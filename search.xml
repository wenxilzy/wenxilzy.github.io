<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>暑期前集训搜索与字符串专题</title>
      <link href="/2022/06/06/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98/"/>
      <url>/2022/06/06/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第356-367题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC356-367%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC356-367%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第336-338题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC336-338%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC336-338%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第320-335题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC320-335%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC320-335%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第304-319题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC304-319%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC304-319%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第288-303题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC288-303%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC288-303%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第272-287题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC272-287%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC272-287%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第256-271题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC256-271%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC256-271%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第240-255题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC240-255%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC240-255%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第224-239题</title>
      <link href="/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC224-239%E9%A2%98/"/>
      <url>/2022/06/05/%E6%AD%A6%E5%BF%A0%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC224-239%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目224">题目224</h2><p>$设函数 (f(x)) 一阶连续可导,且 (f(0)=0), (f’(0)\ne0) ,求 (\lim\limits_{x\to0}\dfrac{\displaystyle\int_0^{x^2}f(t)dt}{x^2\displaystyle\int_0^xf(t)dt})$</p><h3 id="解答">解答</h3><blockquote><p>连续可导：函数可导，且导函数连续</p></blockquote><p>$(f(x)) 一阶连续可导 (\quad\Rightarrow\quad) (\lim\limits_{x \to 0} f’(x_0 + x) = f’(x_0))$</p><p>$[ \begin{aligned} \lim\limits_{x\to0}\dfrac{\displaystyle\int_0^{x^2}f(t)dt}{x^2\displaystyle\int_0^xf(t)dt} &amp;\xlongequal{L’} \lim\limits_{x\to0}\dfrac{2x f(x^2)}{2x\displaystyle\int_0^xf(t)dt + x^2f(x)} \\ &amp;= \lim\limits_{x\to0}\dfrac{2f(x^2)}{2\displaystyle\int_0^xf(t)dt + xf(x)} \\ &amp;\xlongequal{L’} \lim\limits_{x\to0}\dfrac{4xf’(x^2)}{3f(x) + xf’(x)} \\ &amp;= \lim\limits_{x\to0}\dfrac{4f’(x^2)}{3 \cdot \dfrac{f(x)}{x} + f’(x)} \\ &amp;= \frac{4f’(0)}{3 \cdot \lim\limits_{x\to0} \dfrac{f(x)}{x} + f’(0)} \\ &amp;= \frac{4f’(0)}{3f’(0) + f’(0)} \\ &amp;= 1 \\ \end{aligned} ]$</p><h2 id="题目225">题目225</h2><p>$[ \lim_{x\to0^+}\frac {\displaystyle\int_0^x\int_u^xu^2\arctan(1+tu)dtdu} {\displaystyle(\int_0^x\ln(1+t)dt)^2} ]$</p><h3 id="解答-2">解答</h3><p>本题核心思路还是 <strong>洛必达法则</strong> 去 <strong>积分符号</strong></p><p>分子是一个 <strong>积分变量</strong> 分别为 $(t)$ 和 $(u)$ 的 <strong>二重积分</strong>，且两个 <strong>积分上限</strong> 都是 $(x)$ 不好直接 <strong>洛必达</strong></p><p>先考虑一下 <strong>交换积分次序</strong> 的手段，能否解决这个问题（答案是显然的，因为积分域是一个三角形）</p><p>先画出 积分域，是一个边长为 (x) 的 <strong>正方形</strong> <strong>副对角线</strong> 上方的 <strong>三角形区域</strong></p><p>然后利用该 <strong>积分域</strong>，<strong>交换积分次序</strong></p><p>$[ \displaystyle\int_0^x\int_u^xu^2\arctan(1+tu)dtdu = \displaystyle \int_0^x\int_0^t u^2\arctan(1+tu)dudt ]$</p><p>通过 <strong>交换积分次序</strong> 的手段，我们成功在 <strong>积分限</strong> 上只保留了一个$(x)$，接下来就可以 <strong>洛必达</strong> 了</p><p>然后观察一下分母，可以利用 <strong>变上限积分</strong>，对 <strong>被积函数</strong> 做 <strong>等价无穷小代换</strong>，如下：</p><p>$[ \ln(1+x)\sim x \quad\Rightarrow\quad \int_0^x\ln(1+t)dt\sim\int_0^xtdt ]$</p><p>预处理都完成了，剩下的洛就完事了：</p><p>$[ \begin{aligned} &amp;\lim_{x\to0^+}\frac {\displaystyle \int_0^x\int_0^t u^2\arctan(1+tu)dudt} {\displaystyle(\int_0^x t dt)^2} \\ \xlongequal{L’}&amp; \lim_{x\to0^+}\frac {\displaystyle \int_0^x u^2\arctan(1+xu)du} {2x\displaystyle\int_0^xtdt} \\ \xlongequal{\scriptscriptstyle\text{广义积分中值定理}}&amp; \lim_{x\to0^+}\frac {\displaystyle \arctan(1+x\xi) \cdot \int_0^x u^2du} {2x\displaystyle\int_0^xtdt} \quad \text{其中} \xi\in(0,x) \\ =&amp; \frac{\pi}{8} \cdot \lim_{x\to0^+}\frac {\displaystyle \int_0^x u^2du} {x\displaystyle\int_0^x tdt} \\ \xlongequal{L’}&amp; \frac{\pi}{8} \cdot \lim_{x\to0^+}\frac {x^2} {\displaystyle\int_0^x tdt + x^2} \\ \xlongequal{L’}&amp; \frac{\pi}{8} \cdot \lim_{x\to0^+}\frac {2x} {3x} \\ =&amp; \frac{\pi}{12} \end{aligned} ]$</p><h2 id="题目226">题目226</h2><p>$[ \lim_{x\to+\infty}\frac{\displaystyle\int_0^xt|\sin t|dt}{x^2} ]$</p><h3 id="解答-3">解答</h3><p>本题直接 洛必达 的话，洛必达法则会失效</p><p>洛必达法则成立的三大条件：</p><ol><li>$(\dfrac{0}{0},\dfrac{\infty}{\infty}, \dfrac{\cdot}{\infty}) 型$</li><li>函数 $(f(x))$ 和 $(g(x))$ 在 $(x_0)$ 的 <strong>去心邻域内</strong> 可导</li><li>求导后 $(\lim\limits_{x\to x_0}\dfrac{f’(x)}{g’(x)} = A)$ 存在 $（(A)$ 可为 <strong>实数</strong>，也可为$(\infty)）$</li></ol><p>本题直接求导的话，原式 = $(\lim\limits_{x\to+\infty}\dfrac{|\sin x|dt}{2})$ 极限不存在，故 <strong>洛必达失效</strong></p><hr><p>考虑一下如何求解该题，对于 绝对值函数 来说，首要目标就是去 绝对值</p><p>$(|\sin x|) 的 周期 是 (\pi)，故我们可以考虑能不能用 不等式 进行 放缩，然后 夹逼$</p><p>$对于任意 (k\pi \lt x \lt k\pi + \pi)，有：$</p><p>$[ \begin{aligned} \int_0^{k\pi}t|\sin t|dt &amp;\lt \int_0^xt|\sin t|dt &amp;\lt \int_0^{k\pi + \pi}t|\sin t|dt \end{aligned} ]$</p><p>$考虑如何求积分 (\displaystyle \int_0^{k\pi}t|\sin t|dt)$</p><p>$[ \begin{aligned} I_1 &amp;= \int_0^{\pi} t|\sin t| dt = \pi \\ I_2 &amp;= \int_\pi^{2\pi} t|\sin t| dt = 3\pi \\ \cdots \\ I_n &amp;= \int_{(n-1)\pi}^{n\pi} t|\sin t| dt = (2n - 1)\pi \\ \end{aligned} ]$</p><p>$故 (\displaystyle \int_0^{k\pi}t|\sin t|dt = k^2\pi)$</p><blockquote><p>这里分享另一个做法(区间再现+积分再现) $ [ \begin{aligned} \int_0^{k\pi}t|\sin t|dt &amp;= \int_0^{k\pi}(k\pi - t)|\sin (k\pi - t)|dt \\ &amp;= k\pi\int_0^{k\pi}|\sin t|dt - \int_0^{k\pi} t|\sin t|dt \\ I &amp;= k\pi\int_0^{k\pi}|\sin t|dt - I \\ I &amp;= \frac{k\pi}{2}\int_0^{k\pi}|\sin t|dt \\ \end{aligned} ]$ 而积分 $(\displaystyle\int_0^{k\pi} |\sin t|dt = 2k)$ 是显然的$（一拱的面积为 (2)，(k) 拱的面积为 (2k)） 则 (I = k^2\pi)$，这个做法必上述递推要简单</p></blockquote><p>接着我们的任务就是 凑出题设的极限，然后 夹逼</p><p>$[ \lim_{x\to+\infty}\frac{k^2\pi}{x^2} \lt \lim_{x\to+\infty}\frac{\displaystyle\int_0^xt|\sin t|dt}{x^2} \lt \lim_{x\to+\infty}\frac{(k+1)^2\pi}{x^2} ]$</p><p>由 $kx k+ x - kx {x+} {x+} _{x+} $</p><p>$故 (\lim\limits_{x\to+\infty}\dfrac{k^2\pi}{x^2} = \dfrac{1}{\pi})，代入不等式中夹逼可得：(\lim\limits_{x\to+\infty}\dfrac{\displaystyle\int_0^xt|\sin t|dt}{x^2} = \dfrac{1}{\pi})$</p><hr><p>知道 O’Stolz定理（洛必达推广的离散型） 这题就变成 构造题 了</p><p>$令 (x_n = \displaystyle\int_0^{n\pi} t|\sin t|dt)，(y_n = x^2)，由于 (\{y_n\}) 单调递增，且 (\lim\limits_{n\to\infty} y_n = +\infty)$，由 O’Stolz 定理：</p><p>$[ \lim_{n\to+\infty} \frac{x_n}{y_n} = \lim_{n\to+\infty} \frac{x_{n+1} - x_n}{y_{n+1} - y_n} = \lim_{n\to+\infty} \frac{\dfrac{(2n+2)(n+1)\pi}{2} - \dfrac{n\cdot 2n\pi}{2}}{(n\pi + \pi)^2 - (n\pi)^2} = \dfrac{1}{\pi} ]$</p><p>再由 海涅定理 可知：</p><p>$[ \lim_{n\to+\infty} \frac{\displaystyle\int_0^xt|\sin t|dt}{x^2} = \lim_{n\to+\infty} \frac{x_n}{y_n} = \dfrac{1}{\pi} ]$</p><h2 id="题目227">题目227</h2><p>$[ \text{求极限 }\lim_{x\to+\infty}\sin\frac{1}{x}\cdot\int_x^{x^2} (1+\frac{1}{2t})^t\sin\frac{1}{\sqrt{t}}dt ]$</p><h3 id="解答-4">解答</h3><p>$[ \begin{aligned} &amp; \lim_{x\to+\infty}\sin\frac{1}{x}\cdot\int_x^{x^2} (1+\frac{1}{2t})^t\sin\frac{1}{\sqrt{t}}dt \\ =&amp; \lim_{x\to+\infty}[\frac{\displaystyle\int_x^{x^2} (1+\frac{1}{2t})^t\sin\frac{1}{\sqrt{t}}dt}{x}] \\ \xlongequal{L’}&amp; \lim_{x\to+\infty}[2x(1+\frac{1}{2x^2})^{x^2}\cdot \sin\frac{1}{x} - (1+\frac{1}{2x})^{x}\cdot \sin\frac{1}{\sqrt{x}}] \\ =&amp; \lim_{x\to+\infty}[2 \cdot e^{x^2\ln(1+\frac{1}{2x^2})} - e^{x\ln(1+\frac{1}{2x})}\cdot \frac{1}{\sqrt{x}}] \\ =&amp; 2\lim_{x\to+\infty}e^{x^2\ln(1+\frac{1}{2x^2})} - \lim_{x\to+\infty} e^{x\ln(1+\frac{1}{2x})}\cdot \frac{1}{\sqrt{x}} \\ =&amp; 2e^{\frac{1}{2}} - 0 \\ =&amp; 2e^{\frac{1}{2}} \\ \end{aligned} ]$</p><h2 id="题目228">题目228</h2><p>$[ \text{求极限 }\lim_{x\to+\infty}x(1-\frac{\ln x}{x})^x ]$</p><h3 id="解答1-暴力解">解答1(暴力解)</h3><p>$“(\infty \cdot 0)” 型，考虑倒代还化为 “(\dfrac{0}{0})” 型$</p><p>$令 (x = \dfrac{1}{t})，则：$</p><p>$[ \begin{aligned} \lim_{x\to+\infty} x(1-\frac{\ln x}{x})^x &amp;= \lim_{t\to0^+} \frac{(1+t\ln t)^{\dfrac{1}{t}}}{t} \\ &amp;= \lim_{t\to0^+} \frac{e^{\dfrac{\ln(1 + t\ln t)}{t}}}{t} \\ &amp;= \lim_{t\to0^+} \frac{e^{\dfrac{t\ln t - \frac{1}{2}t^2\ln^2 t + o(t^2\ln^2t)}{t}}}{t} \\ &amp;= \lim_{t\to0^+} \frac{e^{\ln t}}{t} \\ &amp;= \lim_{t\to0^+} \frac{t}{t} \\ &amp;= 1 \end{aligned} ]$</p><h3 id="解答2（取对数）">解答2（取对数）</h3><p>考虑乘积幂次都有的式子，不妨取对数，转化为加减法（求导里常用）</p><p>令 $(y = x(1-\dfrac{\ln x}{x})^x)$</p><p>$[ \begin{aligned} \lim_{x\to+\infty} \ln y &amp;= \lim_{x\to+\infty} [\ln x + x\ln(1 - \dfrac{\ln x}{x})] \\ &amp;= \lim_{x\to+\infty} x[\ln(1 - \dfrac{\ln x}{x}) - (-\dfrac{\ln x}{x})] \\ &amp;= \lim_{x\to+\infty} x[-\dfrac{1}{2}(-\dfrac{\ln x}{x})^2] \\ &amp;= -\frac{1}{2} \lim_{x\to+\infty} \dfrac{\ln^2 x}{x} \\ &amp;= 0 \end{aligned} ]$</p><p>$(\lim\limits_{x\to+\infty} \ln y = 0 \quad\Rightarrow\quad \lim\limits_{x\to+\infty} y = 1)$</p><h2 id="题目229">题目229</h2><p>$[ \text{求极限 }\lim_{x\to0}\Bigg(\frac{1 + \displaystyle\int_0^xe^{t^2}dt}{e^x-1} - \frac{1}{\sin x}\Bigg) ]$</p><h3 id="解答-5">解答</h3><p>$[ \begin{aligned} \lim_{x\to0}\Bigg(\frac{1 + \displaystyle\int_0^xe^{t^2}dt}{e^x-1} - \frac{1}{\sin x}\Bigg) &amp;= \lim_{x\to0}\Bigg(\frac{\displaystyle\int_0^xe^{t^2}dt}{e^x-1} - \frac{\sin x - e^x + 1}{(e^x-1)\sin x}\Bigg) \\ &amp;= \lim_{x\to0} \frac{\displaystyle\int_0^xe^{t^2}dt}{e^x-1} - \lim_{x\to0}\frac{\sin x - e^x + 1}{(e^x-1)\sin x} \\ &amp;= \lim_{x\to0} \frac{\displaystyle\int_0^xe^{t^2}dt}{x} - \lim_{x\to0}\frac{x - x - \dfrac{1}{2}x^2}{x^2} \\ &amp;= 1 - \dfrac{1}{2} \\ &amp;= \frac{1}{2} \end{aligned} ]$</p><h2 id="题目230">题目230</h2><p>$[ \lim_{x\to0}\Big[\frac{1}{\ln(x+\sqrt{1+x^2})} - \frac{1}{\ln(1+x) + \int_0^xt(1+t)^{\frac{1}{t}}dt}\Big] ]$</p><h3 id="解答-6">解答</h3><p>$[ \lim_{x\to0}\frac{\ln(x+\sqrt{1+x^2})}{x} = 1 \quad\Rightarrow\quad \ln(x+\sqrt{1+x^2}) \sim x ]$</p><p>$[ \lim_{x\to0}\frac{\int_0^xt(1+t)^{\frac{1}{t}}dt}{x} = 0 \quad\Rightarrow\quad \Big[ \ln(1+x) + \int_0^xt(1+t)^{\frac{1}{t}}dt\Big] \sim \ln(1+x) \sim x ]$</p><p>$[ \begin{aligned} &amp; \lim_{x\to0}\Big[\frac{1}{\ln(x+\sqrt{1+x^2})} - \frac{1}{\ln(1+x) + \displaystyle\int_0^xt(1+t)^{\frac{1}{t}}dt}\Big] \\ =&amp; \lim_{x\to0}\frac {\ln(1 + x) + \displaystyle\int_0^xt(1 + t)^{\frac{1}{t}}dt - \ln(x+\sqrt{1+x^2})} {x^2} \\ =&amp; \lim_{x\to0}\Bigg[\frac{\ln(1+x) - \ln(x+\sqrt{1+x^2})}{x^2}\Bigg] + \lim_{x\to0}\Bigg[\frac{\int_0^xt(1+t)^{\frac{1}{t}}dt}{x^2}\Bigg] \quad(极限的四则运算) \\ =&amp; \lim_{x\to0}\Bigg[\frac{\dfrac{1}{\xi}(1 - \sqrt{1+x^2})}{x^2}\Bigg] + \lim_{x\to0}\Bigg[\frac{x(1+x)^{\frac{1}{x}}}{2x}\Bigg] \quad\bigg(Lagrange中值定理\bigg) \\ =&amp; \lim_{x\to0}\Bigg(\frac{1 \cdot (-1)}{2\sqrt{1+x^2}}\Bigg) + \lim_{x\to0}\Bigg(\frac{e}{2}\Bigg) \quad(洛必达) \\ =&amp; \frac{e - 1}{2} \end{aligned} ]$</p><h2 id="题目231">题目231</h2><p>$[ \lim_{x\to+\infty} \bigg[{ (x^3 - x^2 + \dfrac{x}{2} + 1) e^{\frac{1}{x}} - \sqrt{x^6 + x^2 + x + 1} }\bigg] ]$</p><h3 id="解答-7">解答</h3><p>$[ \begin{aligned} &amp;\lim_{x\to+\infty} \bigg[{ (x^3 - x^2 + \dfrac{x}{2} + 1) e^{\frac{1}{x}} - x^3 + x^3 - \sqrt{x^6 + x^2 + x + 1} }\bigg] \\ =&amp; \lim_{x\to+\infty} x^3 [(1-\dfrac{1}{x} + \dfrac{1}{2x^2} + \dfrac{1}{x^3})e^{\frac{1}{x}} - \sqrt{1 + \dfrac{1}{x^4} + \dfrac{1}{x^5} + \dfrac{1}{x^6}}] \\ =&amp; \lim_{x\to+\infty} x^3 \cdot e^{\frac{1}{x}} [(1-\dfrac{1}{x} + \dfrac{1}{2x^2} + \dfrac{1}{x^3}) - e^{-\frac{1}{x}}\sqrt{1 + \dfrac{1}{x^4} + \dfrac{1}{x^5} + \dfrac{1}{x^6}}] \\ =&amp; \lim_{x\to+\infty} x^3 \cdot [(1-\dfrac{1}{x} + \dfrac{1}{2x^2} + \dfrac{1}{x^3}) - (1 - \dfrac{1}{x} + \dfrac{1}{2x^2} - \dfrac{1}{6x^3}) (1 + o(\dfrac{1}{x^3}))] \\ =&amp; \lim_{x\to+\infty} x^3 \cdot [\dfrac{7}{6} \cdot \dfrac{1}{x^3} + o(\dfrac{1}{x^3})] \\ =&amp; \dfrac{7}{6} \end{aligned} ]$</p><h2 id="题目232">题目232</h2><p>$[ \lim_{x \to 0} \frac{\ln(1+\sin^2 x) - 6(\sqrt[3]{2-\cos x} - 1)}{x^4} ]$</p><h3 id="解答-8">解答</h3><p>复合函数处理方法： 1. 强行泰勒展开（多项式计算量大） 2. 添项减项（精度随缘）</p><p>$[ \ln(1 + \sin^2 x) - \sin ^2x \sim -\dfrac{1}{2}\sin^4x \sim -\dfrac{1}{2}x^4 ]$</p><p>$[ (1 + x)^{\frac{1}{3}} - 1 - x \sim -\dfrac{1}{9} x^2 ]$</p><p>$[ [1 + (1 - \cos x)]^{\frac{1}{3}} - 1 - \dfrac{1}{3}(1 - \cos x)\sim -\dfrac{1}{9} (1 - \cos x)^2 \sim -\dfrac{1}{36} x^4 ]$</p><p>$[ \begin{aligned} &amp;\lim_{x \to 0} \frac{\ln(1+\sin^2 x) - 6(\sqrt[3]{2-\cos x} - 1)}{x^4} \\ =&amp; \lim_{x \to 0} \frac{\ln(1+\sin^2 x) - \sin^2x + 2(1-\cos x)- 6(\sqrt[3]{2-\cos x} - 1)+\sin^2x - 2(1 - \cos x) }{x^4} \end{aligned} ]$</p><p>$[ \dfrac{\sin^2x - 2 + 2\cos x}{x^4} = \dfrac{\cos x - 1}{2x^2} = -\dfrac{1}{4} ]$</p><p>$[ \begin{aligned} &amp; \lim_{x \to 0} \frac{\ln(1+\sin^2 x) - \sin^2x}{x^4} - \lim_{x \to 0} \frac{-2(1-\cos x) + 6(\sqrt[3]{2-\cos x} - 1)}{x^4} \\ +&amp; \lim_{x \to 0} \frac{\sin^2x - 2(1 - \cos x)}{x^4} \\ = &amp; -\dfrac{1}{2} + \dfrac{1}{6} + \dfrac{1}{4} = -\dfrac{7}{12} \end{aligned} ]$</p><h2 id="题目233">题目233</h2><p>$[ \lim_{x\to0} \int_0^x\Big(\frac{\arctan t}{t}\Big)^{\dfrac{1}{\int_0^t\ln(1+u)du}}\cot x dt ]$</p><h3 id="解答-9">解答</h3><p>$[ \begin{aligned} &amp; \lim_{x\to0} \int_0^x\Big(\frac{\arctan t}{t}\Big)^{\dfrac{1}{\int_0^t\ln(1+u)du}}\cot x dt \\ =&amp; \lim_{x\to0} \dfrac{\displaystyle\int_0^x \Big(\dfrac{\arctan t}{t}\Big)^{\dfrac{1}{\int_0^t\ln(1+u)du}}dt}{\tan x} \\ =&amp; \lim_{x\to0} \Big(\dfrac{\arctan t}{t}\Big)^{\dfrac{1}{\int_0^t\ln(1+u)du}}dt \\ &amp; \lim_{x\to0} \dfrac{\ln(\dfrac{\arctan t}{t})}{\displaystyle\int_0^t \ln(1+u)du} \\ =&amp; \lim_{x\to0} \dfrac{\arctan t - t}{t\displaystyle\int_0^t udu} \\ =&amp; -\dfrac{2}{3} \\ &amp; \lim_{x\to0} \int_0^x\Big(\frac{\arctan t}{t}\Big)^{\dfrac{1}{\int_0^t\ln(1+u)du}}\cot x dt \\ =&amp; e^{-\frac{2}{3}} \end{aligned} ]$</p><h2 id="题目234">题目234</h2><p>$[ \lim_{x\to+\infty}\Big[\frac{\ln(x+\sqrt{x^2+1})}{\ln(x+\sqrt{x^2-1})}\Big]^{x^2\ln x} ]$</p><h3 id="解答-10">解答</h3><p>$[ \lim\limits_{x\to+\infty}\frac{\ln(x+\sqrt{x^2-1})}{\ln x} = 1 \quad\Rightarrow\quad \ln(x+\sqrt{x^2-1}) \sim \ln x ]$</p><p>$[ \lim\limits_{x\to+\infty}\frac{\sqrt{x^2+1} - \sqrt{x^2-1}}{\frac{1}{x}} = 1 \quad\Rightarrow\quad \sqrt{x^2+1} - \sqrt{x^2-1} \sim \dfrac{1}{x} ]$</p><p>$[ \begin{aligned} 原式 &amp;= \lim_{x\to+\infty} e^{x^2\ln x\cdot\ln(\frac{\ln(x+\sqrt{x^2+1})}{\ln(x+\sqrt{x^2-1})})} \quad(幂指函数互化) \\ &amp;= e^{\lim\limits_{x\to+\infty}x^2\ln x\cdot (\frac{\ln(x+\sqrt{x^2+1}) - \ln(x+\sqrt{x^2-1})}{\ln(x+\sqrt{x^2-1})})} \quad(等价无穷小代换) \\ &amp;= e^{\lim\limits_{x\to+\infty}x^2\ln x\cdot (\frac{\ln(x+\sqrt{x^2+1}) - \ln(x+\sqrt{x^2-1})}{\ln x})} \quad(\ln(x+\sqrt{x^2-1}) \sim \ln x) \\ &amp;= e^{\lim\limits_{x\to+\infty}x^2\cdot \Big((\ln(x+\sqrt{x^2+1}) - \ln(x+\sqrt{x^2-1})\Big)} \quad = e^{\lim\limits_{x\to+\infty}x^2\cdot \ln\frac{x+\sqrt{x^2+1}}{x+\sqrt{x^2-1}}} \quad (\ln\frac{A}{B} = \ln A - \ln B) \\ &amp;= e^{\lim\limits_{x\to+\infty}x^2\cdot \frac{x+\sqrt{x^2+1} - x - \sqrt{x^2-1}}{x+\sqrt{x^2-1}}} \quad = e^{\lim\limits_{x\to+\infty}x^2\cdot \frac{\sqrt{x^2+1} - \sqrt{x^2-1}}{x+\sqrt{x^2-1}}} \quad(等价无穷小代换) \\ &amp;= e^{\lim\limits_{x\to+\infty}x^2\cdot \frac{\frac{1}{x}}{x+\sqrt{x^2-1}}} \quad = e^{\lim\limits_{x\to+\infty}\frac{x}{x+\sqrt{x^2-1}}} \quad(\sqrt{x^2+1} - \sqrt{x^2-1} \sim \dfrac{1}{x}) \\ &amp;= e^{\frac{1}{2}} \end{aligned} ]$</p><h2 id="题目235">题目235</h2><p>$设 (f(x)) 连续, (\lim\limits_{x\to0}\dfrac{f(x)}{x}=1) ,求极限 (\lim\limits_{x\to0}\Big[ 1+\displaystyle\int_0^xtf(x^2-t^2)dt \Big]^{\dfrac{1}{(\tan x - x)\ln(1+x)}})$</p><h3 id="解答-11">解答</h3><p>$(f(x)) 连续 (\&amp;) $_{x0}=1 $ (\quad \Rightarrow \quad) (f(0) = 0) 且 (f’(0) = 1)$</p><p>幂指函数，先取指对数，然后单独处理指数部分</p><p>$[ \begin{aligned} &amp; \lim_{x\to0} \dfrac{\ln(1 + \displaystyle\int_0^x tf(x^2 - t^2)dt)}{(\tan x - x) \ln(1 + x)} \\ =&amp; \lim_{x\to0} \dfrac{\displaystyle\int_0^x tf(x^2 - t^2)dt}{\dfrac{1}{3}x^4} \\ &amp; \text{令} x^2 - t^2 = u, \text{则} -2tdt = du \\ =&amp; \dfrac{3}{2} \lim_{x\to0} \dfrac{\displaystyle\int_0^{x^2} f(u)du}{x^4} \\ \xlongequal{L’}&amp; \dfrac{3}{4} \lim_{x\to0} \dfrac{f(x^2)}{x^2} \\ =&amp; \dfrac{3}{4} \lim_{x\to0} \dfrac{f(x^2) - f(0)}{x^2 - 0} \\ =&amp; \dfrac{3}{4} f_+'(0) \\ =&amp; \dfrac{3}{4} \\ \end{aligned} ]$</p><p>故 $(\lim\limits_{x\to0}\Big[ 1+\displaystyle\int_0^xtf(x^2-t^2)dt \Big]^{\dfrac{1}{(\tan x - x)\ln(1+x)}} = e^{\frac{3}{4}})$</p><h2 id="题目236">题目236</h2><p>$[ \lim_{x\to+\infty} \Big(x^{\frac{1}{x}} - 1\Big)^{\frac{1}{\ln x}} ]$</p><h3 id="解答-12">解答</h3><p>这里介绍一个 <strong>对数函数的等价无穷大技巧</strong>：</p><p>$若 (x \to x_0) 时，(A) 与 (B) 是等价无穷小 （(A \sim B)），则 (\ln A) 与 (\ln B) 是 等价无穷大$</p><p>证明：</p><p>$[ \text{欲证：}\lim_{x\to x_0} \dfrac{\ln A}{\ln B} = 1,\text{不妨证} \lim_{x\to x_0} \dfrac{\ln A}{\ln B} - 1 = 0 ]$</p><p>$[ \lim_{x\to x_0} \dfrac{\ln A}{\ln B} - 1 = \lim_{x\to x_0} \dfrac{\ln A - \ln B}{\ln B} = \lim_{x\to x_0} \dfrac{\ln\dfrac{A}{B}}{\ln B} = \dfrac{0}{\infty} = 0 \quad QED ]$</p><p>在本题中，取过指对数后，可利用该技巧：</p><p>$[ \begin{aligned} &amp;\lim_{x\to +\infty} \dfrac{\ln (e^{\dfrac{\ln x}{x}} - 1)}{\ln x} \\ =&amp;\lim_{x\to +\infty} \dfrac{\ln ({\dfrac{\ln x}{x}})}{\ln x} \\ =&amp; \lim_{x\to +\infty} \dfrac{\ln\ln x - \ln x}{\ln x} \\ \xlongequal{L’}&amp; \lim_{x\to +\infty} \dfrac{1 - \ln x}{\ln x} \\ =&amp; -1 \end{aligned} ]$</p><p>故原式 = $(e^{-1})$</p><h2 id="题目237">题目237</h2><p>若 $(\lim\limits_{x\to0}\dfrac{\cos(xe^x)-e^{-\dfrac{x^2e^{2x}}{2}}}{x^\alpha}= \beta\ne0)，求 (\alpha,\beta)$</p><h3 id="解答-13">解答</h3><blockquote><p>已知极限反求参数，<strong>不能使用洛必达，不能使用洛必达，不能使用洛必达</strong> 这个行为违背了洛必达的 <strong>先验性</strong> 在已知极限的情况下，再洛必达获得的新极限，不一定与原极限相等</p></blockquote><p>由泰勒展开：</p><p>$[ \cos(xe^x) = 1 - \dfrac{1}{2} (x^2e^{2x}) + \dfrac{1}{24}x^4e^{4x} + o(x^4e^{4x}) ]$</p><p>$[ e^{-\dfrac{x^2e^{2x}}{2}} = 1 - \dfrac{1}{2}(x^2e^{2x}) + \dfrac{1}{8}(x^4e^{4x}) + o(x^4e^{4x}) ]$</p><p>可以推得：</p><p>$[ \cos(xe^x)-e^{-\dfrac{x^2e^{2x}}{2}} \sim -\dfrac{1}{12}x^4e^{4x} ]$</p><p>故：</p><p>$[ \lim\limits_{x\to0}\dfrac{\cos(xe^x)-e^{-\dfrac{x^2e^{2x}}{2}}}{x^\alpha} = \lim\limits_{x\to0} \dfrac{-\dfrac{1}{12}x^4}{x^\alpha} = \beta \ne 0 ]$</p><p>由于 极限存在，且不为 $(0)$，故 $(\alpha = 4, \beta = - \dfrac{1}{12})$</p><h2 id="题目238">题目238</h2><p>$[ \lim_{x\to0}\frac{\cos 2x - \cos x\sqrt{\cos 2x}}{x^k} = a \ne 0,\text{求k,a} ]$</p><h3 id="解答-14">解答</h3><p>对 <strong>分子</strong> 恒等变形：</p><p>$[ \begin{aligned} \cos 2x - \cos x\sqrt{\cos 2x} &amp;= \sqrt{\cos 2x} \cdot (\sqrt{\cos 2x} - \cos x) \\ &amp;= \sqrt{\cos 2x} \cdot \dfrac{\cos 2x - \cos^2 x}{\sqrt{\cos 2x} + \cos x} \\ &amp;= \dfrac{\sqrt{\cos 2x}}{\sqrt{\cos 2x} + \cos x} \cdot (2\cos^2 x - 1 - \cos^2 x) \\ &amp;= \dfrac{\sqrt{\cos 2x}}{\sqrt{\cos 2x} + \cos x} \cdot (\cos^2 x - 1) \\ &amp;= \dfrac{\sqrt{\cos 2x}}{\sqrt{\cos 2x} + \cos x} \cdot (- \sin^2 x) \\ \end{aligned} ]$</p><p>故原式为</p><p>$[ \begin{aligned} \lim_{x\to0}\frac{\cos 2x - \cos x\sqrt{\cos 2x}}{x^k} &amp;= \lim_{x\to0} \dfrac{\sqrt{\cos 2x}}{\sqrt{\cos 2x} + \cos x} \cdot \frac{(- \sin^2 x)}{x^k} \\ &amp;= -\dfrac{1}{2} \lim_{x\to0} \frac{\sin^2 x}{x^k} \\ &amp;= -\dfrac{1}{2} \lim_{x\to0} \frac{x^2}{x^k} \\ \end{aligned} ]$</p><p>由于 <strong>极限存在</strong>，故 $(k = 2, a = -\dfrac{1}{2})$</p><h2 id="题目239">题目239</h2><p>若 $(\lim\limits_{x\to0}\dfrac{ax^2+bx+1-e^{x^2-2x}}{x^2}=2)$,求$(a,b)$的值</p><h3 id="解答-15">解答</h3><p>由 <strong>泰勒展开</strong>：</p><p>$[ e^{x^2 - 2x} - 1 = x^2 - 2x + \dfrac{1}{2}(x^2 - 2x)^2 + o(x)^2 = 3x^2 - 2x + o(x^2) ]$</p><p>故可对原式进行 <strong>泰勒展开</strong>：</p><p>$[ \lim\limits_{x\to0}\dfrac{ax^2+bx+1-e^{x^2-2x}}{x^2} = \lim\limits_{x\to0}\dfrac{(a - 3)x^2+(b + 2)x}{x^2} ]$</p><p>极限存在，故 $(b = -2, a = 5)$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武忠祥老师每日一题第211-223题</title>
      <link href="/2022/06/04/%E6%AD%A6%E9%92%9F%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC211-223%E9%A2%98/"/>
      <url>/2022/06/04/%E6%AD%A6%E9%92%9F%E7%A5%A5%E8%80%81%E5%B8%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC211-223%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目211">题目211</h2><p>设 $(f(x)=1-\cos{x})$，求极限 $(\lim\limits_{x\to0}\dfrac{(1-\sqrt{\cos{x}})(1-\sqrt[3]{\cos{x}})(1-\sqrt[4]{\cos{x}})(1-\sqrt[5]{\cos{x}})}{f\{f[f(x)]\}})$</p><h3 id="解答-16">解答</h3><p>当 $(x \to 0)$ 时：</p><p>$[ 1-\sqrt{\cos x} \sim 1 - (1 - \frac{1}{2}x^2)^{\frac{1}{2}} \sim -(-\frac{1}{4})x^2 = \frac{1}{4}x^2 ]$</p><p>同理，由此推导可证得：$(1 - \cos^\alpha x \sim \dfrac{1}{2} \alpha x^2)$</p><p>$[ \begin{aligned} \text{原式} &amp;= \frac {\dfrac{1}{4} \cdot \dfrac{1}{6} \cdot \dfrac{1}{8} \cdot \dfrac{1}{10} \cdot x^8} {1 - \cos(f[f(x)])} \\ &amp;= \frac {\dfrac{x^8}{1920}} {\dfrac{1}{2}[1 - \cos f(x)]^2} \\ &amp;= \frac {\dfrac{x^8}{1920}} {\dfrac{1}{2}[\dfrac{1}{2}(1 - \cos x)^2]^2} \\ &amp;= \frac {\dfrac{x^8}{1920}} {\dfrac{1}{128} \cdot x^8} \\ &amp;= \frac{1}{15} \\ \end{aligned} ]$</p><h2 id="题目-212">题目 212</h2><p>$[ \text{求极限 } \lim_{x\to0}\frac{\tan(\sin x) - x}{\arctan x - \arcsin x} ]$</p><h3 id="解答-17">解答</h3><p>该极限为 $(\dfrac{0}{0})$ 型极限，常用方法有：</p><ol><li>洛必达法则</li><li>等价无穷小</li><li>泰勒展开<br>$[ \tan x - x \sim \frac{1}{3}x^3 \quad\Rightarrow\quad \tan(\sin x) - \sin x \sim \frac{1}{3}\sin^3x ]$</li></ol><p>由以上 等价无穷小，我们可以考虑 加减交叉项 凑出需要的形式</p><p>$[ \begin{aligned} \text{原式} &amp;= \lim_{x\to 0} \frac{\tan(\sin x) - \sin x + \sin x - x}{-\dfrac{1}{3}x^3 - \dfrac{1}{6}x^3} \\ &amp;= -2\lim_{x\to 0} \frac{\tan(\sin x) - \sin x}{x^3} -2\lim_{x\to 0} \frac{\sin x - x}{x^3} \\ &amp;= -2\lim_{x\to 0} \frac{\dfrac{1}{3}\sin^3 x}{x^3} -2\lim_{x\to 0} \frac{-\dfrac{1}{6}x^3}{x^3} \\ &amp;= -\frac{2}{3} + \frac{1}{3} \\ &amp;= -\frac{1}{3} \\ \end{aligned} ]$</p><h2 id="题目-213">题目 213</h2><p>$$[ \text{求极限 } \lim_{x\to0}\frac{\sqrt[4]{1-\sqrt[3]{1-\sqrt{1-x}}} - 1} {(1+x)^\frac{1}{\sqrt[3]{x^2}} - 1} ]$$</p><h3 id="解答-18">解答</h3><p>$[ \sqrt[4]{1-\sqrt[3]{1-\sqrt{1-x}}} - 1 \sim \sqrt[4]{1-\sqrt[3]{\frac{1}{2}x}} - 1 \sim -\frac{1}{2^{\frac{7}{3}}}x^{\frac{1}{3}} ]$</p><p>$[ (1+x)^\frac{1}{\sqrt[3]{x^2}} - 1 \sim x^{\frac{1}{3}} ]$</p><p>$[ \text{原式} = \lim_{x\to0}\frac{-\dfrac{1}{2^{\frac{7}{3}}}x^{\frac{1}{3}}}{x^{\frac{1}{3}}} = -\frac{1}{2^{\frac{7}{3}}} ]$</p><h2 id="题目-214">题目 214</h2><p>$$[ \lim_{x\to0}\frac{(3+\sin x^2)^x-3^{\sin x}}{x^3} ]$$</p><h3 id="解答-19">解答</h3><p>底数相同 的 幂指函数 相减，一般考虑 左提右式 或 拉格朗日中值定理（不推荐）</p><p>$[ \begin{aligned} \lim_{x\to0}\frac{(3+\sin x^2)^x-3^{\sin x}}{x^3} &amp;= \lim_{x\to0}\frac{e^{x\ln(3+\sin x^2)} - e^{\sin x\ln 3}}{x^3} \\ &amp;= \lim_{x\to0}\frac{e^{\sin x\ln 3}[x\ln(3+\sin x^2) - \sin x\ln 3]}{x^3} \\ &amp;= \lim_{x\to0}\frac{x\ln(3+\sin x^2) - x\ln 3 - (\sin x\ln 3 - x\ln 3)}{x^3} \\ &amp;= \lim_{x\to0}\frac{x\cdot [\ln(3+\sin x^2) - \ln 3]}{x^3} - \ln 3\cdot \lim_{x\to0}\frac{\sin x - x}{x^3} \\ &amp;= \lim_{x\to0}\frac{x\cdot \ln(1+\dfrac{\sin x^2}{3})}{x^3} + \frac{\ln 3}{6} \\ &amp;= \lim_{x\to0}\frac{x \cdot \sin x^2}{3x^3} + \frac{\ln 3}{6} \\ &amp;= \frac{1}{3} + \frac{\ln 3}{6} \\ &amp;= \frac{2 + \ln 3}{6} \\ \end{aligned} ]$</p><h2 id="题目-215">题目 215</h2><p>$$[ \text{求极限 }\lim_{x\to 1}\frac{x - x^x}{1 - x + \ln x} ]$$</p><h3 id="解答-20">解答</h3><p>先处理分子：</p><p>$[ \lim_{x\to 1}\frac{x - x^x}{1 - x + \ln x} = \lim_{x\to 1}x \cdot \frac{1 - x^{x - 1}}{1 - x + \ln x} = -\lim_{x\to 1}\frac{e^{(x-1)\ln x} - 1}{1 - x + \ln x} = -\lim_{x\to 1}\frac{(x-1)\ln x}{1 - x + \ln x} ]$</p><p>不妨换元，令 $(t = x - 1)，则 (x = 1 + t)$</p><p>$[ \text{原式}= -\lim_{t\to0} \frac {t\ln(1 + t)} {ln(1 + t) - t} = -\lim_{t\to0} \frac {t^2} {\bigg(t - \dfrac{1}{2}t^2 + o(t^2)\bigg) - t} = 2 ]$</p><h2 id="题目-216">题目 216</h2><p>$$[ \text{求极限 } \lim_{x\to0}\frac{(1+x)^{\frac{2}{x}} - e^2[1 - \ln(1+x)]}{x} ]$$</p><h3 id="解答-21">解答</h3><p>$$[ \begin{aligned} \lim_{x\to0}\frac{(1+x)^{\frac{2}{x}} - e^2[1 - \ln(1+x)]}{x} &amp;= \lim_{x\to0}\frac{e^{\frac{2\ln(1 + x)}{x}} - e^2[1 - \ln(1+x)]}{x} \\ &amp;= e^2 \cdot \lim_{x\to0}\frac{e^{\frac{2\ln(1 + x) - 2x}{x}} - 1 + \ln(1+x)}{x} \\ &amp;= e^2 \cdot \lim_{x\to0}\frac{e^{\frac{2\ln(1 + x) - 2x}{x}} - 1}{x} + e^2 \cdot \lim_{x\to0}\frac{\ln(1+x)}{x} \\ &amp;= e^2 \cdot \lim_{x\to0}\frac{2\ln(1 + x) - 2x}{x^2} + e^2 \\ &amp;= -e^2 + e^2 \\ &amp;= 0 \end{aligned} ]$$</p><h2 id="题目-217">题目 217</h2><p>$$[ \text{求极限 } \lim_{x\to0}\frac{(1+x)^{\frac{1}{x}} - (1 + 2x)^{\frac{1}{2x}}}{\sin x} ]$$</p><h3 id="解答-22">解答</h3><p>$$[ \begin{aligned} \lim_{x\to0}\frac{(1+x)^{\frac{1}{x}} - (1 + 2x)^{\frac{1}{2x}}}{\sin x} &amp;= \lim_{x\to0}\frac{e^{\frac{\ln(x + 1)}{x}} - e^{\frac{\ln(2x + 1)}{2x}}}{x} \\ &amp;= \lim_{x\to0} e^{\frac{\ln(2x + 1)}{2x}} \cdot \frac{e^{\frac{2\ln(x + 1) - \ln(2x + 1)}{2x}} - 1}{x} \\ &amp;= e\cdot \lim_{x\to0} \frac{2\ln(x + 1) - \ln(2x + 1)}{2x^2} \\ &amp;= e\cdot \lim_{x\to0} \frac{2x -x^2 - 2x + 2x^2 + o(x^2)}{2x^2} \\ &amp;= \frac{e}{2} \end{aligned} \ ] $$</p><h2 id="题目-218">题目 218</h2><p>$$[ \text{求极限 } \lim_{x\to0}\frac{x\sin x^2 - 2(1 - \cos x)\sin x}{x^5} ]$$</p><h3 id="解答-23">解答</h3><p>$[ x\sin x^2 = x^3 - \dfrac{1}{6}x^6 + o(x^6) \quad ]$</p><p>$[ 2(1 - \cos x) \sin x = (x^2 - \dfrac{1}{12}x^4 + o(x^4)) \cdot (x - \dfrac{1}{6}x^3 + o(x^3)) = x^3 - (\frac{1}{6} + \frac{1}{12}) x^5 + o(x^5) ]$</p><p>$[ \lim_{x\to0}\frac{x\sin x^2 - 2(1 - \cos x)\sin x}{x^5} = \lim_{x\to0}\frac{x^3 - \dfrac{1}{6}x^6 - x^3 + \dfrac{1}{4}x^5 + o(x^5)}{x^5} = \frac{1}{4} ]$</p><h2 id="题目-219">题目 219</h2><p>设 $(f’(0) = 0), (f’'(0))$存在, 求极限 $ _{x0} $</p><h3 id="解答-24">解答</h3><p>“f-f” 型 同名函数 相减，考虑 拉格朗日中值定理</p><p>然后，通过题干给出的条件，建立等式</p><p>由于 $(f’‘(0))$ 存在，故 $(f’(x))$ 在点 $(x=0)$ 处 连续 （可导 $(\Rightarrow)$ 连续）</p><p>故 $(\lim\limits_{x\to 0}f’(x) = f’(0))$</p><p>先由 $(Lagrange)$ 中值定理可得：</p><p>$[ \begin{aligned} \lim\limits_{x\to0}\dfrac{f(x) - f(\ln(1 + x))}{x^3} &amp;= \lim\limits_{x\to0}\dfrac{f’(\xi)(x - \ln(1+x))}{x^3} \end{aligned} ]$</p><p>其中 $(\ln(1 + x) &lt; \xi &lt; x)$，两侧同除 x 取极限 ，然后 夹逼，可得:</p><p>$[ \lim\limits_{x\to 0}\dfrac{\ln(1 + x)}{x} &lt; \lim\limits_{x\to 0} \dfrac{\xi}{x} &lt; \lim\limits_{x\to 0}\dfrac{x}{x} \quad\Rightarrow\quad \lim\limits_{x\to 0} \dfrac{\xi}{x} = 1 \quad\Rightarrow\quad \xi \sim x \quad(x\to 0) ]$</p><p>最后用 导数定义 收尾：</p><p>$[ \begin{aligned} \lim\limits_{x\to0}\dfrac{f’(\xi)(x - \ln(1+x))}{x^3} &amp;= \dfrac{1}{2} \lim\limits_{x\to0} \dfrac{f’(\xi)}{x} \\ &amp;= \dfrac{1}{2} \lim\limits_{x\to0} \dfrac{f’(\xi) - f’(0)}{\xi} \cdot \dfrac{\xi}{x} \\ &amp;= \dfrac{1}{2} \lim\limits_{x\to0} \dfrac{f’(\xi) - f’(0)}{\xi - 0} \cdot 1 \\ &amp;= \dfrac{1}{2} f’'(0) \\ \end{aligned} ]$</p><h2 id="题目-220">题目 220</h2><p>$[ \lim_{x\to0^+}\frac{\sqrt{a}\arctan\sqrt{\dfrac{x}{a}}-\sqrt{b}\arctan\sqrt{\dfrac{x}{b}}}{x\sqrt{x}} ]$</p><h3 id="解答-25">解答</h3><p>$[ \arctan x = x - \dfrac{1}{3}x^3 \quad \Rightarrow \quad \arctan \sqrt{\dfrac{x}{a}} = \sqrt{\dfrac{x}{a}} - \dfrac{x^{\frac{3}{2}}}{3a^{\frac{3}{2}}} + o(x^{\frac{3}{2}}) ]$</p><p>根据上述推导，可对等式中的分子进行如下变形：</p><p>$[ \sqrt{a}\arctan\sqrt{\dfrac{x}{a}}-\sqrt{b}\arctan\sqrt{\dfrac{x}{b}} = x^{\frac{1}{2}} - \dfrac{x^{\frac{3}{2}}}{3a} - x^{\frac{1}{2}} + \dfrac{x^{\frac{3}{2}}}{3b} + o(x^{\frac{3}{2}}) = \dfrac{a - b}{3ab} x^{\frac{3}{2}} + o(x^{\frac{3}{2}}) ]$</p><p>刚好展开到分母对应的阶数，于是就做完了</p><p>$[ \lim_{x\to0^+}\frac{\sqrt{a}\arctan\sqrt{\dfrac{x}{a}}-\sqrt{b}\arctan\sqrt{\dfrac{x}{b}}}{x\sqrt{x}} = \dfrac{a - b}{3ab} ]$</p><h2 id="题目-221">题目 221</h2><p>设函数 $(f(x))$ 连续, 且$(f(0)\ne0)$, 求极限 $(\lim\limits_{x\to0}\dfrac{x\int^x_{0}f(x-t)dt}{\int_0^xtf(x-t)dt})$</p><h3 id="解答-26">解答</h3><p>极限中有 变上限积分，考虑用 洛必达法则 求导消掉积分符号</p><p>然后分母的 被积函数 中含有 $(x)$，考虑对积分变量换元，从而分离出 $(x)$</p><p>令 $(x - t = u)$，则 $(-dt = du)$，有</p><p>$[ \int_0^xf(x-t)dt = \int_0^xf(u)du ]$</p><p>$[ \int_0^xtf(x-t)dt = \int_0^x(x - u)f(u)du = x\int_0^xf(u)du - \int_0^x uf(u)du ]$</p><p>拆分好后，按照先前给出的思路，洛必达 即可</p><p>$[ \lim\limits_{x\to0}\dfrac{x\int_0^xf(u)du}{x\int_0^xf(u)du - \int_0^x uf(u)du} = \lim\limits_{x\to0}\dfrac{\int_0^xf(u)du + xf(x)}{\int_0^xf(u)du} ]$</p><p>这里没说 (f(x)) 可导，再洛就寄了，考虑 积分中值定理 来去掉 积分符号</p><p>$(\exists \xi \in (0,x), s.t. xf(\xi) = \int_0^x f(u)du)$，则原式 $ = {x0} = {x0}$</p><p>又由于 $(f(x))$ 连续，且 $(f(0) \ne 0)$，故 $(\lim\limits_{\xi \to 0} f(\xi) = f(0) \ne 0)$</p><p>于是，原式 $ $ = _{(, x) (0,0)} = = 2$ $</p><h2 id="题目-222">题目 222</h2><p>$设函数 (f(x)) 连续, 且(f(0)\ne0), 求极限 (\lim\limits_{x\to0}\dfrac{x\int^x_{0}f(x-t)dt}{\int_0^xtf(x-t)dt})$</p><h3 id="解答-27">解答</h3><p>极限中有 变上限积分，考虑用 洛必达法则 求导消掉积分符号</p><p>然后分母的 被积函数 中含有 $(x)$，考虑对积分变量换元，从而分离出 $(x)$</p><p>令 $(x - t = u)$，则 $(-dt = du)$，有</p><p>$[ \int_0^xf(x-t)dt = \int_0^xf(u)du ]$</p><p>$[ \int_0^xtf(x-t)dt = \int_0^x(x - u)f(u)du = x\int_0^xf(u)du - \int_0^x uf(u)du ]$</p><p>拆分好后，按照先前给出的思路，洛必达 即可</p><p>$[ \lim\limits_{x\to0}\dfrac{x\int_0^xf(u)du}{x\int_0^xf(u)du - \int_0^x uf(u)du} = \lim\limits_{x\to0}\dfrac{\int_0^xf(u)du + xf(x)}{\int_0^xf(u)du} ]$</p><p>这里没说 $(f(x))$ 可导，再洛就寄了，考虑 积分中值定理 来去掉 积分符号</p><p>$(\exists \xi \in (0,x), s.t. xf(\xi) = \int_0^x f(u)du)$，则原式 $ = {x0} = {x0}$</p><p>又由于 $(f(x))$ 连续，且 $(f(0) \ne 0)$，故 $(\lim\limits_{\xi \to 0} f(\xi) = f(0) \ne 0)$</p><p>于是，原式 =  2</p><h2 id="题目-223">题目 223</h2><p>$设函数 (f(x)) 连续,且(\lim\limits_{x\to0}\dfrac{f(x)}{x} = 2), 求极限 (\lim\limits_{x\to0}\dfrac{\displaystyle\int_0^xe^{xt}\arctan(x-t)^2dt}{\displaystyle\int_0^xtf(x-t)dt})$</p><h3 id="解答-28">解答</h3><p>由函数 $(f(x))$ 连续 及 $(\lim\limits_{x\to0}\dfrac{f(x)}{x} = 2)$，易知：$(\lim\limits_{x\to0}f(x)=f(0)=0)$</p><p>再由 导数定义，可得：$(f’(0) = \lim\limits_{x\to0}\dfrac{f(x) - f(0)}{x - 0} = 2)$</p><p>变上限积分函数 求极限，考虑 洛必达法则 求导去积分符号</p><p>分子的 变上限积分函数 中，既有 $(xt)$ 又有 $(x-t)$，换元法 不能同时消掉，故考虑 广义积分中值定理</p><p>由 广义积分中值定理 $(\displaystyle\int_a^b f(x)g(x)dx = f(\xi) \displaystyle\int_a^b g(x)dx)$，其中 $(g(x))$ 在 $((a,b))$ 上不变号</p><p>易知在 $(x\to 0)$ 时，$(\arctan(x-t)^2)$ 不变号，于是有：</p><p>$(\displaystyle\int_0^xe^{xt}\arctan(x-t)^2dt = e^{x\xi}\displaystyle\int_0^x\arctan(x-t)^2dt)，其中 (\xi\in(0,x))$</p><p>$[ \begin{aligned} \lim\limits_{x\to0}\frac{\displaystyle\int_0^xe^{xt}\arctan(x-t)^2dt}{\displaystyle\int_0^xtf(x-t)dt} &amp;= e^0 \cdot \lim\limits_{x\to0}\frac{\displaystyle\int_0^x\arctan(x-t)^2dt}{\displaystyle\int_0^xtf(x-t)dt} \\ &amp;= \lim\limits_{x\to0}\frac{\displaystyle\int_0^x\arctan u^2du}{x\displaystyle\int_0^xf(u)du - \displaystyle\int_0^x uf(u)du} \\ &amp;= \lim\limits_{x\to0}\frac{\arctan x^2}{xf(x) + \displaystyle\int_0^xf(u)du - xf(x)} \\ &amp;= \lim\limits_{x\to0}\frac{x^2}{\displaystyle\int_0^xf(u)du} \\ &amp;= \lim\limits_{x\to0}\frac{2x}{f(x)} = 2 \cdot \lim\limits_{x\to0}\frac{1}{\dfrac{f(x) - f(0)}{x - 0}} \\ &amp;= \frac{2}{f’(0)} \\ &amp;= 1 \end{aligned} ]$</p>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘与大数据分析复习</title>
      <link href="/2022/05/27/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/05/27/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="题型">题型</h2><ul><li>选择题——单选、多选</li><li>大题——2道计算题 大部分是简答题 最后一题是综合题</li></ul><blockquote><ul><li>决策树的流程</li><li>聚类有哪些类型</li><li>数据挖掘的任务有哪些~</li><li>关联规则挖掘</li><li>分类/预测 与 回归</li><li>聚类分析</li><li>孤立点检测</li></ul></blockquote><h2 id="第一章-数据挖掘与大数据简介">第一章 数据挖掘与大数据简介</h2><p><img src="https://img-blog.csdnimg.cn/20210604113812714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzA0OTQy,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="复习提纲">复习提纲</h3><ol><li>基本概念<ul><li>什么是大数据</li><li>什么是数据挖掘</li></ul></li><li>大数据的4V特征</li><li>数据挖掘的主要任务</li><li>KDD过程（数据挖掘是核心）</li><li>DM（数据挖掘）挑战</li><li>数据挖掘和多个学科的融合</li></ol><h3 id="基本概念">基本概念</h3><h4 id="什么是大数据">什么是大数据</h4><p>大数据是一个流行词，或称流行语，用来描述大量的结构化和非结构化数据，这些数据如此之大，<br>很难使用传统的数据库和软件技术进行处理<br>无法在<strong>一定时间内用常规软件工具</strong>对其内容进行<strong>抓取，管理，处理</strong>的数据集合<br>是要更新处理模式才能具有更强的决策力，洞察发现力，流程优化能力来适应海量，高增长率，多样化的信息资产</p><h4 id="什么是数据挖掘">什么是数据挖掘</h4><p>从<strong>大量</strong>数据中挖掘那些<strong>令人感兴趣的，有用的，隐含的，先前未知的，可能有用的模式或者知识</strong></p><p>关键是从“大量的数据中挖掘令人感兴趣的模式或知识”<br><strong>注意</strong>：并非所有数据分析都是“数据挖掘”</p><ul><li>查询处理</li><li>专家系统或者是数学计算/统计程序</li></ul><h4 id="大数据的4V特征">大数据的4V特征</h4><ul><li>规模性</li><li>多样性</li><li>高速性</li><li>价值性</li></ul><h3 id="数据挖掘主要任务">数据挖掘主要任务</h3><ol><li><strong>关联规则分析</strong> 发掘数据之间的关联规则，如挖掘空气质量和气象条件之间的关系</li><li><strong>聚类分析</strong> 将数据归为不同的类，形成新的类别进行分析，最大化<strong>类内相似性</strong>和最小化<strong>类间相似性</strong></li><li><strong>分析 回归 预测</strong> 找出描述和区分数据类或者概念的模型 让该模型可以预测未知的对象类标签</li><li><strong>离群点分析</strong> 分析孤立而原本会被当作噪音丢弃的数据 在欺骗检测中通过孤立点分析得到的结论</li></ol><blockquote><p>这些内容在之后的章节都会讲到</p></blockquote><h3 id="（重点）KDD过程（知识发现过程）">（重点）KDD过程（知识发现过程）</h3><p>KDD：从数据中获取知识</p><ol><li>数据清理：消除噪声和删除不一致的数据</li><li>数据集成： 多种数据源可以组合在一起</li><li>数据选择：从数据库中提取与分析任务相关的数据</li><li>数据变化：把数据变换和统一成适合挖掘的形式</li><li><strong>数据挖掘</strong>：核心步骤，<strong>使用智能方法提取数据模式</strong></li></ol><blockquote><p>知识发现的核心是数据挖掘！</p></blockquote><ol start="6"><li>模式评估：根据兴趣度度量，识别代表知识的真正有趣的模式</li><li>知识表示：使用可视化和知识表示技术，向用户提供挖掘的知识</li></ol><blockquote><p>注意数据挖掘是核心</p></blockquote><h3 id="数据挖掘挑战">数据挖掘挑战</h3><p>数据<strong>容量</strong> <code>Scale of Data</code>——VOLUMN<br>数据的实时性 <code>Data Stream</code> ——VELOCITY<br>数据的多样性<code>Different format of data different sources</code>——VARIETY<br>数据的不确定性 <code> Uncertainty, missing value</code></p><h3 id="数据挖掘与多个学科融合">数据挖掘与多个学科融合</h3><ul><li>机器学习，数据库系统，信息检索</li><li>统计学，物理学，其他学科</li></ul><h2 id="第二章-认识数据和数据预处理">第二章 认识数据和数据预处理</h2><h3 id="复习提纲-2">复习提纲</h3><ol><li>属性类型</li><li>数据的统计描述</li></ol><ul><li>中心性<ul><li>均值</li><li>众数</li><li>中位数</li><li>中列数</li></ul></li><li>散度<ul><li>极差</li><li>最小</li><li>最大</li><li>四分位</li><li>百分位</li><li>方差</li></ul></li></ul><ol start="3"><li>相似性度量</li></ol><ul><li>标称<code>d(i,j)=#不同/# 总</code></li><li>数值<ul><li>欧式</li><li>曼哈顿</li></ul></li><li>数据标准化<ul><li>最大最小法</li><li>Z-Score</li></ul></li><li>其他相似性<ul><li>余弦相似性</li><li>马氏距离</li><li>相关散度</li><li>KL散度</li></ul></li><li>数据预处理<br>清理$\to$集成$\to$规约$\to$变换$\to$离散化</li><li>清理：缺值，噪声</li><li>集成：相关分析，卡方分析</li><li>规约：采用PCA小波分析，特征筛选（信息增益）</li><li>变换：最大最小法，E-score，数据离散化</li></ul><ol start="4"><li>数据类型</li></ol><h3 id="属性类型">属性类型</h3><p><strong>分类型</strong></p><ul><li>标称型-<strong>特殊（二元）</strong></li></ul><blockquote><p>标称型目标变量的结果<strong>只在有限目标集中取值</strong>，比如真与假（标称型目标变量主要用于<strong>分类</strong>）</p><ul><li>例：ID号，眼球颜色，邮政编码</li><li>特殊：二元</li></ul></blockquote><ul><li>序数型<ul><li>例：军阶，GPA，用{tall,medium,short}表示身高</li></ul></li></ul><p><strong>数值型</strong></p><blockquote><p>数值型目标变量则可以<strong>从无限的数值集合中取值</strong>，如0.555，666.666等（数值型目标变量主要用于<strong>回归分析</strong>）</p></blockquote><ul><li>区间<ul><li>例如：日历，摄氏或华氏温度</li></ul></li><li>比率<ul><li>例如：开式温度，长度，计数</li></ul></li><li><strong>标称属性</strong>的值是一些符号和事物的名称（比如头发的颜色）</li></ul><blockquote><p>标称：意味着“与名称有关”</p></blockquote><p><strong>离散和连续属性</strong><br><strong>二元属性</strong>是标称的一种 1代表有 0代表没有<br>如果是对称的说明无权重（例如男女性别）<br>如果是非对称的说明有权重（例如检测结果为阴性/阳性） 一个值比另一个值重要，重要的通常较少出现，通常用1表示</p><p>数值属性：区间，比率</p><h3 id="数据类型">数据类型</h3><ul><li>记录数据<ul><li>数据矩阵</li><li>文档数据</li><li>购物篮数据</li></ul></li><li>图数据<ul><li>万维网</li><li>分子结构</li></ul></li><li>有序数据<ul><li>时序数据</li><li>序列数据</li><li>基因序列数据</li><li>空间数据</li></ul></li></ul><h3 id="（重点）【选填题】数据的描述性统计">（重点）【选填题】数据的描述性统计</h3><p><strong>中心趋势度量：均值，众数，中位数，中列数</strong>——（中心性描述）<br><strong>数据的散步：极差，四分位数，四分位数极差，五数概括，盒图</strong>——（散布描述）<br><strong>可视化</strong></p><ul><li>分位数图</li><li>分位数-分位数图</li><li>直方图</li></ul><h4 id="中心趋势度量">中心趋势度量</h4><p><strong>均值</strong><br>均值=总和/个数</p><p>加权平均：考虑权重的均值</p><p><strong>中列数</strong><br>数据集的最大和最小值的平均值</p><p><strong>中位数（median）</strong><br>有序数据值的中间值</p><p>大数据：近似值估计（线性插值法）</p><p><strong>众数（mode）</strong><br>在集合中出现最频繁的值。（一个数据集中可能有多个众数）</p><p>对于非对称的单峰数据，有以下经验关系</p><p><code>mean-mode ~ 3 * (mean-median)</code>即为<code>均值-众数近似等于3*（均值-中位数）</code></p><blockquote><p>选填可能会考！</p></blockquote><h4 id="数据的散布">数据的散布</h4><ul><li>方差</li><li>标准差</li><li>极差</li></ul><p><strong>max-min</strong></p><ul><li>四分位数（quantile）</li><li>四分位数极差（距离）<br><code>IQR=Q3-Q1</code></li><li>五数概括</li></ul><blockquote><p>[min, Q1,median,Q3,max]</p></blockquote><h3 id="（重点）【上机实习】-数据的相似度度量">（重点）【上机实习】 数据的相似度度量</h3><h4 id="标称属性数据">标称属性数据</h4><p>标称变量是二元变量的拓展，它可以取多于两种状态</p><p>相异性度量方法中，不匹配率</p><p>计算方法为 $d(i,j)=\frac{p-m}{p}$</p><blockquote><p>m是状态取值匹配的变量数目 p是变量总数</p></blockquote><h4 id="二元变量属性数据">二元变量属性数据</h4><p>首先获取列联表<br><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_de3d687adf-1.png" alt="1.png"></p><p>对称的二元变量的相异度计算</p><blockquote><p>对于对称属性，r+s是一个1一个0的总数和，q是两个1</p></blockquote><p>$$d(i,j)=\frac{r+s}{q+r+s+t}$$</p><p>如果是非对称则t被忽略<br>$$d(i,j)=\frac{r+s}{q+r+s}=1-\frac{q}{q+r+s}=1-Jaccard(i,j)$$</p><p>不对称的二元变量的相异度计算</p><blockquote><p>二元变量的两个状态的输出不是同样重要</p></blockquote><h4 id="序数型变量数据">序数型变量数据</h4><p><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_730900c2df-2.png" alt="2.png"></p><h4 id="数值属性数据">数值属性数据</h4><p>使用<strong>距离</strong>来度量两个数据对象之间的<strong>相似性/相异性</strong></p><ul><li>闵可夫斯基(Minkowski) 距离</li><li>曼哈顿距离</li></ul><blockquote><p>一维 绝对值之和</p></blockquote><ul><li>欧式距离</li></ul><blockquote><p>二维开根号</p></blockquote><h4 id="数据标准化">数据标准化</h4><p><strong>使用平均绝对偏差比使用标准差更具有鲁棒性</strong></p><h4 id="混合型数据">混合型数据</h4><p><strong>基本思想</strong>：将不同类型的变量组合在<strong>单个相异度矩阵中</strong>，把所有变量转换到共同的值域区间[0.0,1.0]上</p><h4 id="相似性度量">相似性度量</h4><ul><li>余弦相似性</li><li>马氏距离</li><li>相关散度</li><li>KL散度</li></ul><h3 id="（重点）数据预处理">（重点）数据预处理</h3><h4 id="为什么要挖掘？">为什么要挖掘？</h4><p>现实世界的数据是“肮脏的”</p><ul><li>不完整的：有些感兴趣的属性缺少属性值，或仅包含聚集数据</li><li>含噪声的：包含错误或者“孤立点”</li><li>不一致的：在编码或者命名上存在差异</li></ul><p>没有高质量的数据，就没有高质量的挖掘结果</p><h4 id="数据预处理的主要任务">数据预处理的主要任务</h4><h5 id="（重点）-数据清理-（数据的填充方式重点）">（重点） 数据清理 （数据的填充方式重点）</h5><p>【重点】填充方法</p><ul><li>忽略元组</li><li>人工填充缺省值：工作量大，可行性低</li><li>使用一个全局变量填充空缺值：比如使用unknown或-∞替换</li><li>使用属性的平均值填充空缺值</li><li>使用与给定元组属同一类的所有样本的均值</li><li>使用最可能的值填充空缺值：使用像Bayesian公式或判定树这样的预测的方法</li></ul><blockquote><p>空缺值 噪声数据 删除孤立点 解决不一致性</p></blockquote><p>用均值或者用临近数</p><p>噪声使用过滤的方法（聚类，回归，分箱）</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_a40d3865df-3.png" alt="3.png"></p><h5 id="数据集成">数据集成</h5><p>将多个数据源的数据整合到一个一致的存储中</p><p>集成多个数据库时，经常会出现冗余数据</p><p><strong>冗余分析</strong>：</p><ul><li>数字型 相关分析 皮尔逊相关系数</li><li>标称数据 卡方检验<br><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_6cac7c94df-4.png" alt="4.png"></li></ul><h5 id="数据规约">数据规约</h5><p>得到数据集的压缩表示，但可以得到相同或相近的结果</p><p>分为</p><ol><li>维度规约：小波分析，<strong>PCA，特征筛选</strong></li><li>数量规约：回归，<strong>聚类，采样</strong>，数据立方体聚集</li><li>数据压缩（非重点）：使用变换</li></ol><p><strong>维度规约</strong>：PCA，小波分析，<strong>特征筛选</strong><br>**PCA基本思想：**找到一个投影，其能表示数据的最大变化</p><blockquote><p>特征筛选<br>目的：通过删除不相干的属性或维减少数据量<br>挑战：枚举所有几乎不可能<br>策略：启发式方法</p></blockquote><ul><li>逐步向前选择法</li><li>逐步向后删除法</li><li>向前选择和向后删除相结合</li></ul><p>利用信息增益，信息熵等（信息增益越大越好）</p><blockquote><blockquote><p>信息熵：刻画信息的混乱程度</p></blockquote></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_3ac0b253df-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_f61ae973df-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/30/99310_2f00c283df-3.png" alt="3.png"></p><p><a href="https://blog.csdn.net/xwd18280820053/article/details/70739368">信息熵的介绍</a></p><p><strong>数量规约</strong>：回归，聚类，采样</p><h5 id="数据变化">数据变化</h5><blockquote><p>规范化和聚集<br>把数据变换和统一成适合挖掘的形式</p></blockquote><ul><li>最大最小规范化</li><li>Z-score规范化</li></ul><h5 id="数据离散化">数据离散化</h5><p>将连续数据进行离散处理</p><p>离散化（连续数据）<br>概念分层（标称数据）</p><h2 id="第三章-关联规则挖掘">第三章 关联规则挖掘</h2><h3 id="复习提纲-3">复习提纲</h3><p>定义</p><ul><li>关联规则挖掘</li><li>频繁模式</li><li>项集</li><li>支持度/计数</li><li>置信度</li></ul><p><code>Apriori</code>算法</p><ul><li>剪枝基本思想</li><li><code>Apriori</code>流程，计算</li><li>存在挑战及改进</li></ul><p>FP-Growth算法</p><ul><li>如何构造FP树</li><li>如何挖掘</li></ul><p>评估方法</p><ul><li>支持度</li><li>置信度</li><li>兴趣因子</li></ul><h3 id="定义以及一些概念">定义以及一些概念</h3><p>关联规则的挖掘：在事务，关系数据库中的项集和对象中发现<strong>频繁模式，关联规则，相关性</strong>或者<strong>因果结构</strong></p><p>频繁模式：数据库中频繁出现的项集</p><p>支持度 support</p><p>置信度 confidence</p><p>这两个标准来衡量事物关联规则的强度</p><ul><li>支持度support$X\to Y$：确定项集的频繁程度</li></ul><p>包含项集的事务数与总事务数的比值</p><ul><li>置信度</li><li>项集</li><li>频繁项集</li><li>置信度计算公式</li></ul><h3 id="Apriori算法">Apriori算法</h3><p>通过对数据的多次扫描来计算项集的支持度，发现所有频繁项集从而生成关联规则</p><p>剪枝的基本思想</p><p><strong>性质1：如果一个项集是频繁的，则它的所有子集一定也是频繁的</strong></p><p><strong>性质2：相反，如果一个项集是非频繁的，则它的所有超集也一定是非频繁的</strong></p><p><strong>提高Apriori算法的方法</strong></p><ul><li>Hash-based itemset counting（散列项集计数），压缩候选k项集</li><li>Transaction reduction（事务压缩），删除不可能对寻找频繁项集有用的事务</li><li>Partitioning（划分），分而治之</li><li>Sampling（采样），选取原数据库的一个样本, 使用Apriori 算法在样本中挖掘频繁模式</li></ul><h3 id="FP-growth算法">FP-growth算法</h3><p>优点：<strong>快</strong><br>该算法不同于Apriori算法的“产生-测试”范型。而是使用一种称为FP树的紧凑数据结构组织数据，并<strong>直接从该结构中提取频繁项集</strong></p><p><strong>基本思想</strong><br>首先：将<strong>代表频繁项集的数据库</strong>压缩到FP树上<br>其次：将FP树划分为一组条件数据库（每个数据关联一个频繁项或“模式段”），挖掘每个条件数据库获取频繁项集<br><strong>如何构造FP树</strong></p><ol><li>支持度排序</li><li>构建FP树</li></ol><h3 id="支持度，置信度及兴趣因子">支持度，置信度及兴趣因子</h3><h2 id="第四章-分类-回归">第四章 分类/回归</h2><h3 id="复习提纲-4">复习提纲</h3><p>基本概念</p><ul><li>监督/无监督</li><li>生成/判别</li><li>分类 VS 回归</li></ul><p>分类算法</p><ul><li>（重点）决策树<ul><li>建构过程</li><li>属性选择基本准则</li><li>信息增益率</li><li>基尼指数</li></ul></li><li>（重点）过拟合问题<ul><li>如何避免</li><li>决策树中</li></ul></li><li>（重点）KNN<ul><li>基本思想</li><li>优缺点</li></ul></li><li>Naive Bayes 朴素贝叶斯<ul><li>贝叶斯理论（优缺点）</li></ul></li><li>（重点）SVM支持向量机<ul><li>支持向量/小样本/泛化能力</li><li>基本思想</li><li>非线性函数： 核函数</li></ul></li><li>人工神经网络</li></ul><p>集成学习</p><ul><li>学习准则<ul><li>准确性</li><li>多样性</li></ul></li><li>集成策略<ul><li>RF</li><li>Ada Boost</li><li>Stacking</li></ul></li></ul><p>评估</p><ul><li>准确度</li><li>轻度</li><li>吕四率</li><li>F1</li><li>类不平衡：灵敏性，特效性</li></ul><h3 id="基本概念-2">基本概念</h3><h4 id="监督学习-VS-无监督学习">监督学习 VS 无监督学习</h4><p>监督学习</p><p>分类，预测等</p><blockquote><p>“告诉机器怎么学”</p></blockquote><p>无监督学习</p><p>关联规则挖掘，聚类分析都是无监督学习</p><blockquote><p>“不告诉机器怎么学”</p></blockquote><h4 id="（重要）-模型分类">（重要） 模型分类</h4><h5 id="生成模型">生成模型</h5><p>希望从数据中<strong>学习/还原出原始的真实数据生成模型</strong></p><blockquote><p>朴素贝叶斯，隐马尔可夫模型</p></blockquote><h5 id="判别模型">判别模型</h5><p>从数据中<strong>学习到</strong>不同类概念的<strong>区别从而进行分类</strong></p><blockquote><p>KNN SVM ANN 决策树</p></blockquote><h5 id="二者的区别">二者的区别</h5><p>生成模型</p><ul><li>容量大 生成模型容易接近真实模型</li><li>能够处理具有<strong>隐含变量</strong>的情景</li></ul><p>判别模型</p><ul><li>速度快</li><li>准确率高</li></ul><p>分类和回归</p><p>分类：根据训练数据集和类标号属性，构建模型来分类现有数据，并用来分类新数据</p><p>预测：建立连续函数值模型，预测未来的情况比如预测空缺值</p><h3 id="决策树（DT）">决策树（DT）</h3><h4 id="（重点）-决策树的优缺点">（重点） 决策树的优缺点</h4><p>优点</p><ul><li>容易转换成分类规则</li><li>计算量相对较小，所以速度较快</li><li>准确性高（挖掘出来的分类规则准确性高 便于理解）</li></ul><p>缺点</p><ul><li>容易过拟合</li><li>忽略了属性之间的相关性</li></ul><h4 id="（重点）-构建决策树的方法">（重点） 构建决策树的方法</h4><p>构造方式</p><h4 id="（重点）-属性选择基本准则">（重点） 属性选择基本准则</h4><p>具有最好度量得分的属性（对分类数据类别越“纯”）选定为分裂属性</p><p>三种度量：信息增益，信息增益率，Gini指标</p><h5 id="（重点）-信息增益（ID3）">（重点） 信息增益（ID3）</h5><p>信息增益：原来的信息与分裂后的信息之差，说明我们通过划分得到了多少信息</p><h5 id="（重点）-信息增益率（C4-5）">（重点） 信息增益率（C4.5）</h5><p>信息增益倾向于有大量不同取值的属性，但每个划分只有一个类的时候 info=0</p><p>C4.5（ID3后继）使用增益率来克服这一问题（规范化信息增益）</p><p>公式为信息增益/根据当前的那个类利用信息熵计算出来的值，越大越好</p><h5 id="Gini指数（CART）">Gini指数（CART）</h5><p>Gini指数度量数据元组的不纯度，越小越好</p><p>如果是三个属性，要进行二元分裂，那么两两为一组，计算后加权后的Gini指数</p><h3 id="（重点）-过拟合问题和解决">（重点） 过拟合问题和解决</h3><p>过拟合：为了得到一致性假设而使<strong>假设变得过度复杂</strong>称为过拟合</p><p>过拟合是监督学习中普遍存在的问题</p><ul><li>原因：因为训练样本<strong>只是</strong>真实情况下的<strong>一个抽样集</strong></li><li>结果：<strong>泛化能力不强</strong></li></ul><h4 id="过拟合问题的解决策略">过拟合问题的解决策略</h4><ol><li>增加样本集</li><li>噪声去除</li><li>降低模型复杂度</li><li>模型选择正确：正则项等（例如选择VC堆）</li></ol><h4 id="（重点）在决策树中如何避免过拟合">（重点）在决策树中如何避免过拟合</h4><p>一颗归纳的树可能过分拟合数据训练数据造成的后果</p><ul><li>分支太多，某些反映训练数据中的异常，噪声/孤立点</li><li>未参与训练的样本的低精度预测</li></ul><p>具体做法</p><ul><li>限制决策树的层数来限制树的生长</li><li>设定每个节点必须包含的最少的记录数 节点个数小于这个最小记录数就停止分隔</li><li>树剪枝<ul><li>先剪枝<strong>提前终止树构造</strong></li><li>后剪枝<strong>从完全生长的树中剪去树枝</strong>（但是后剪枝的计算量代价比先剪枝方法大很多！尤其是大样本集中）【在小样本中后剪枝要好】</li></ul></li></ul><h3 id="（重点）-KNN">（重点） KNN</h3><h4 id="基本思想">基本思想</h4><p>算法步骤：</p><ol><li>算距离：给定测试对象，计算它与训练集中的每个对象的距离</li><li>找邻居：圈定距离最近的k个训练对象，作为测试对象的近邻</li><li>做分类：根据这k个近邻归属主要的类别，来对测试对象分类</li></ol><h4 id="优缺点">优缺点</h4><p>优点：</p><ul><li>简单，易于实现，无需估计参数，无需训练</li><li>准确率一般较高</li><li>适合对稀有事件进行分类，特别适合于多分类问题</li></ul><p>缺点：</p><ul><li>懒惰算法，对测试样本分类时计算量大，内存开销大，评分慢</li><li>当类解释不平衡的时候，倾向于将类全部归于大类</li><li>可解释性差，无法给出决策树那样的规则。对噪声非常敏感</li></ul><h3 id="朴素贝叶斯">朴素贝叶斯</h3><p>关注分子：哪个更大<br>找更大的y（y是类别）<br>优点：概率输出，对文本分类效果较好</p><h3 id="（重点）SVM支持向量机">（重点）SVM支持向量机</h3><h4 id="（重点）SVM的优缺点">（重点）SVM的优缺点</h4><h4 id="什么是支持向量？">什么是支持向量？</h4><p>在<strong>分界点上的点</strong>称为支持向量</p><p>SVM的优点：</p><ol><li>可以处理小样本</li><li>泛化能力强</li></ol><h3 id="人工神经网络">人工神经网络</h3><p>人工神经网络（ANN，Artificial Neural Networks）是人类对大脑神经网络认识的基础上，人工构造的能够实现某种功能的神经网络。<br>它是理论化的人脑神经系统的数学模型，是基于模仿大脑神经结构和功能而建立起来的一种信息处理系统。<br>是一个多输入单输出的非线性阈值器件。</p><h3 id="集成学习">集成学习</h3><p>考的可能性不大，PPT里面没有<br>集成学习：通过<strong>构建并结合多个学习器</strong>来完成学习任务，个体学习器要有一定的“准确性”，并且要有“多样性”，即学习器间有差异</p><blockquote><p>多样性是核心</p></blockquote><h3 id="分类评价指标">分类评价指标</h3><p><strong>准确度：Accuracy=$\frac{TP+TN}{ALL}$</strong><br>精度<br>A代表实际，PR代表预测，左上角和右下角是预测正确的<br><strong>准确度：Accuracy=$\frac{TP+TN}{ALL}$</strong><br><strong>误差率：1-Accuracy</strong><br><strong>错误率=$\frac{FP+FN}{ALL}$</strong><br><strong>精度：被分类预测为正确的占所有实际正确的比例$\frac{TP}{TP+FP}$</strong><br><strong>召回率：在所有实际正确的类别中被识别为正确的比率$\frac{TP}{TP+FN}$</strong></p><h3 id="练习题">练习题</h3><h2 id="第五章-聚类算法和噪声检测">第五章 聚类算法和噪声检测</h2><h3 id="复习提纲-5">复习提纲</h3><ol><li>什么是聚类？</li><li>聚类算法分类</li><li>KMEANS DBSCAN算法</li><li>什么是离群点？</li><li>离群点种类</li><li>LOF</li></ol><h3 id="什么是聚类">什么是聚类</h3><p>无监督学习的一种，就是将数据分为多个簇（Clusters），使得在同一簇内对象之间具有较高的相似度，而不同簇之间的对象差别较大.<br>目的是寻找出数据中<strong>潜在的自然分组结构</strong>，<strong>让一个簇内的数据尽可能相似，不同簇内的数据尽可能不同</strong></p><h3 id="聚类算法分类">聚类算法分类</h3><p>一般而言，从<strong>不同角度出发</strong>可以将各种聚类算法分成不同的类型。如按照聚类的基本思想可主要分为：</p><ul><li><p>基于<strong>划分</strong>方法<br>给定一个有n个对象的数据集，划分聚类技术将构造数据k个划分，每一个划分就代表一个簇<br>对于给定的k，算法首先给出了一个初始的划分办法，以后“通过反复迭代的方法改变划分，使得每一次改进后的划分方案都较前一次更好”。经典的算法有：K-MEANS（K-均值），K-Medoids（K-中心点）等</p></li><li><p>基于<strong>层次</strong>方法<br>层次聚类方法对给定的数据集进行层次的分解，直到满足某种条件为止<br><strong>凝聚的层次聚类</strong>是一种自底向上的策略，首先将每个对象作为一个簇，然后合并这些原子簇为越来越大的簇，知道某个终结条件被满足。AGENS算法<br><strong>分裂的层次聚类</strong></p></li><li><p>基于<strong>密度</strong>方法<br>密度聚类方法的指导思想是，只要一个区域中的点的密度大于某个阈值，就可把它加到与之相近的聚类中去。<br>这类算法<strong>能克服基于距离的算法只能发现“类圆形”的聚类的缺点</strong>，可以发现任意形状，<strong>且对噪声数据不敏感</strong></p></li><li><p>基于<strong>网格</strong>方法<br>将对象空间量化为有限数目的单元，形成一个网格结构，所有的聚类都在这个网格结构上进行。</p></li></ul><h3 id="（重点）KMEANS">（重点）KMEANS</h3><p>KMEANS</p><ul><li>选取K个点作为初始的类中心点，这些点一般都是从数据集中随机抽取的</li><li>将每个点分配到最近的类中心点，这样就形成了K个类，然后重新计算每个类的中心点；（一般用欧几里得距离公式算最近，用每个维度的平均值重新计算每个类的中心点）</li><li>重复第二步，直到类不发生变化，或者你也可以设置最大迭代次数，这样即使类中心点发生变化，但是只要达到最大迭代次数就会结束</li></ul><h3 id="KMEANS优缺点">KMEANS优缺点</h3><p>优点：速度快，相对可伸缩和高效率<br>缺点：对K值敏感，对初值敏感，<strong>不适合非球形的簇</strong>，对孤立点和噪声敏感</p><h3 id="（重点）DBSCAN">（重点）DBSCAN</h3><p>缺点：</p><ul><li>对参数EPS和Minspt非常敏感，但是这两个参数的选取主要依靠主观判断</li><li>数据库比较大的话，会有比较大的IO开销</li></ul><h3 id="什么是离群点">什么是离群点</h3><p>“离群点是一个数据对象，它显著不同于其他数据对象，好像它是被不同的机制产生的一样。”</p><blockquote><p>异常数据具有<strong>特殊意义和很高的使用价值</strong>，异常数据虽然有时候或作为离群点被排斥掉，但是却也有可能给我们新的视角，比如</p></blockquote><ul><li>在欺诈检测中，异常数据可能意味着欺诈行为的发生</li><li>在入侵检验中，异常数据可能意味着入侵行为的发生</li></ul><h3 id="离群点种类">离群点种类</h3><ul><li>全局离群点 和别的一点点关系都没有</li><li>局部离群点，对全局来说不是离群点，但是对于某个簇来说是离群点</li><li>集体离群点 某一个群体和其他不同</li></ul><h3 id="LOF离群（异常-孤立）点检测">LOF离群（异常/孤立）点检测</h3><ul><li>基于统计学的孤立点检测</li><li>基于距离的孤立点检测</li><li>基于偏离的孤立点检测</li><li>基于密度判断：<br>对象P的局部可达密度(Local Reachable Distance)<br>对象P的局部可达密度为对象P与它的MinPts-邻域的平均可达距离的倒数<br>对象P的局部异常因子（Local Outlier Factor）<br>Lrd是局部密度，所以孤立点的密度小，分子大，分母小，所以最终结果大<br>对象P的局部异常因子表示P的异常程度，局部异常因子愈大，就认为它可能更异常，反之可能性越小</li></ul><h2 id="第六章-大数据分析">第六章 大数据分析</h2><h3 id="复习提纲-6">复习提纲</h3><p>哈希技术</p><ul><li>Mini Hash 最小哈希-签名矩阵的计算</li><li>LSH局部敏感哈希</li><li>其中 签名矩阵的计算 与局部敏感哈希近似<br>数据流挖掘</li><li>数据流挑战</li><li>概念漂移（PCC（x）改变）检测方法</li><li>分类（VFDT$\to$Hoe）</li><li>聚类：线上+线下<ul><li>线上：数据抽象：微簇</li><li>线下：KMEANS DBSCAN</li></ul></li></ul><h3 id="哈希技术">哈希技术</h3><h4 id="（重点）-Min哈希（最小哈希）">（重点） Min哈希（最小哈希）</h4><p>步骤</p><ol><li>计算签名矩阵<br><strong>（重点） 会算签名矩阵</strong></li><li>通过签名矩阵寻找相似的签名</li><li>检测签名相似的是否真的相似（可选）</li></ol><p>主要思想：<br>把每一列转换成一个更小的签名矩阵C，让C足够小能够放到内存里面，让C1和C2能表征原始数据的相似性<br>相似性用雅阁比距离来表征：$\frac{a}{a+b+c}$ a为两者都是1，b和c表示一个0和一个1<br>最小哈希定义<br>首次出现1的行号</p><h4 id="LSH（局部敏感哈希）">LSH（局部敏感哈希）</h4><p><strong>原因</strong><br>想要比较两个文档，一一校对是非常苦难的，提出LSH<br><strong>哈希的思想</strong><br>不一一匹配，把数据放到桶里，<strong>每个桶里的东西都非常相似</strong><br>把列向量b划分为b块，对每一块进行映射，如果是相似的，那么至少有一块会映射到一个桶子里<br>将签名矩阵划分为几块，对每一块进行映射，候选对是至少散列到一个桶的对<br>概率随比例变化<br>将每一列划分为b个bands，然后每个bands分别放到桶里<br>如果相似度很大（超过0.5），至少有一个band全部放到一个桶里，就可以放到一起</p><h3 id="数据流挖掘">数据流挖掘</h3><p><strong>（重点）如何检测概念漂移</strong><br>数据流：<strong>持续的依次到达的对象，无穷长，有概念漂移</strong><br>挑战：<strong>单程处理，内存限制，低时间复杂度，概念漂移</strong><br><strong>概念漂移</strong><br>在预测分析和机器学习中，概念漂移意味着模型试图预测目标的统计特征随时间以不可预见的方式改变<br>条件概率发生变化<br>如下图，中间是真正的概念漂移，右边是虚假的，如果P（x）变化整体不会变<br><strong>如何检测数据漂移</strong><br><strong>使用分布</strong><br>用于检测突变的概念漂移<br>检测相同时间间隔（窗口）检测P（C|X）,如果检测到变化就说明发生了<br>问题：1.窗口大小不好确定；2.学习漂移慢；3.虚假的概念漂移<br>ADWIM：处理当前数据，发生显著性变化就用新的替代老的<br><strong>错误率</strong><br>缺点：1.对噪声敏感 2.对缓慢变化的数据难以处理 3.取决于学习模型的健壮性<br><strong>分类</strong><br>传统静态不适用，每一次输入一个数据后快速进行分类<br>方法：快速决策树（VFDT）<br>动态地构造决策树，利用小部分数据构造<br>算法：假如新来的数据满足关系，那么就划分一次 如果错误变多了，那么可以认为是发生了概念漂移，使用新的节点<br><strong>聚类</strong><br>数据流抽象，分为在线和离线<br>线上把数据用合适地数据结构处理，线下用传统方式去进行聚类<br>微簇：用几个点表示几个相近的点<br>动态变化，线上（重要），如何去线上整出这些微簇<br><strong>簇特征（重要）</strong><br>CF=（N，LS，SS）N是点的个数，LS是横坐标之和，SS是横坐标平方和<br><strong>为什么要做处理</strong></p><ol><li>可以计算这些点的中心和半径</li><li>可以支持动态增量式计算</li><li>因为数据连续不断的进入，只需要加新增的数据就可以（可加性，可减性）</li></ol><h3 id="（重点）-Hadoop-spark的基本概念！">（重点） Hadoop/spark的基本概念！</h3><p><strong>Hadoop</strong>：Hadoop是一个软件框架，用于跨大型计算机群对大型数据集进行分布式处理TB PB级别<br><strong>Spark</strong>：一个统一的完整的引擎<br><strong>Hadoop设计准则</strong><br>需要处理大数据<br>需要跨数千个节点并行计算，大量廉价机器并行计算<br>分而治之<br>1.自动并行化 2.容错和自动恢复 3.给用户提供接口<br><strong>Hadoop生态</strong><br>MapReduce（计算）和HDFS（存储） ZOOKeeper用来协调<br><strong>HDFS怎么存储</strong><br>分而治之，分为很多块<br>Namenode和Datanode<br>用Namenode去存哪一块放到哪个机器里面，存储数据原信息<br>Datenode存储实际数据，文件被存在各个节点里，拥有时钟机制，每个几秒发送一次汇报工作，如果过了很久还没能发送，那么已经默认你已经挂掉，重新创建节点存储被挂掉节点存储的数据<br>可以存储大数据<br><strong>MapReduce VS Spark</strong><br>MaoReduce适用于一次操作，对多次操作不适用，共享机制落后，花费大量时间IO<br>Spark是用于推广reduce去支持同一引擎的新应用，拥有RDD支持内存计算，提供多种API<br><strong>RDD弹性分布式数据集</strong><br>只读，便于内存计算<br>操作方式：</p><ol><li>Transformation<br>他从现有的数据集创建一个新数据集，所有操作都是懒惰的</li><li>Action<br>它在对数据集运行计算后向驱动程序返回一个值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘与大数据分析 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础复习</title>
      <link href="/2022/05/27/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/05/27/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-绪论">第一章 绪论</h2><h3 id="软件开发六步骤（了解）">软件开发六步骤（了解）</h3><ol><li>问题理解</li><li>算法设计</li><li>数据结构选择</li><li>算法分析</li><li>程序设计</li><li>程序实现</li></ol><h3 id="操作系统的主要功能（了解）">操作系统的主要功能（了解）</h3><ol><li>处理机管理</li><li>存储器管理</li><li>设备管理</li><li>文件管理</li><li>用户接口</li></ol><h4 id="软件程序编译">软件程序编译</h4><p><strong>程序需要编译成计算机能理解的代码才能在操作系统上运行</strong><br>软件是运行在操作系统之上的，因此与操作系统息息相关。同一个软件逻辑和程序在不同的操作系统上的实现可能是不同的，其可运行的二进制码也是不同的<br>程序实现的区别</p><ul><li>Window：进程和线程的概念都是有着明确定义</li><li>Linux：没有很明确的进程，线程概念</li></ul><h4 id="数据库管理系统（了解）">数据库管理系统（了解）</h4><p><strong>定义</strong>数据库管理系统是位于用户与操作系统之间的数据管理软件</p><p><strong>功能</strong>1.数据定义 2.数据操作 3.数据库运行管理 4.数据组织，存储和管理 5.数据库的建立和维护 6.数据通信接口<br><strong>组成</strong></p><ol><li>数据定义语言及其翻译处理程序</li><li>数据操作语言及其翻译处理程序</li><li>数据运行控制程序</li><li>适中程序</li></ol><h2 id="第二章-数据结构与算法">第二章 数据结构与算法</h2><h3 id="线性表的逻辑存储结构">线性表的逻辑存储结构</h3><p>在线性结构中，数据元素之间存在着一对一的关系，其特点是数据元素之间按某种规定存在一个<strong>顺序关系</strong>（逻辑结构）<br>线性表：n个同类数据元素的有限序列，记为：L($a_1，a_2,…，a_i,…，a_n$)<br>L为表名，i为数据元素$a_i$在线性表中的位序；n为线性表的表长，n=0时称为空表，$a_i$的数据类型相同<br>特点：</p><ul><li>$a_i$的数据类型相同</li><li>位序i从1开始</li><li>前驱（前一个元素），后继（后一个元素）</li></ul><h3 id="线性表的顺序存储结构">线性表的顺序存储结构</h3><p><strong>基本概念</strong><br>用一组地址连续的存储单元依次存放线性表中的数据元素，线性表的起始地址s称作线性表的基地址，数据元素ai的存储位置为：LOC(ai) = LOC(a1) + (i-1)×d<br><strong>顺序表的c语言定义</strong><br><img src="https://img-blog.csdnimg.cn/20210702140718959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>插入操作</strong></p><ol><li>检查插入位置是否合法，如果合法则继续，否则退出；</li><li>判表是否已占满；因为是事先静态地分配空间，可能存在所分配存储空间全部被占用的情况，此时也不能实现插入。</li><li>若前面检查通过则数据元素依次向后移动一个位置；为避免覆盖原数据，应从最后一个向前依次移动。</li><li>新数据元素放到恰当位置；</li><li>表长加1。<br><strong>代码</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status  <span class="hljs-title">List_Insert</span><span class="hljs-params">(ListPtr L, <span class="hljs-type">int</span> pos, ElemType elem)</span></span>&#123;<br>    Status status = range_error;<br>    <span class="hljs-type">int</span> len = L-&gt;length, i;<br>    <span class="hljs-keyword">if</span> (len == MAXSIZE) status = overflow;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt;= pos &amp;&amp; pos &lt;= len + <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len; i &gt;= pos; i -- )<br>            L-&gt;elem[i + <span class="hljs-number">1</span>] = L-&gt;elem[i];<br>        L-&gt;elem[pos] = elem;<br>        L-&gt;length ++ ;<br>        status = success;<br>    &#125;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>时间复杂度$O(n)$</p><p><strong>删除操作</strong></p><ol><li>检查删除位置是否合法；</li><li>若检查通过，数据元素依次向前移动一个位置；</li><li>表长减1</li></ol><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status <span class="hljs-title">List_Remove</span><span class="hljs-params">(ListPtr L,<span class="hljs-type">int</span> pos)</span></span>&#123;<br>    Status status = range_error;<br>    <span class="hljs-type">int</span> len = L-&gt;length, i;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt;= pos &amp;&amp; pos &lt;= len)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i &lt; len; i ++ )<br>            L-&gt;elem[i] = L-&gt;elem[i + <span class="hljs-number">1</span>];<br>        L-&gt;length -- ;<br>        status = success;<br>    &#125;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性表的链式存储结构">线性表的链式存储结构</h3><p>用一组地址任意的存储单元存放线性表中的数据元素。<br>数据域 (数据元素) + 指针域 (指示后继元素存储位置) =  结点，以“结点的序列”表示线性表——称作链表<br><img src="https://img-blog.csdnimg.cn/20210702145330594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>带头节点和不带头节点的区别</strong><br>不带：链表指针存放链表第一个数据元素节点的地址，空链表时该指针域为NULL<br>带：一个专门的节点，称为头节点，该头节点是永远存在的，该头节点指针域存放第一个数据元素节点的地址，空链表为L.next=NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//单链表的定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *next;<br>&#125;ListNode, *ListNodeptr;<br><span class="hljs-keyword">typedef</span> ListNodePtr List, *Listptr;<br><br><span class="hljs-comment">//变量的定义和使用</span><br>ListNode n1, n2; <span class="hljs-comment">// 定义2个节点变量</span><br>ListNodePtr p = &amp;n1; <span class="hljs-comment">// 定义一个指向节点的指针变量p,并存放n1的地址(指针)</span><br>n1.next = &amp;n2; <span class="hljs-comment">// 节点n1的指针域存放节点n2的地址</span><br>List L; <span class="hljs-comment">// 定义单链表</span><br></code></pre></td></tr></table></figure><p><strong>插入操作</strong><br><img src="https://img-blog.csdnimg.cn/2021070215030488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>步骤：找到$a_{i-1}$的位置，构造一个数据为elem的新节点，将其挂在单链表上<br>s-&gt;data=elem;<br>s-&gt;next=pre-&gt;next;<br>pre-&gt;next = s;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status  <span class="hljs-title">List_Insert</span><span class="hljs-params">(ListPtr L, <span class="hljs-type">int</span> pos, ElemType elem)</span></span>&#123;<br>    Status status;<br>    ListNodePtr pre, s;<br>    status = <span class="hljs-built_in">List_SetPosition</span>(L, pos - <span class="hljs-number">1</span>, &amp;pre);<br>    <span class="hljs-keyword">if</span> (status == success)<br>    &#123;<br>        s = (LinkNodePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ListNode));<br>        <span class="hljs-keyword">if</span> (s)&#123;<br>            s-&gt;data = elem;<br>            s-&gt;next = pre-&gt;next;<br>            pre-&gt;next = s;<br>        &#125;<br>        <span class="hljs-keyword">else</span> status = fatal;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除操作</strong><br><img src="https://img-blog.csdnimg.cn/20210702150556389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>步骤：首先找到第i-1个节点p，修改第i-1的节点的后继为第i+1个节点的地址，再释放第pos个节点所占的存储空间<br>q=pre-&gt;next;<br>pre-&gt;nxt=q-&gt;next;<br>free(q);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status <span class="hljs-title">List_Remove</span><span class="hljs-params">(ListPtr L, <span class="hljs-type">int</span> pos)</span></span>&#123;<br>    Status status;<br>    ListNodeptr pre, q;<br>    status = <span class="hljs-built_in">List_SetPosition</span>(L, pos - <span class="hljs-number">1</span>, &amp;pre);<br>    <span class="hljs-keyword">if</span> (status == success)&#123;<br>    q = pre-&gt;next;<br>    pre-&gt;next = q-&gt;next;<br>    <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两种存储方式的优缺点">两种存储方式的优缺点</h3><p><strong>顺序表</strong><br>优点：空间利用率高，数据是连续存放的，命中率比较高；存取速度高效，通过下标来直接访问。<br>缺点：插入删除效率低；需要预分配空间<br><strong>时间复杂度</strong>：查找操作为O(1),插入和删除操作为O(n)<br><strong>链表</strong><br>优点：插入删除速度快；没有空间限制，储存元素无上限；动态内存分配<br>缺点：占用额外空间以存储指针；查找速度慢<br><strong>时间复杂度</strong>：查找操作为O(n)，插入和删除操作为O(1)和O(n)<br><strong>链表插入删除是读操作的O（n），而顺序表是写操作的O（n），两者速度不同</strong></p><h3 id="时间复杂度渐进分析（大题）">时间复杂度渐进分析（大题）</h3><p>渐进分析：</p><ol><li>渐近上界记号O<br>O(g(n)) = { f(n) | 存在正常数c和$n_0$使得对所有n $\geq$ $n_0$有：$0 \leq f(n) \leq cg(n)$ }</li><li>渐近下界记号$\Omega$<br>$\Omega$(g(n)) = { f(n) | 存在正常数c和$n_0$使得对所有n $\geq$ $n_0$有：$0 \leq cg(n) \leq f(n)$   }</li><li>紧渐进记号 $\Theta$<br>$\Theta$(g(n)) = { f(n) | 存在正常数c1,c2和$n_0$使得对所有n$\geq$ $n_0$有：$c_1g(n) \leq f(n) \leq c_2g(n)$ }</li><li>非紧上界记号o<br>o(g(n)) = { f(n) | 对于任何正常数c &gt; 0，存在正数和 $n_0$ &gt;0使得对所有 $ n \leq n_0$有：$0 \leq f(n) &lt;cg(n)$ }<br>等价于  f(n) / g(n) $\to 0$ ，as  n$\to \infty$</li><li>非紧下界记号$\omega$<br>$\omega$ (g(n)) = { f(n) | 对于任何正常数c&gt;0，存在正数和$n_0$ &gt;0使得对所有$n \leq n_0$有：$0 \leq cg(n) &lt; f(n)$ }<br>等价于  f(n) / g(n) $\to \infty$ ，as  n $\to \infty$。<br>$logn&lt;n&lt;nlogn&lt;n^2&lt;2^n&lt;n!$<br><strong>常用关系式</strong><br><img src="https://img-blog.csdnimg.cn/20210702152611349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>例题</strong><br><img src="https://img-blog.csdnimg.cn/20210702161341161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>解：首先得知道渐进关系O的定义：</li></ol><p>O(g(n)) = { f(n) | 存在正常数c和n0使得对所有 n≧n0 有：0 ≦ f(n) ≦ cg(n) }</p><p>即：若 f(n)=O(g(n))，则f(n)≦ g(n)</p><p>主要利用上面的指数和对数两个式子：<br><img src="https://img-blog.csdnimg.cn/20210704192243318.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="分治算法求解排序问题">分治算法求解排序问题</h3><p><strong>分治思想</strong></p><ul><li>对这k个子问题分别求解。如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止</li><li>将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解</li><li>分治法的设计思想是，将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</li></ul><p><strong>分治算法的适用条件</strong></p><ul><li>该问题的规模缩小到一定的程度就可以容易地解决</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有<strong>最优子结构性质</strong></li><li>利用该问题分解出的子问题的解可以合并为该问题的解</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题</li></ul><blockquote><p>这条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用动态规划较好。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210702162858489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>基本思想：</strong><br>将待排序元素分成大小大致相同的2个子集合.递归的分别对2个子集合进行排序.最终将排好序的子集合并成为所要求的排好序的集合.<br><img src="https://img-blog.csdnimg.cn/20210702163103476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(Comparable a[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right)&#123;<br>        <span class="hljs-type">int</span> i = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(a, left, i);<br>        <span class="hljs-built_in">mergeSort</span>(a, i + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-built_in">merge</span>(a, b, left, i, right);<br>        <span class="hljs-built_in">copy</span>(a, b, left, right);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="各个排序算法的时间复杂度">各个排序算法的时间复杂度</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/6611f12fde5c92d2aa299a172794b2e0.png" alt=""></p><h3 id="树">树</h3><p><strong>定义：</strong><br>由一个或多个（n$\leq$0）的节点组成的有限集合，有且仅有<strong>一个节点称为根（root）</strong>，当n&gt;1，其余的节点分为m(m$\leq$0)个<strong>互不相交</strong>的有限集合$T_1,T_2,…,T_m$，被称为这个根的<strong>子树</strong></p><blockquote><p>注意空树也是树</p></blockquote><p>基本概念：</p><p>结点：</p><p>根结点：</p><p>叶子：度为0的结点</p><p>结点的度：拥有所有的子树的个数称为结点的度</p><p>树的度：所有结点度中的最大值</p><p>树的深度/高：所有结点中的最大的层数</p><p><strong>树和线性结构的比较</strong></p><table><thead><tr><th style="text-align:center">线性结构</th><th style="text-align:center">树型结构</th></tr></thead><tbody><tr><td style="text-align:center">第一个数据元素（无前驱）</td><td style="text-align:center">根节点（无前驱）</td></tr><tr><td style="text-align:center">最后一个数据元素（无后继）</td><td style="text-align:center">多个叶子节点（无后继）</td></tr><tr><td style="text-align:center">其他数据元素（一个前驱，一个后继）</td><td style="text-align:center">其他数据元素（一个前驱，多个后继）</td></tr></tbody></table><h3 id="二叉树的概念">二叉树的概念</h3><p><strong>定义</strong>：是一个n（n≥0）个节点的有限集合，由一个根节点以及两课互不相交的，分别称为左子树和右子树的二叉树组成（递归定义）<br><strong>基本特征：</strong><br>每个结点最多有两颗字数；左右子树的次序不能颠倒<br><strong>满二叉树：</strong><br>深度为k，且有$2^{k-1}$个结点的二叉树<br>节点层序编号方法：从根节点起，从上到下逐层（层内从左到右）对二叉树的节点进行连续编号<br><strong>完全二叉树</strong><br>深度为k，结点数为n的二叉树，当且仅当每个节点的编号都与相同深度的满二叉树中从1到n的节点一一对应时，称为完全二叉树。<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_37e5bd75e4-1.png" alt="1.png"></p><p><strong>二叉树与度数为2的树的区别</strong></p><ol><li>度不同 度为2的树要求每个节点最多只能有两棵子树,并且至少有一个节点有两棵子树。二叉树的要求是度不超过2,节点最多有两个叉,可以是1或者0。 在任意一棵二叉树中,叶子结点总是比度为2的结点多一个。</li><li>分支不同 度为2的树有两个分支,但分支没有左右之分; 一棵二叉树也有两个分支,但有左右之分,左右子树的次序不能随意颠倒。</li><li>次序不同 度为2的树从形式上看与二叉树很相似,但它的子树是无序的,而二叉树是有序的。即在一般树中若某结点只有一个孩子,就无需区分其左右次序,而在二叉树中即使是一个孩子也有左右之分。</li></ol><h3 id="二叉树的存储">二叉树的存储</h3><p><strong>顺序存储结构</strong><br>按二叉树的节点“自上而下，从左到右”编号，用一组连续的存储单元存储<br>若是完全二叉树或满二叉树，可以做到<strong>唯一</strong>复原，有规律：下表为i的双亲，其左孩子的下标值必为2i,其右孩子的下标值必为2i+1<br>若不是完全二叉树，一律转化为完全二叉树，通过补空节点节点完成，但是会浪费空间，插入删除不方便<br><strong>链式存储结构</strong><br>二叉链表：2个链表分别存放左孩子和右孩子<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_af34691de4-1.png" alt="1.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//二叉链表的存储表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild, *rchild;<br>&#125;BiTNode, *BiTree;<br></code></pre></td></tr></table></figure><p>三叉链表：2个链表分别存放左孩子和右孩子，一个指向双亲<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_eef65435e4-2.png" alt="2.png"></p><h3 id="二叉树的遍历">二叉树的遍历</h3><p><img src="https://img-blog.csdnimg.cn/20210702165829672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>先序遍历结果：ABCDEFGHIJK<br>中序遍历结果：CDBEFAHGJIK<br>后序遍历结果：DCFEBHJKIGA</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(BiTree bt)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, bt-&gt;data);<br>        <span class="hljs-built_in">preorder</span>(bt-&gt;lchild);<br>        <span class="hljs-built_in">preorder</span>(bt-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(BiTree bt)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">inorder</span>(bt-&gt;lchild);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, bt-&gt;data);<br>        <span class="hljs-built_in">inorder</span>(bt-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(BiTree bt)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">postorder</span>(bt-&gt;lchild);<br>        <span class="hljs-built_in">postorder</span>(bt-&gt;rchild);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, bt-&gt;data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>层序遍历：利用队列，节点出队时将其左右孩子入队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status <span class="hljs-title">LayerTraverse</span><span class="hljs-params">(BiTree T, Status(*visit)(ElemType e))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//层次遍历二叉树</span><br>    <span class="hljs-built_in">InitQueue</span>(Q);<br>    <span class="hljs-keyword">if</span> (T) <span class="hljs-built_in">EnQueue</span>(Q, T);<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">QueueEmpty</span>(Q))&#123;<br>        <span class="hljs-built_in">Dequeue</span>(Q, p);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Visit</span>(p-&gt;data)) <span class="hljs-keyword">return</span> ERROR;<br>        <span class="hljs-keyword">if</span> (p-&gt;lchild) <span class="hljs-built_in">Enqueue</span>(Q, p-&gt;lchild);<br>        <span class="hljs-keyword">if</span> (p-&gt;rchild) <span class="hljs-built_in">Enqueue</span>(Q, p-&gt;rchild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树和二叉树的互换">树和二叉树的互换</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/fe460605a43c811a25acbb92a7534eae.png" alt=""></p><h3 id="先序和中序遍历恢复二叉树">先序和中序遍历恢复二叉树</h3><p>一棵二叉树的先序序列和中序序列分别我：A B C D E F G H J K L M N和C B E D G F A J H K M L N，则二叉树的后序序列为（A）。</p><pre><code>A. C E G F D B J M N L K H A     B. C E D G F B J H K M N L AC. C G F E D B J M N L K H A     D. C E G D F B M N J L K H A</code></pre><h3 id="树的存储结构">树的存储结构</h3><ol><li>双亲表示法</li><li>孩子表示法</li><li>孩子兄弟表示法</li></ol><h3 id="树的遍历方式">树的遍历方式</h3><ol><li>先根层次遍历<br>树的先根遍历简单而言就与，二叉树的前序遍历相似，都是“根左右”，只不过在左右之分上面，不是简单的只是左右而已，而是同一层上面的节点，从左边的节点遍历结束之后才轮到右边的下一个节点（同一层不一定只是左右两个节点）；<br><img src="https://img-blog.csdnimg.cn/20210311080429252.png" alt=""></li><li>后根层次遍历<br>树的后根遍历简单而言就与，二叉树的后序遍历相似，都是“左右根”，只不过在左右之分上面，并没有二叉树那么明确而已。其实树的遍历与二叉树的遍历都是相似的，只不过没有了明确的左右子树的划分而已。<br><img src="https://img-blog.csdnimg.cn/20210311080453995.png" alt=""></li></ol><h3 id="二叉搜索树">二叉搜索树</h3><p><strong>查找</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">(ElementType X, SearchTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (x &lt; T-&gt;Element) <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(X, T-&gt;Left);<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(X, T-&gt;Right);<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> T;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>插入</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">Status <span class="hljs-title">Insert_BST</span><span class="hljs-params">(BiTree &amp;T, ElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SerachBST</span>(T, e.key, p)) &#123;<br>        s = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (BiTNode));<br>        s-&gt;data = e;<br>        s-&gt;lchild = s-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-keyword">if</span> (!p) T = s;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.key &lt; p-&gt;data.key)<br>            p-&gt;lchild = s;<br>        <span class="hljs-keyword">else</span> p-&gt;rchild = s;<br><br>        <span class="hljs-keyword">return</span> TRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图">图</h3><p><strong>定义</strong><br>图G由顶点集V和关系集E组成,记为 G=(V,E)，V是顶点(元素)的有穷非空集，记为V(G).E是V中两个顶点对（称为边）的有穷集合。记为E(G).</p><p>有向图和无向图</p><p><strong>存储结构</strong></p><ol><li>邻接矩阵</li><li>邻接表</li></ol><h4 id="邻接矩阵-2">邻接矩阵</h4><p><strong>01矩阵</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_bcf65c6ce4-1.png" alt="1.png"><br><strong>权重矩阵</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_c47a3ea9e4-2.png" alt="2.png"></p><p>在无向图中顶点$v_i$的度等于邻接矩阵中第i行（或第i列）的元素之和（非零元素个数）</p><p>在有向图中，顶点$V_i$的出度为邻接矩阵中第i行元素之和，顶点$V_i$的入度为邻接矩阵中第i列元素之和</p><h4 id="邻接表">邻接表</h4><p><img src="https://img-blog.csdnimg.cn/20210702171839145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20210702172004557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20210702172113680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="图的邻接矩阵和邻接表的表示比较">图的邻接矩阵和邻接表的表示比较</h3><ol><li>一个图的邻接矩阵表示是唯一的；邻接表表示不唯一。邻接表中各边表结点的次序取决于建立算法和及输入边的次序.</li><li>邻接表（逆邻接表）中，每个边表对应邻接矩阵中的一行(或一列）；边表中结点的个数等于邻接矩阵中的一行(或一列)非0元素的个数。</li><li>邻接表或逆邻接表的空间复杂度为S(n,e)=O(n+e)。若图中的边数e远远小于n2,称为稀疏图，其邻接表比邻接矩阵要节省存储空间。当边数e接近n2 （无向图:e接近n(n-1)/2;有向图:e接近n(n-1)）时，称为稠密图,考虑链域占空间，应选择邻接矩阵存储为宜。</li><li>求有向图顶点的度，采用邻接矩阵比邻接表结构方便。在邻接表结构中，求顶点的出度容易，入度困难。逆邻接表中，求顶点的入度容易，出度困难。</li><li>判断边，邻接矩阵比邻接表容易；求边数：邻接矩阵中花费的时间复杂度为O(n2),邻接表中花费的时间复杂度为O(n+e)</li></ol><h3 id="图的遍历">图的遍历</h3><p><strong>深度优先搜索：</strong><br>关键：递归，栈<br>思想：选定一个出发点后进行遍历，如果有邻接的未被访问过的节点则继续前进。若不能继续前进，则回退一步再前进，若回退一步仍然不能前进，则连续后退至可以前进的位置为止。重复此过程，直到所有与选定点相通的节点都被遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> v0)</span></span><br><span class="hljs-function"></span>&#123;<br>    visited[v0] = <span class="hljs-number">1</span>;<br>    w = <span class="hljs-built_in">firstadj</span>(g, v0);<br>    <span class="hljs-keyword">while</span> (w != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> (visited[w] == <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(w);<br>        w = <span class="hljs-built_in">nextadj</span>(g, v0, w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>广度优先搜索：</strong><br>关键：队列、类似层次遍历<br>思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Graph g, <span class="hljs-type">int</span> v0)</span></span>&#123;<br>    visited[v0] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">Enqueue</span>(Q, v0);<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">Empty</span>(Q))&#123;<br>        v = <span class="hljs-built_in">Dlqueue</span>(Q);<br>        w = <span class="hljs-built_in">Firstadj</span>(g, v);<br>        <span class="hljs-keyword">while</span> (w != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (visited[w] == <span class="hljs-number">0</span>)&#123;<br>                visited[w] = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">Enqueue</span>(Q, w);<br>            &#125;<br>            w = <span class="hljs-built_in">nextadj</span>(g, v, w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="贪心算法">贪心算法</h3><p><strong>思想：</strong><br>在对问题求解时，总是<strong>做出在当前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的<strong>局部最优解</strong>。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是<strong>整体最优解的近似解</strong><br>活动安排问题<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_09805dd3e4-3.png" alt="3.png"></p><p>由于输入的活动以其完成时间的非减序排列，所以算法greedySelector每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。<br>算法greedySelector的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。</p><h3 id="Dijkstr算法求最短路径">Dijkstr算法求最短路径</h3><p><strong>算法思路</strong></p><ul><li>维护一个已被探索过的点集S。S中我们已经得到了从源点s到点u的最短路径</li><li>初始化S={s}，d(s)=0,d(其他)=$+\infty$</li><li>选择出未探索的点中具有最小$\pi(v)$值的点v<br>$$\pi(v)=mind(u)+l_e$$<br>下一个加入探索节点集的点假设为v’</li><li>添加v’到S，并设置d(v’)=$\pi(v’)$</li></ul><ol><li>无向图和有向图无影响</li><li>非负环无影响</li></ol><p><img src="https://img-blog.csdnimg.cn/20210704201100819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="第三章-操作系统">第三章 操作系统</h2><h3 id="程序顺序执行时的特征">程序顺序执行时的特征</h3><ol><li>顺序性<br>处理机的操作严格按照程序所规定的<strong>顺序</strong>执行</li><li>封闭性<br>程序运行时<strong>独占</strong>全机资源，程序一旦开始执行，其执行结果不受外界因素影响。</li><li>可再现性<br>只要程序执行时的环境和初始条件相同，都将获得<strong>相同</strong>的结果。</li></ol><h3 id="进程的定义">进程的定义</h3><ul><li>一个正在<strong>执行</strong>中的程序。</li><li>一个正在计算机上<strong>执行</strong>的程序实例。</li><li>能分配给处理器并由处理器<strong>执行</strong>的实体</li><li>一个具有以下特征的活动单元：一组指令序列的<strong>执行</strong>、一个当前状态和相关的系统资源集</li><li>可并发执行的程序在一个数据集合上的<strong>运行</strong>过程</li></ul><p><strong>引入进程的目的</strong><br>使<strong>多道</strong>程序能够正确地<strong>并发</strong>执行，以保证程序运行结果的可再现性。</p><h3 id="进程三状态转换模型">进程三状态转换模型</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_d1781c36e4-1.png" alt="1.png"></p><h3 id="进程五状态转换模型">进程五状态转换模型</h3><p><img src="https://img-blog.csdnimg.cn/20210702190638127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="挂起状态">挂起状态</h3><p><strong>定义：</strong><br>使执行程序暂停执行，静止下来，不再参与CPU竞争<br><strong>进程挂起的原因</strong></p><ul><li>进程全部阻塞，处理机空闲</li><li>系统负荷过重，内存空间紧张</li><li>操作系统需要，操作系统可能需要挂起后台进程或一些服务进程，或某些可能导致系统故障的进程。</li><li>终端用户的请求</li><li>父进程请求<br><strong>挂起和阻塞的区别：</strong></li><li>挂起是主动行为，阻塞是被动行为</li><li>阻塞会释放GPU，挂起不释放</li><li>挂起时进程在外存而不在主存</li></ul><h3 id="进程的构成和PCB（了解）">进程的构成和PCB（了解）</h3><p><strong>进程的构成</strong>：程序段+数据段+进程控制块(PCB)<br>**进程控制块PCB的作用：**进程存在的唯一标识；PCB常驻内存<br><strong>PCB内部的信息</strong>标识，处理机状态，进程调度信息，进程控制信息。</p><h3 id="运行Fork-创建进程">运行Fork()创建进程</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_2f1103c5e4-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_90d67df1e4-3.png" alt="3.png"><br>父进程要快一点，从fork下一句返回，但是子进程会采用一种操作使得fork返回值为0<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_aa6a7e6be4-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_eecd8bd7e4-5.png" alt="5.png"></p><h3 id="线程">线程</h3><p>**定义：**线程是进程中的一个实体，是独立调度和分派的基本单位。</p><p><strong>三类线程：</strong><br>分类依据：依据线程是否对内核透明</p><ol><li>用户级线程<br>线程的创建等操作全由应用进程完成，操作系统内核不知道线程的存在，仍以进程为调度单位</li></ol><blockquote><p>Infomix支持用户级线程</p></blockquote><ol start="2"><li>内核级线程<br>线程的创建等操作全由系统内核完成，以线程为调度单位</li></ol><blockquote><p>Windows 2000/XP、Linux和OS/2等操作系统采用了内核级线程技术</p></blockquote><ol start="3"><li>混合线程<br>线程的创建，撤销，调度和同步等操作在用户级应用程序中完成，多个用户级线程被影射到一个或较少的某些内核级线程</li></ol><blockquote><p>Solaris操作系统采用了混合线程模式</p></blockquote><h3 id="进程和线程的区别">进程和线程的区别</h3><ol><li>定义不一样，进程是执行中的一段程序，而一个进程中执行的每个任务即为一个线程</li><li>一个线程只属于一个进程，但一个进程可以包含多个线程</li><li>线程无地址空间，他被包含在进程的地址空间中</li><li>线程的开销比进程小</li></ol><h3 id="竞争临界资源引起的问题">竞争临界资源引起的问题</h3><p>间接制约【资源共享】 $\to$ 互斥<br>直接制约【进程合作】 $\to$ 同步<br><strong>临界资源</strong>：必须互斥使用的资源<br><img src="https://img-blog.csdnimg.cn/20210702194249623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>死锁：如果一组进程中的每一个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程是死锁的。<br>饥饿：指系统不能保证某个进程的等待时间上界，从而使该进程长时间等待，当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿。当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。<br>例子：<br>死锁：砍树你需要一个斧子，但是斧子又需要木头来做，这就发生了死锁。<br>饥饿：排队过程中，总有人插队到你前面，你一直处于排队状态，这就发生了饥饿。</p><h3 id="互斥的条件">互斥的条件</h3><ul><li>空闲让进：如临界区空闲，则有进程申请就立即进入</li><li>忙则等待：每次只允许一个进程处于临界区</li><li>有限等待：保证进程在有限的时间内能进入临界区</li><li>让权等待：进程在临界区不能长时间阻塞等待某事件</li></ul><h3 id="信号量方法">信号量方法</h3><p>信号量的两个原子操作：<strong>wait(s)<strong>和</strong>signal(s)</strong>，有时也称作P(s)和V(s)。<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_451b0c1be4-1.png" alt="1.png"><br>P：先将信号量-1，判断信号量是否大于等于0，若是执行程序，否则进程阻塞，进入等待队列<br>V：使信号量+1，释放信号量<br><strong>信号量的物理意义</strong></p><ul><li>s.count &gt; 0表示目前临界资源的<strong>可用</strong>数量，即还可执行wait(s)而不会阻塞的进程数</li><li>每执行一个wait(s)操作，意味着<strong>请求分配</strong>一个单位的资源</li><li>s.count $\leq 0$ 表示已无可用的临界资源，请求该资源的进程被阻塞。此时，s.count的绝对值等于该信号量队列中的<strong>等待进程数</strong></li><li>执行一次signal操作，就意味着<strong>释放</strong>一个单位的资源。若s.count $\leq 0$ 表示s.queue队列中还有被阻塞的进程，需要唤醒该队列中的第一个进程，将它转移到就绪队列中。</li></ul><p><strong>wait，signal的应用</strong></p><ul><li>进程进入临界区之前，首先执行wait(s)原语，若s.count&lt;0,则进程调用阻塞原语，将自己<strong>阻塞</strong>，并插入到s.queue队列中排队。</li><li>一旦其他某个进程执行了signal(s)原语中的s.count+1操作后，发现s.count$\leq$0，即阻塞队列中还有被阻塞进程，则调用<strong>唤醒</strong>原语，把s.queue中第一个进程修改为就绪状态，送就绪队列，准备执行临界区代码。<br><strong>互斥信号量</strong><br>用于申请获释放资源的使用权，通常初始化为1<br><strong>资源信号量</strong><br>用于申请或归还资源，可以初始化为大于1的正整数，表示系统中某类资源的可用个数<br><strong>互斥信号量的取值范围和含义</strong></li><li><strong>两个</strong>并发程序共享临界资源<ul><li>s.count=1,表示无进程进入临界区</li><li>s.count=0,表示已有一个进程进入临界区</li><li>s.count=-1,则表示已有一个进程正在等待进入临界区</li></ul></li><li><strong>n个</strong>进程共享临界区<br>$$-(n-1)\leq s.count \leq 1$$<br><strong>资源信号量的取值范围</strong><br>依赖于<strong>临界资源数量</strong>和<strong>并发程序数量</strong></li></ul><h3 id="生产者消费者问题">生产者消费者问题</h3><p>缓冲区：固定长度<br>生产者：满则等待，空则填充<br>消费者：空则等待，有则获取</p><ul><li>各个生产者，消费者<strong>独立自主</strong>向前推进<ul><li>指针in和out初始化指向缓冲区的第一个存储单元</li><li>生产者通过in指针向存储单元存放数据，一次存放一条数据</li><li>每存放一条数据，in指针向后移动一个位置</li><li>消费者从缓冲区中逐条取走数据，一次取一条数据，相应的存储单元变为“空”</li><li>每取走一条数据后，out指针向后移动一个存储单元</li></ul></li><li>生产者/消费者必须互斥<ul><li>生产者和消费者不能同时读写一个存储单元</li><li>多个生产者不能同时写缓冲区</li><li>多个消费者不能同时取缓冲区数据</li></ul></li><li>生产者/消费者必须同步<ul><li>生产者不能向满缓冲区写数据</li><li>消费者也不能在空缓冲区中取数据<br><strong>用PV解决生产者消费者模型</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_418f766ae4-1.png" alt="1.png"></li></ul></li></ul><p><strong>例题</strong></p><ol><li>图书馆有N个座位，一张登记表，要求(1)阅读者进入时登记，取得座位号；(2)出来时注销。请用P、V操作描述一个读者的使用过程。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP">semaphore empty = N; <span class="hljs-comment">// 记录空闲座位数量</span><br>semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 作为互斥的登记和注销操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">P</span>(empty);<br>    <span class="hljs-built_in">P</span>(mutex);<br>    <span class="hljs-comment">//登记</span><br>    <span class="hljs-built_in">V</span>(mutex);<br>    <span class="hljs-comment">//阅读</span><br>    <span class="hljs-built_in">P</span>(mutex);<br>    <span class="hljs-comment">//注销</span><br>    <span class="hljs-built_in">V</span>(empty);<br>    <span class="hljs-built_in">V</span>(mutex);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>有3个进程PA，PB和PC合作解决文件打印问题：(1)PA将文件记录从磁盘读入主存的缓冲区1，每执行一次读一个记录；(2)PB将缓冲区1的内容复制到缓冲区2，每执行一次复制一个记录；(3)PC将缓冲区2的内容打印出来，每执行一次打印一个记录。缓冲区的大小等于一个记录大小。请用P，V操作来保证文件的正确打印。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-type">int</span> empty1=<span class="hljs-number">1</span>;<span class="hljs-comment">//记录缓冲区 1 是否为空</span><br><span class="hljs-type">int</span> empty2=<span class="hljs-number">1</span>; <span class="hljs-comment">//记录缓冲区 2 是否为空</span><br><span class="hljs-type">int</span> full1 = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录缓冲区 1 是否有数据</span><br><span class="hljs-type">int</span> full2 = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录缓冲区 2 是否有数据</span><br><span class="hljs-type">int</span> mutex1 = <span class="hljs-number">1</span>;<span class="hljs-comment">//对缓冲区 1 的访问互斥</span><br><span class="hljs-type">int</span> mutex2 = <span class="hljs-number">1</span>;<span class="hljs-comment">//对缓冲区 2 的访问互斥</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">cobegin</span><br><span class="hljs-function">    <span class="hljs-title">PA</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-built_in">PB</span>();<br>    <span class="hljs-built_in">PC</span>();<br>    coend<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PA</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//从磁盘读数据</span><br>    <span class="hljs-built_in">P</span>(empty1);<br>    <span class="hljs-built_in">P</span>(mutex1);<br>    <span class="hljs-comment">//将数据存入缓冲区 1</span><br>    <span class="hljs-built_in">V</span>(mutex1);<br>    <span class="hljs-built_in">V</span>(full1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PB</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">P</span>(full1);<br>    <span class="hljs-built_in">P</span>(mutex1);<br>    <span class="hljs-comment">//从缓冲区 1 读数据</span><br>    <span class="hljs-built_in">V</span>(mutex1);<br>    <span class="hljs-built_in">V</span>(empty1);<br>    <span class="hljs-built_in">P</span>(empty2);<br>    <span class="hljs-built_in">P</span>(mutex2);<br>    <span class="hljs-comment">//将数据写入缓冲区 2</span><br>    <span class="hljs-built_in">V</span>(mutex2);<br>    <span class="hljs-built_in">V</span>(full2);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PC</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">P</span>(full2);<br>    <span class="hljs-built_in">P</span>(mutex2);<br>    <span class="hljs-comment">//读取缓冲区 2 的数据并打印</span><br>    <span class="hljs-built_in">V</span>(mutex2);<br>    <span class="hljs-built_in">V</span>(empty2)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进程间的通信">进程间的通信</h3><p><strong>低级通信</strong><br>以信号，信号量作为通信工具，由于其所交换的信息量少而被归结为低级通信<br><strong>高级通信</strong><br>用户可直接利用操作系统所提供的一组通信命令，高效地传送大量数据的一种通信方式<br><strong>消息传递的同步</strong><br>当发送进程调用Send原语发送消息时，若没有空闲的消息缓冲区，则发送进程阻塞<br>当接受进程调用Receive原语接收消息时，如果没有消息可接收，则接收进程阻塞，直到一条消息到达。<br><strong>三种同步方式</strong><br>阻塞发送，阻塞接收<br>不阻塞发送， 阻塞接收<br>不阻塞发送，不阻塞接收<br><strong>如何利用信息传递实现互斥</strong></p><blockquote><p><strong>互斥</strong>：不允许<strong>两个</strong>或<strong>两个以上</strong>的进程<strong>同时</strong>进入临界区</p></blockquote><ul><li>多个并发执行的发送进程和接收进程共享一个邮箱box，且box的初始状态为仅包含一条空消息；</li><li>采用“不阻塞发送，阻塞接收”方式传递消息；</li><li>若邮箱中存在一条消息，则允许一个进程进入临界区。</li><li>若邮箱为空，则表明有一个进程位于临界区，其它试图进入临界区的进程必须阻塞。</li><li>只要保证邮箱中最多只有一条消息，就能保证只允许一个进程进入临界区，从而实现进程互斥使用临界资源。<br><img src="https://cdn.acwing.com/media/article/image/2022/06/05/99310_da2a4d7ee4-2.png" alt="2.png"></li></ul><h3 id="链接方式">链接方式</h3><p><strong>高级语言源代码转换为进程的3个基本步骤</strong></p><ol><li>编译</li><li>链接</li><li>装入<br><strong>静态链接：<strong>在程序运行之前，先将目标模块及他们所需的库函数，链接成一个</strong>完整的装配模块</strong>，以后不再拆开<br>缺点：不利于代码共享；不利于模块的独立升级；可能链接一些不会执行的模块，浪费空间和处理时间<br>**装入时链接：**目标模块在装入内存时，采用边装入边链接的链接方式。<br>优点：便于各模块的独立升级；便于实现模块的共享。<br>缺点：可能链接一些不会执行的模块，浪费空间和处理时间；装入后不能移动位置<br><strong>运行时动态链接：<strong>对于某些目标模块的链接，是在程序</strong>执行</strong>中需要该模块时，由操作系统去找到该模块并将其装入内存，随后把它链接到调用者模块上。<br>优点：不会装入未被用到的目标模块，加快了程序的装入过程，<strong>节省</strong>大量内存空间<br><strong>三者的区别</strong><br>分别在运行之前链接个模块和所需库函数，边装入边链接，执行时链接</li></ol><h3 id="装入方式（了解）">装入方式（了解）</h3><p><strong>绝对装入方式：</strong><br>优点：实现简单。<br>缺点：每次必须装入同一内存区，需要提前知道内存使用情况；不适于多道程序系统。<br><strong>可重定位装入方式：</strong><br>优点：容易实现。<br>缺点：装入后不能移动；存储空间只能连续分配；难于共享</p><h2 id="第四章-编译原理">第四章 编译原理</h2><h3 id="编译相关概念">编译相关概念</h3><p><strong>翻译</strong>：将一种语言编写的程序转换成完全等效的另一种语言编写的程序的过程称为翻译；在计算机中，翻译由一个程序来实现，称为翻译程序。<br><strong>编译</strong>：将高级程序语言翻译成低级语言程序称为编译<br><strong>三种语言</strong>：源语言，工具语言，目标语言<br><strong>三种程序</strong>：源程序，编译程序，目标程序</p><h3 id="编译前端与后端">编译前端与后端</h3><blockquote><p>前端和后端通过中间代码连接，可极大的提高编译器设计与实现的效率<br>前端：主要是与源语言相关的部分<br>词法，语法分析，语义分析和中间代码是生成等<br>后端：主要是与目标语言相关的部分<br>包括优化，目标代码生成等</p></blockquote><h3 id="定义语言">定义语言</h3><p>语言=语法（规则）+语义（规则）<br><strong>语法</strong>：用以<strong>构造语言（程序）<strong>及其成分（语法单位）的</strong>规则</strong>的集合<br><strong>语义</strong>：用以规定语法正确的语法单位<strong>含义</strong>的<strong>规则</strong>的集合</p><p><strong>如何定义一门语言</strong><br>生成（文法）；识别（语法图）</p><blockquote><p>文法和语法图是语言语法的等价表示，<strong>文法从产生的观点来定义语言的语法</strong>，更通用，更准确。<strong>语法图以识别的观点定义语言的语法</strong>，更直观，更清晰。采用生成的方法还是采用识别的方法来定义由语言的设计者确定<br><strong>语法图</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_06004362e5-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_3916c99fe5-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_3daeebece5-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_3f47f8c5e5-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_429e8a18e5-5.png" alt="5.png"></p></blockquote><h3 id="文法">文法</h3><p><strong>定义：<strong>文法是描述语言的语法结构的形式规则，文法G定义成一个四元式：G=($V_T$, $V_N$, $S$, $P$),其中$V_T$是终结符的有限集合，$V_N$是非终结符的有限集合；S是开始符号，S $\in V_N$，P是产生式的非空有限集<br><strong>0型文法</strong>：<br>又称短文语法，能力相当于图灵机<br>产生式形如：α→β，α$\in (V_N ∪ V_T)$且至少含有一个非终结符，β$\in(V_N ∪ V_T)*$<br><strong>产生式左边至少有一个大写字母（非终结符），右边随意</strong><br><strong>1型文法</strong>：<br>上下文有关文法，对终结符进行替换时必须考虑上下文<br>对于其产生式：α→β 要求 |α|≦|β| （S→ε例外） 或产生式形如 αAβ→αωβ，ω属于V +<br>即</strong>右边生成的字母个数必须大于等于左边的字母个数</strong><br><strong>2型文法</strong><br><a href="https://www.zhihu.com/question/21833944">二型文法的理解</a><br>上下文无关文法，简称文法<br>A→α 即产生式左边必须完全都是大写字母。<br><strong>3型文法</strong><br>正则文法，右线性文法<br>A→α 或 A→αB 其中 A、B ∈ $V_N$ ，α ∈ $V_T$ *<br>通俗的解释：所有产生式右边要么没有大写字母，如果有，必须全部写在小写字母的同一边，也就是要保持线性一致<br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_9c176cc3e5-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/06/06/99310_9e6f12bce5-7.png" alt="7.png"><br><strong>约定</strong></p><ul><li>用<strong>英文大写字母</strong>表示终结符</li><li><strong>小写字母</strong>表示<strong>终结符</strong></li><li><strong>希腊小写字母</strong>表示<strong>串</strong></li></ul><h3 id="推导和规约">推导和规约</h3><p><a href="https://blog.csdn.net/weixin_43320847/article/details/105032230?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165445214616781483761418%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165445214616781483761418&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-105032230-null-null.142%5Ev11%5Econtrol,157%5Ev13%5Econtrol&amp;utm_term=%E6%8E%A8%E5%AF%BC%E4%B8%8E%E8%A7%84%E7%BA%A6&amp;spm=1018.2226.3001.4187">推导和规约</a><br><strong>推导</strong>：由产生式右边替换产生式左边<br><strong>规约</strong>：推导的逆过程<br>若存在$v =w0\Rightarrow w1 \Rightarrow …\Rightarrow wn=w, (n&gt;0)称v推导出（产生）w（推导长度为n）, w规约到v$,$记作v \Rightarrow ^{+} w$</p><p>$若有 v \Rightarrow ^{+} w或v=w，则记为v\Rightarrow ^{*}w$</p><p>$\Rightarrow ^{*}包含左右相等即推导长度等于0的情况即最小步数为0而\Rightarrow ^{+}不包括$，即最小步数为1</p><p><strong>最左推导过程</strong>:总是选择每个句型的最左非终结符进行替换<br><img src="https://img-blog.csdnimg.cn/20210703133644202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>最右推导过程（规范推导）</strong>:也称为规范推导，总是选择每个句型的最右非终结符进行替换<br><img src="https://img-blog.csdnimg.cn/20210703133718705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="句型和句子">句型和句子</h3><p><img src="https://img-blog.csdnimg.cn/20210703133939317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>二者关系</strong>：句子是只含终结符的句型，特殊情况<br><img src="https://img-blog.csdnimg.cn/20210703134512198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>注意s本身也是一个句型</strong></p><h3 id="文法和语言">文法和语言</h3><p>文法 G=($V_T,V_N,S,P$) 产生的所有句子的集合, 称为由文法G产生的语言记为L(G)<br>例：<br><img src="https://img-blog.csdnimg.cn/20210703135019956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>若两个文法G和G2有L(G)=L(G2), 则称两文法等价</p><h3 id="短句和直接短语">短句和直接短语</h3><p>令G是一个文法，S是文法的开始符号，假定 αβδ是文法G的一个句型，</p><p>如果有S$\Rightarrow^{*}$ αAδ且 A $\Rightarrow^{+}$ β，则此时称β是相对于非终结符A的, 句型αβδ的短语；</p><p>如果有 S$\Rightarrow^{*}$αAδ且 A $\Rightarrow$ β，则此时称β是相对于非终结符A的, 句型αβδ的直接短语；</p><p>区别在于A是不是一步推导出β，注意不是αAδ的短语</p><p>补充：素短语：含有终结符的短语，并且它的真子 串不具有这个特性。</p><h3 id="句柄">句柄</h3><p><strong>定义</strong>：一个<strong>句型</strong>的<strong>最左直接短语</strong>称为该句型的句柄。<br><strong>特征</strong>：直接短语，所以，它是某规则右部；<br>它是最左边的直接短语<br>一个句型的直接短语可能不止一个，但是其最左直接短语是唯一的。<br><img src="https://img-blog.csdnimg.cn/20210703140457498.png" alt=""></p><h3 id="语法树">语法树</h3><p>语法树的构造过程是从文法的开始符号出发，构造了一个推导的过程<br><img src="https://img-blog.csdnimg.cn/20210703142807306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>文法的二义性</strong>：一个句子有两颗不同的推导树<br><strong>依语法树求：</strong></p><ol><li>n个内部节点（根节点也算）则有n颗子树，每颗子树的叶节点从左至右排列组成一个<strong>短语</strong></li><li>只有父子两代的为直接子树，其叶节点从左至右排列为<strong>直接短语</strong></li><li>由最左端的直接子树求的<strong>句柄</strong></li></ol><h3 id="编译步骤">编译步骤</h3><p><img src="https://img-blog.csdnimg.cn/20210703145437932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><ol><li>词法分析：输入字符串，根据词法规则识别出单词符号</li><li>语法分析：根据语法规则，将单词符号构成各类语法单位，并进行语法检查</li><li>语义分析：根据语义规则，理解语句功能，进行初步编译</li><li>优化：对中间代码进行时间，空间优化，以使代码更有效</li><li>目标代码生成：生成机器语言程序或汇编语言程序</li><li>符号表管理：完成符号表的建立，查找，更新</li><li>出错处理：发现，指出，限制</li></ol><p><strong>说明：</strong></p><ul><li>使用的编译程序不一定总是分成5个阶段</li><li>目标程序不一定能立即执行，可能还要经过链接，装入等阶段</li><li>编译的各阶段均需要和符号表管理程序，出错处理程序打交道</li></ul><h3 id="词法分析">词法分析</h3><p><strong>词法分析功能</strong>：</p><ol><li><strong>扫描</strong>源程序的字符串</li><li>按照词法<strong>规则</strong></li><li><strong>识别</strong>出单词符号作为输出</li><li>对识别过程中发现的词法错误，则输出出错误信息</li><li>过滤到源程序中的注释和空白</li><li>将编译器生成的错误信息与源程序的位置关</li></ol><blockquote><p>词法分析器在编译器中负责1.读取源程序，2.识别单词<br><strong>词法分析器的输出形式</strong></p></blockquote><ol><li>单词种类</li></ol><ul><li>标识符：用来命名程序中出现的变量、数组、函 数、过程、标号等</li><li>基本字：也可称关键字或保留字, 如if、while、 for、do、goto等</li><li>常数：各种类型的常数, 如216、3.14159、TRUE 等</li><li>运算符：如+  -   *   /等</li><li>界符：如;   :   /*   */等</li></ul><ol start="2"><li>单词的输出形式</li></ol><ul><li>二元组<br><strong>词法分析扫描缓冲区结构</strong><br><img src="https://img-blog.csdnimg.cn/2021070413582328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li></ul><ol><li>输入缓冲区：源程序 =&gt;输入缓冲区</li><li>预处理程序：取消注解，剔除无用的空白、跳格、回车、换行等</li><li>扫描缓冲区：输入固定长度字符串，双缓冲区结构：左缓冲区读完后新读入的字符存入右缓冲区</li><li>词法分析：直接在扫描缓冲区进行符号识别<br><strong>超前搜索</strong>：为了判断一个单词符号的类别，而该单词符号并没有这么长，这种扫描方式叫做“超前搜索”<br>起始指针：用来指示正在扫描的单词的起点<br>搜索指针：用来向前搜索，寻找单词的结束</li></ol><h3 id="词法分析两大类型">词法分析两大类型</h3><p><strong>自上而下</strong><br>从文法开始符出发，能否找到一个<strong>最左推导</strong>序列，使得s$\Rightarrow^*w$<br>或者从根节点S开始，能否构造一颗语法树，使得该语法树的叶节点自左至右的连接正好是w？<br><strong>自下而上</strong>：<br>从w出发，能否找到一个<strong>最左规约</strong>（最右推导的逆过程）序列，逐步向上规约，直至文法的开始符S？或者对生成的w语法树，按最左规约对语法树进行剪枝，能否最后只剩下根节点S<br>基本方法：采用栈，移进–规约，将输入串的符号一次入栈，若栈顶（一个或多个符号）形成某个非终止符的候选式（注意此时在栈中  从下往上读），则将其替换，最后只剩下开始符号S则合法<br><img src="https://img-blog.csdnimg.cn/2021070415241429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="自下而上可能遇到的问题">自下而上可能遇到的问题</h3><p>**关键问题：**如何判断栈顶符号串能否形成可规约串？如何进行规约？<br>二者冲突：移进与归约的冲突；归约与归约的冲突</p><h3 id="确定与不确定">确定与不确定</h3><p>自下而上的语法分析分为不确定性和确定的两类<br>回溯分析法是不确定的分析方法<br>递归下降分析法和预测分析法属于确定的分析方法。</p><h3 id="递归下降分析法">递归下降分析法</h3><ol><li>公共左因子：<br>是指在文法的产生式集合中，某个非终止符的多个候选式具有相同的前缀。如：$\alpha \to \alpha \beta_1 | \alpha \beta_2$<br>解决方法：提取左公共因子<br><img src="https://img-blog.csdnimg.cn/20210704141632618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>例如：<br><img src="https://img-blog.csdnimg.cn/20210704141723941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li><li>左递归<br>可能产生无限循环<br>形式为：$A \Rightarrow^+ A\beta$或者直接$A \Rightarrow A\beta$<br>解决办法：</li><li>直接左递归的消除，改写为右递归<br><img src="https://img-blog.csdnimg.cn/20210704143109316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li><li>间接左递归的消除，先把候选式转为直接左递归<br><img src="https://img-blog.csdnimg.cn/20210704143556491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></li></ol><h3 id="预测分析法">预测分析法</h3><p><strong>组成</strong>：预测分析法是一种表驱动的方法，它由下推栈，预测分析表和控制程序组成<br><strong>三种情况的判断</strong></p><ol><li>若</li></ol><h3 id="算法优先分析法">算法优先分析法</h3><h3 id="FIRSTVT集">FIRSTVT集</h3><h3 id="LASTVT集">LASTVT集</h3><h3 id="优先关系表构造法">优先关系表构造法</h3><h2 id="第五章-数据库">第五章 数据库</h2><h3 id="数据库基本概念">数据库基本概念</h3><h3 id="模式的体系结构">模式的体系结构</h3><h3 id="关系模型基本概念">关系模型基本概念</h3><h3 id="关系运算">关系运算</h3><h3 id="连接运算">连接运算</h3><h3 id="完整性约束">完整性约束</h3><h3 id="函数依赖">函数依赖</h3><h3 id="主码和候选码">主码和候选码</h3><h3 id="模式分解">模式分解</h3><h3 id="范式">范式</h3><h3 id="重要例题">重要例题</h3><h3 id="三种数据模型">三种数据模型</h3><h3 id="E-R模型">E-R模型</h3><h3 id="数据库设计阶段">数据库设计阶段</h3><ol><li><p><strong>需求分析阶段</strong>：</p></li><li><p><strong>概念设计阶段</strong>：将用户的需求抽象为用户与开发人员都能接受的概念模型，</p></li><li><p><strong>逻辑设计阶段</strong>：把抽象的概念结构进一步转换为可以被具体的DBMS产品所能支持的数据模型</p></li><li><p><strong>物理设计阶段</strong>：确定的物理存储结构</p></li><li><p><strong>实现阶段</strong>：开发和调试，以及现实数据的录入和试运行等基本工作。</p></li><li><p><strong>运行与维护阶段</strong>：保证数据库系统的效率，以及根据实际运行情况和用户的需求变动进行调整</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算智能复习</title>
      <link href="/2022/05/23/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/05/23/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-互联网情境下的智能预测">第一章 互联网情境下的智能预测</h2><h3 id="强弱连接基本概念">强弱连接基本概念</h3><p>强连接：连接稳定，共通点多，传播范围有限，例如亲戚，朋友，社会认知<br>弱连接：共同点少，例如无意间提到或打开收音机听到的信息</p><h3 id="图的定义">图的定义</h3><p>一个图G=(V,E)由一个非空顶点（或节点）集合V和一个边集合E组成。每条边都有一个或两个与之相关的顶点，称为端点。一条边被称为连接它的端点。</p><h3 id="邻接矩阵">邻接矩阵</h3><p><strong>基本规则</strong><br>连边存在，值为1，连边不存在值为0.<br><strong>对于有向图</strong><br>第i行的含义为从顶点$v_i$出发的边，出度边，箭头的尾，即<strong>出度=第i行中元素之和</strong><br>第j列的含义为到顶点$v_j$结束的边，入度边，箭头的头，即<strong>入度=第i列中元素之和</strong><br><strong>邻接矩阵的n次方</strong><br>R代表可通过1条边到达某节点之间的路径数</p><p>$R*R=R^2$代表可通过R的两条边到达某节点的路径数</p><p>$R^n$代表可通过R中n条边到达的某节点的路径数</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/26/99310_17b7bce5dc-1.png" alt="1.png"></p><p><strong>优点：</strong></p><ul><li>直观，简单</li><li>方便寻找是否有连边存在</li><li>方便寻找任意顶点的邻接点</li><li>方便计算任意顶点的度</li></ul><p><strong>缺点：</strong></p><ul><li>不便于增删节点</li><li>浪费空间：稀疏图（点多，边少），有大量元素</li><li>浪费时间：稀疏图统计需要大量时间</li></ul><h3 id="交叉验证Cross-Validation">交叉验证Cross Validation</h3><p><strong>定义</strong><br>Cross Validation也叫Rotation Estimation，是一种统计学上讲数据样本切割成较小子集的使用方法</p><p><strong>目的：</strong><br>为了得到稳定可靠的模型</p><blockquote><p>在神经网络中常常将样本分为训练集，验证集，测试集，能提高训练精度防止过拟合<br><strong>常见形式</strong><br>K-Fold Cross Validation</p></blockquote><h3 id="混淆矩阵">混淆矩阵</h3><p><strong>定义：</strong><br>也叫误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵来表示（n代表预测类别）<br><strong>二元分类-预测类别：</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/26/99310_84c171d2dc-2.png" alt="2.png"></p><blockquote><p>关于上表的理解，阳性为真，阴性为假，真阳性就是预测为真，实际也为真，假阳性就是预测为真，但实际为假的，假阴性就是预测为假，实际为真，而真阴性就是预测为假，实际也为假，后面的单词就是缩写，真的为T，假的为F，阳性为P，阴性为N</p></blockquote><h3 id="链路预测">链路预测</h3><p><strong>定义：</strong><br>网络中的链路预测（Link Prediction）是指通过已知的网络节点以及网络结构等信息预测网络中尚未产生连边的两个节点之间产生链接的可能性。</p><p>如果两个节点具有相似的网络结构，则他们是相连的</p><p><strong>目的：</strong><br>预测两节点相连的可能性</p><p><strong>应用：</strong><br>社交媒体，好友推荐</p><p><strong>相似度指数：</strong><br>局部相似度Local similarity Indices：仅使用局部信息（信息 节点周围），不是很准确但很快<br>全局相似度Global similarity indices：使用全局信息（信息 在整个网络中），更准确但成本高<br>准本地指数Quasi-local indices：本地和全球之间的权衡</p><p><strong>分类</strong><br>Local Prediction</p><ul><li>公共邻居Common neighbors (CN)<br>两个节点的公共邻居个数<br><img src="https://img-blog.csdnimg.cn/20210629142818578.png" alt="1.png"></li><li>公共邻居比例Jaccard (JC)<br>公共邻居数占两点总邻居的比例<br><img src="https://img-blog.csdnimg.cn/20210629141325855.png" alt="1.png"></li><li>资源分配Resource Allocation (RA)<br>公共邻居的度取倒数，然后累加<br><img src="https://img-blog.csdnimg.cn/20210629141534871.png" alt="1.png"></li></ul><blockquote><p>可以看作公共邻居分配给自己的资源</p></blockquote><ul><li>Adamic-Adar (AA)<br>公共邻居的度数取对后再取倒数，然后累加<br><img src="https://img-blog.csdnimg.cn/20210629141651353.png" alt="1.png"></li><li>Preferential attachment (PA) …<br>两节点度 相乘<br><img src="https://img-blog.csdnimg.cn/20210629142733325.png" alt="1.png"></li></ul><p>Global Prediction</p><ul><li>Katz score</li><li>Hitting time</li><li>PageRank …</li></ul><p>Quasi-Local Prediction</p><h3 id="链路预测-机器学习性能评估指标">链路预测/机器学习性能评估指标</h3><p><strong>灵敏度Sensitivity=召回率Recall</strong></p><p>真阳性率，实际阳性案例中，检测出阳性的比例</p><blockquote><p>实际阳性包括真阳和假阴</p></blockquote><p>真阳性率=$\frac{TP}{TP+FN}$</p><p><strong>特异性Specificity</strong><br>真阴性率，实际阴性案例中，检测出阴性的比例</p><blockquote><p>实际阴性包括真阴和假阳</p></blockquote><p>真阴性率=$\frac{TN}{FP+TN}$</p><p><strong>Precision</strong><br>被预测出阳性的案例中实际为阳性的比例</p><p>$$\frac{TP}{TP+FP}$$</p><p><strong>Accuracy</strong><br>正确分类样本数占总样本数的比例，该值越高，分类效果越好</p><p>$$\frac{TP+TN}{TP+FP+TN+FN}$$</p><p><img src="https://img-blog.csdnimg.cn/20210626145320729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><p><strong>ROC&amp;AUC</strong><br>ROC是以真阳率和真阴率为轴的曲线</p><p>AUC是ROC曲线与坐标轴围成的面积，面积越接近于1，分类效果越好</p><h3 id="网页排序PageRank">网页排序PageRank</h3><p><strong>核心思想：</strong> 非竞价排名</p><p><strong>数量假设：</strong> 在Web图模型中，如果一个页面节点接收到的其他页面指向的入链数量越多，那么这个页面越重要</p><p><strong>质量假设：</strong> 指向网页的入链质量不同，质量高的页面会通过链接向其他页面传递更多的权重。所以越是质量高的页面指向网页，则这个页面越重要。</p><p><strong>迭代公式：</strong><br>$$PR(i)=\sum_{j \in B_i}\frac{PR(j)}{O_j}$$</p><p>$O_j$表示出度，$B_i$表示指向page i的所有网页集</p><p><strong>排名泄露</strong><br>如果存在网页没有出度链接，则会出现排名泄露问题，经过多次迭代后，所有网页的PR值都趋向于0</p><blockquote><p>可以这样理解，就是说所有的权重为1，有一个网站会不断的吸取权重，使得系统中的权重不断减少，经过多次迭代系统内部的权重被吸收完了。</p></blockquote><p><strong>排名下沉</strong><br>若网页没有入度链接，经过多次迭代，其PR值会趋向于0</p><p><strong>排名上升</strong><br>互联网中一个网页只有对自己的出链，或者几个网页的出链形成了一个循环圈。那么在不断迭代过程中，这一个或几个网页的PR值将只增不减</p><h2 id="第二章-互联网情境下的智能学习">第二章 互联网情境下的智能学习</h2><h3 id="过拟合-Overfitting">过拟合 Overfitting</h3><p><strong>根本原因：</strong> 参数过多<br><strong>实际原因：</strong></p><ul><li>训练集和测试集分布不一致</li><li>模型太过复杂而样本量不足</li></ul><p><strong>解决策略：</strong><br>增大数据规模，简化模型，交叉检验，增大正则化系数$\lambda$</p><h3 id="Bias-VS-Variance">Bias VS Variance</h3><p>Bias代表偏差，高Bias代表与真实值偏离大，对应着欠拟合</p><p>Variance代表方差，高Variance代表数据波动大，对应过拟合</p><p><img src="https://img-blog.csdnimg.cn/20210626154804445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h3 id="正则化">正则化</h3><p><strong>概念</strong><br>简单的来说，正则化是一种为了减小<strong>测试误差</strong>的行为（有时候会增加<strong>训练误差</strong>）<br><strong>常用方法</strong></p><ol><li>L1&amp;L2范数正则化<br>在目标函数后面添加一个惩罚项，之后的目标函数为<br><img src="https://img-blog.csdnimg.cn/20210626165721277.png" alt="1.png"><br>$\lambda$是超参数，用于控制正则化程度，L1或L2正则化时，惩罚项对应为L1/L2范数</li><li>Dropout<br>直接在网络层里加一个dropout层，随机丢弃神经网络参数</li><li>earlystopping<br>提前终止可能是最简单的正则化方法，他适用于模型的表达能力很强的时候。一般情况下，一般训练误差会随着训练次数的增多逐渐下降，而测试误差则会先下降而后再次上升。我们需要做的就是在测试误差最低的点停止训练即可。</li></ol><h3 id="范数">范数</h3><p><strong>定义</strong><br>在线性代数中，泛函分析等数学分支中，范数（Norm）是一个函数，其赋予了某个向量空间（或矩阵）中的每个向量以长度或大小，向量$x=[x_1,x_2,…,x_n]$,向量的长度，或者向量到零点的距离，或者相应的两个点之间的距离。对于零向量，另其长度为零。<br><strong>性质</strong><br>满足非负性$||x||\leq 0|，齐次性||CX||=|C|||X||，三角不等式$||x+y||\leq ||x||+||y||$<br><strong>分类</strong><br><strong>$L_0范数$</strong> ||x||为x向量中所有非零元素的个数<br>实现稀疏的模式表示，如果我们用$L_0$范数来求min，规则化一个参数矩阵W，就是使W的大部分元素都是0.（特征简单）</p><p>稀疏的意义：</p><p>实现特征的自动选择：去掉这些没有信息的特征，也就是把这些特征对应的权重置为0</p><p>模型更容易解释：例如患某种病的概率是y，收集到的数据x是1000维的，也 就是我们需要寻找这1000种因素到底是怎么影响患上这种病的概率的。假设 我们这个是个回归模型： y=w1 *x1+w2 *x2+…+w1000 <em>x1000+b 如果最后学习到 的w</em>就只有很少的非零元素，例如只有5个非零的$w_i$，那么我们就有理由相信， 这些对应的特征在患病分析上面提供的信息是巨大的，决策性的。</p><p><strong>L1范数</strong>：||x||为x向量各个元素绝对值之和</p><p>也叫“稀疏规则算子”，同样是使得W中的大部分元素都为0 ， 在一定条件下，L1范数和L0范数可以等价 ，L1范数和L0范数可以实现稀疏， L1因具有比L0更好的优化求解特性而被广泛应用；</p><p>在Wi=0的地方不可微，并且可以分解为一个“求和”的形式，它是L0范数的最 优凸近似，比L0范数要容易优化求解求min（有一些计算机解法）；</p><p><strong>L2范数</strong>||x||为x向量各个元素平方和的1/2次方，L2范数又称Euclidean范数 或者Frobenius范数</p><p>“岭回归”（Ridge Regression），也叫做“权值衰减weight decay”。将L2范数的规则项||W||2最小化，可以使得W的每个元素都很小，都接近于0 ，但与L1范数不同，它不会让它等于0，而是接近于0。</p><p>我们可以实现对模型空间的限制，从而在一定程度上避免了 过拟合</p><p><strong>Lp范数</strong>：||x||为x向量各个元素绝对值p次方和的1/p次方</p><p><strong>L∞范数</strong>：||x||为x向量各个元素绝对值最大那个元素的绝对值</p><h3 id="距离度量">距离度量</h3><p><strong>闵可夫斯基距离：</strong><br>闵氏距离不是一种距离，而是一组距离的定义，对应$L_p$范数，p为参数。</p><p><img src="https://img-blog.csdnimg.cn/20210626160819342.png" alt="1.png"></p><p><strong>典型的闵可夫斯基距离：</strong></p><ul><li>p=1时，即为曼哈顿距离</li><li>p=2时，就是欧几里得距离（欧式）距离</li><li>当$p \to$∞时，就是切比雪夫距离</li></ul><p><strong>损失函数</strong><br>铰链损失（Hinge Loss）：主要用于支持向量机（SVM） 中；</p><p>互熵损失 （Cross Entropy Loss，Softmax Loss ）：用于Logistic 回归与 Softmax 分类中；</p><p>平方损失（Square Loss）：主要是最小二乘法（OLS）中；</p><p>指数损失（Exponential Loss） ：主要用于Adaboost 集成学习算法中；</p><p>其他损失（如0-1损失，绝对值损失）</p><h3 id="时间复杂度">时间复杂度</h3><p><img src="https://img-blog.csdnimg.cn/20210626163143251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><p><strong>计算步骤</strong></p><ol><li>找出算法中重复执行次数最多的语句的频率来估计时间复杂度</li><li>保留算法的最高次幂，忽略所有低次幂和高次幂的系数</li><li>将算法实行次数的数量级放入大O记号中</li></ol><p><img src="https://img-blog.csdnimg.cn/20210626164812545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h2 id="互联网情景下的智能决策">互联网情景下的智能决策</h2><h3 id="四大基本智能体">四大基本智能体</h3><ol><li><p>简单反射智能体Simple Reflex Agent：<br><img src="https://img-blog.csdnimg.cn/20210628130410367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p></li><li><p>基于模型的反射智能体Model-based Reflex Agent：<br>相当于在action由一个网络模型（神经网络或其他网络模型应该都算）计算得到<br><img src="https://img-blog.csdnimg.cn/20210628130735828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p></li><li><p>基于目标的反射智能体 Goal-based agents：<br><img src="https://img-blog.csdnimg.cn/20210628130836443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p></li><li><p>基于用途的反射智能体Utility-based agents:<br>现在用的最多的智能个体框架</p></li></ol><p>个人理解可能相当于不止考虑当前action的V值，还考虑未来的V值，也就是以当前action的Q值为标准。<br><img src="https://img-blog.csdnimg.cn/20210628131018337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h3 id="强化学习框架">强化学习框架</h3><p><img src="https://img-blog.csdnimg.cn/20210628131341652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h3 id="博弈">博弈</h3><p>多智能体之间交互，互相学习训练的过程</p><p><img src="https://img-blog.csdnimg.cn/2021062813165051.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h3 id="机器学习定义">机器学习定义</h3><p>基本定义：</p><p>通过统计学的学习方法，使模型从大量数据中找到规律，从而得到预测未来的能力</p><p>白话定义：<br>举一反三，通过对大量样本的学习总结出规律，再次利用规律对从未见过的样本进行分析，判断并得出结论</p><h3 id="三大机器学习">三大机器学习</h3><ol><li>监督学习：<strong>预测分类</strong></li></ol><p>从<strong>有标签</strong>的训练数据中学习模型，以便对未知或者未来的数据做出预测</p><p>应用：自然语言处理，计算机视觉</p><ol start="2"><li><p>非监督学习：<strong>聚类</strong><br>从<strong>没有标签</strong>的训练数据中学习判断，寻找相似点进行聚类</p></li><li><p>强化学习：<strong>行为决策</strong><br>根据环境数据<strong>选择行为</strong>以最大化预期长期收益</p></li></ol><p>强化学习框架可以融合其他学习的方法但其他学习无法刻画强化学习</p><p>应用：智能机器人，游戏AI， Alpha Go</p><h3 id="强化学习的主要元素">强化学习的主要元素</h3><p>历史（History）：一连串的observation、action和reward</p><p>状态（state）：是历史（History）的函数，用来决定即将发生的情况</p><p>策略（Policy）：环境感知到动作的映射action = f ( state )</p><p>受益（Reward）：定义强化学习中智能个体的目标</p><p>状态估值（State Value）：一个状态的估值就是从这个状态开始，按照某一策略，智能个体期望在未来获得的奖赏</p><p>环境模型（Model of Environment）：刻画环境的演变</p><h3 id="强化学习应用">强化学习应用</h3><ol><li><p>各类游戏：Alpha Go、OpenAI Five</p></li><li><p>资源调度：带宽资源、功率资源</p></li><li><p>自动控制：交通信号灯、无人驾驶</p></li><li><p>推荐排序：个性化、网页排序</p></li></ol><h3 id="Discount">Discount</h3><p>折扣因子关注智能体在过去，现在和未来获得的rewards，也就是说它将奖励和时域联系起来。简单来说，就是对不同时期的reward加权</p><p>discount的值在[0, 1],若discount=0，那么智能体仅关注过去获得的第一个reward，若等于1，则关注未来获得所有的奖励，0，1之间的就介于值之间，自己理解</p><p>使用衰减因子的最终回报函数<br><img src="https://img-blog.csdnimg.cn/20210628150937843.png" alt="1.png"></p><p>通俗解释：不同时期的reward重要程度不一样，discount小于1时，越后期的reward加权值越小，重要程度越小</p><p>在大多数马尔可夫奖励和决策中都是使用了discount，原因是什么呢？</p><ul><li>数学上方便对奖励discount</li><li>避免循环马尔可夫过程中的无限汇报</li><li>未来的不确定性可能无法完全体现</li><li>如果奖励是财务奖励，即时奖励可能比延迟奖励赚取更多的利息</li><li>动物/人类行为表现出对即时奖励的偏好</li><li>有时可以使用未贴现的马尔可夫奖励过程（即discount=1），例如：如果所有序列都终止</li></ul><h3 id="Reward-VS-Value">Reward VS Value</h3><p>简单的来说，reward是当前收益（即时利益），value是长远收益</p><blockquote><p>• Whlie the reward signWal indicates what is good in an immediate sense, a value function     specifiWes what is good in the long run .<br>• Whlie rewards determine the immediate, intrinsic desirability of  environmental states,     values indicate the long-term desirability of states after taking into account the states that    are likely to follow and the rewards available in those states .<br>• Rewards are in a sense primary, whereas values, as predictions of rewards, are   secondary …<br>• We seek actions that bring about states of highest value, not highest reward, because   these actions obtain the greatest amount of reward for us over the  long run.<br>• Rewards are basically given directly by the environment, but values must be estimated   and re-estimated from the sequences of observations an agent makes over its entire   lifetime<br>• A state might always yield a low immediate reward but still have a high value because it is   regularly followed by other states that yield high rewards. Or the reverse could be true<br>• It is much harder to determine values than it is to determine rewards</p></blockquote><ul><li>虽然reward signal 表明什么是<strong>即时</strong>意义的好，但value function指定了从<strong>长远</strong>来看什么是好的</li><li>虽然reward决定了环境状态的直接，内在可取性，但在考虑了可能遵循的这些状态和这些状态中可用奖励后，values表明了状态的长期可取性</li><li>从某种意义上说，reward是主要的，而作为对reward的预测，value是次要的</li><li>我们寻求带来<strong>最高value状态而非最高reward</strong>的行动，因为从长远来看，这些行动会为我们带来最大的reward</li><li>一个状态可能总是产生<strong>较低的即时奖励，但仍然具有很高的价值</strong>，因为它经常被其他产生高奖励的状态跟随，反之亦然。</li><li>确定value比确定reward要困难得多</li></ul><h3 id="Exploit-VS-Explore">Exploit VS Explore</h3><p>探索常用即贪婪搜索，即完全随机选择动作，以寻找到更多可能的情况<br><img src="https://img-blog.csdnimg.cn/20210628144759700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><p><img src="https://img-blog.csdnimg.cn/20210628144947936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt="1.png"></p><h3 id="马尔科夫过程MP">马尔科夫过程MP</h3><p><strong>定义：</strong><br>马尔可夫过程是一个二元组（S，P），且满足：S是有限状态集合，P是状态转移概率：<br><img src="https://img-blog.csdnimg.cn/20200303103916957.png" alt="1.png"><br>马尔科夫过程也称为马尔科夫链：由一些具有马尔科夫性的量随机组成的记忆链，这些量之间有转移概率，如具有马尔科夫性质的stat可以组成马尔科夫链<br><strong>状态转移矩阵：</strong><br>描述当前状态转移到可达的多个状态的概率值（一行），行和都为1<br><img src="https://img-blog.csdnimg.cn/20200303104120445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt="1.png"><br>实例：<br>在马尔科夫链中，假如学生在上class 1，那么结束class 1后有0.5的概率继续上class 2，也有0.5的概率会去刷facebook，那么class1对应行的值为【0，0.5， 0， 0， 0， 0.5， 0】<br><img src="https://img-blog.csdnimg.cn/20200303104447841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt="1.png"></p><p><img src="https://img-blog.csdnimg.cn/20200303105149956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt="1.png"></p><p>求得完整的马尔可夫状态转移矩阵</p><h3 id="马尔科夫奖励过程MRP">马尔科夫奖励过程MRP</h3><p>仅仅有上面的MP还不足以做出决策，RL本质上是一个基于reward的过程，我们需要引入reward，在马尔可夫链中可以表示为下图所示效果，比如进入Facebook状态时reward=-1</p><p><img src="https://img-blog.csdnimg.cn/20210628151509755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>MRP值函数：</strong><br>在一个episode中，我们每完成一个状态就给一个奖励，回合结束时将奖励累积起来就是最终的回报(return)，在这也就是MRP值函数，定义如下，其中r是衰减discount，不明白的可以看上面介绍Discount部分。<br><img src="https://img-blog.csdnimg.cn/20200303105727741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>计算MRP值函数（设衰减r=0.5）：</strong><br>C1 C2 C3 Pass Sleep：  $v = -2 - 2 * 0.5 - 2 * 0.5 ^2 +10 * 0.5^3 + 0 * 0.5^4 = -2.25$</p><p>C1 FB FB C1 C2 Sleep:   $v = -2 - 1 * 0.5 - 1 * 0.5 ^2 - 2 * 0.5^3 - 2*0.5^4 + 0 * 0.5^4 = -3.125$</p><blockquote><p>就是将该路径上的权值采用上图的方法来进行处理</p></blockquote><h3 id="贝尔曼方程Bellman-Equation">贝尔曼方程Bellman Equation</h3><p>从上面的计算可以看出不同情况下，每个状态的v值时不同的，而我们value function计算的是期望值，此时就需要贝尔曼方程来计算每个状态的value期望值，</p><p>即当前状态的value值 = 当前状态的奖励R + 衰减 * 下一步各状态的v值 * 转移概率</p><p><img src="https://img-blog.csdnimg.cn/20210628153124305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p>举个例子：</p><p>下图中C3下一步可选状态有两个，其v值分别为10和0.8，设衰减为1</p><p>$4.3 = - 2 + 1 *（ 0.6 *10 +0.4 *0.8） $</p><p><img src="https://img-blog.csdnimg.cn/20200303112603372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""></p><p>如果把r设为0.9：</p><p>$4.1 = - 2 + 0. 9 *（ 0.6 * 10 +0.4 *1.9 ）$</p><p><img src="https://img-blog.csdnimg.cn/20210628153928184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p>此时会产生一个问题，这里的10 和 1.9是哪来的呢?我们需要从终止状态Sleep算起，终止状态Sleep的V值就等于他的R值，一步步反向推到，或者是建方程组求解所有的V值，具体计算过程这里不讨论（主要是考试不考），上面的计算其实就只是验证了一下计算的正确性。</p><h3 id="马尔科夫决策过程MDP">马尔科夫决策过程MDP</h3><p>有了MP和MRP，要完成RL的决策目标就需要最后加入一个action形成一个完整的决策过程<br><strong>MDP值函数：</strong><br>主要分为状态-值函数（v值）和动作-值函数（q值），一个基于状态，一个基于动作和状态，如下：<br><img src="https://img-blog.csdnimg.cn/20200303130209971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200303130209971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""><br>q值与v值的关系如下：<br><img src="https://img-blog.csdnimg.cn/20200303131350591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""><br><strong>也就是说，v值是采取不同动作产生q值概率加权而来的</strong><br><strong>q值公式：</strong><br><img src="https://img-blog.csdnimg.cn/20210628171858154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>如果采取某一动作后只进入一个状态，那q值其实就等于采取动作的R值+下一状态v值*衰减即：</p><p>q = R +  rV，若r=1，那么q = R + v</p><p>简单来说就是q等于R加上下一状态的V值，如果采取动作可能进入多个状态，那就状态加个权</p><p>计算示例：</p><p>注意此图中的R值是采取动作的R值，不同于上面的进入某状态的R值，注意观察R的位置</p><p>在下图中，圆圈里的值代表每一个状态的V值，对于7.4的状态，下一步有两个动作选择，所以我们先来计算两个动作的q值，都记r=1</p><p>第一个动作选择Study进入终止状态，R=10，但是终止状态后没有后续选择，于是公式后半部分为0，此时q值就为R=10；</p><p>第二个动作选择Pub，R=-2，但执行次动作进入的状态不确定，可能还会进入三种状态，此时累加衰减<em>概率</em>下一步V值，最后加上R即为当前动作的q值</p><p>最后用两个q值乘上对于概率就求导了当前状态的v值7.4<br><img src="https://img-blog.csdnimg.cn/20210628172447366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>寻找最优策略</strong><br>一个简单的最优策略可以通过找到每步最大的q值得出，如下图</p><p>从左上开始，每步选择q值最大的动作，最终红线就是最优化策略</p><p><img src="https://img-blog.csdnimg.cn/20200303143859306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pvaG5KaW0w,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="贝尔曼最优等式">贝尔曼最优等式</h3><p><img src="https://img-blog.csdnimg.cn/20210628184445289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""><br>需要注意的是贝尔曼最优等式是非线性的，因此没有一个通解，常用的解决方法如下：<br><img src="https://img-blog.csdnimg.cn/20210628184523792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk4MTIyNA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="互联网情景下的智能交互">互联网情景下的智能交互</h2><h3 id="公开竞价拍卖">公开竞价拍卖</h3><p><strong>升价拍卖</strong><br>英式拍卖，加价获胜者支付自己的最终出价<br><strong>降价拍卖</strong><br>荷兰式拍卖，价格一直降低，直到有人接受</p><h3 id="密封出价拍卖">密封出价拍卖</h3><p><strong>一价拍卖</strong><br>出价最高者得，支付最高价格<br><strong>二价拍卖</strong><br>出价最高者得，支付第二高得价格</p><h3 id="HA匹配问题">HA匹配问题</h3><h4 id="定义">定义</h4><p>这是一个具有<strong>单边偏好</strong>的<strong>多一、二部</strong>匹配问题，存在单边偏好（或者我们主要关心一方的偏好）</p><ul><li>学生在校园里挑选住房</li><li>学生选择新生研讨会</li></ul><p>HA的一个实例包括</p><ul><li>一个申请人的集合 $$A = {a_1,a_2,…,a_{n1}} $$</li><li>一个房子集合 $$H= {h_1,h_2,…  ,h_{n2}} $$</li></ul><p>每个申请人对一套房子都有一定的偏好。</p><h4 id="最优匹配">最优匹配</h4><p>什么是“好”结果？</p><ul><li>帕累托最优匹配</li></ul><blockquote><p>直观地说，如果没有申请人能在不要求另一个申请人使自己过得更差，那么匹配是帕累托最优的</p></blockquote><ul><li>流行匹配</li><li>基于配置文件的最优匹配</li></ul><h4 id="帕累托最优匹配">帕累托最优匹配</h4><p>求帕累托最优匹配的算法</p><ul><li>（随机）系列独裁机制(SDM)<ul><li>每个学生都有一个优先权（可能是在住房抽签中随机分配的）</li><li>学生们按他们的优先级的顺序选择房子</li></ul></li><li>处理申请人的顺序将会影响申请结果</li><li>所得到的帕累托最优匹配是不同的大小的</li><li>定理:连续独裁是有效的（即之后没有相互同意的交易）和战略证明的。</li></ul><h4 id="证明-2">证明</h4><p>策略证明</p><ul><li>有第一选择的人会得到她最喜欢的房子，所以显然没有撒谎的动机</li><li>有第二选择的人在剩下的房子中得到她喜欢的房子，所以同样没有理由撒谎。</li><li>等等<br>效率</li><li>有优先权的个人并不想进行交易。</li><li>考虑到她出局了，有第二优先级的人不想交易</li><li>等等…。<br><img src="https://cdn.acwing.com/media/article/image/2022/05/27/99310_5b1a0368dd-1.png" alt="1.png"></li></ul><h4 id="变体">变体</h4><p>初始捐赠</p><ul><li>在每个申请人最初拥有一件商品的情况下，这被称为房屋市场(HM)问题</li><li>亚伯拉罕给出了一个个体理性的算法，它确保每个最初拥有一个房子的申请人最终都拥有相同或更好的房子。</li><li>缩短申请人的优先名单，取消所有比最初捐赠更好的房屋。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 计算智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计量经济学复习</title>
      <link href="/2022/05/20/%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/05/20/%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-回归分析概述">第一章 回归分析概述</h2><p><strong>计量经济学研究路线</strong></p><ul><li><strong>建立</strong>理论模型</li><li><strong>确立</strong>计量经济学模型</li><li><strong>搜集</strong>检查并整理<code>数据</code></li><li><strong>估计</strong>计量经济学模型</li><li><strong>评价</strong>计量经济学模型</li><li><strong>应用</strong>计量经济学模型</li></ul><p><strong>回归分析的现代含义</strong></p><blockquote><p>回归分析是关于研究一个叫做因变量的变量（Y）对另一个或多个叫做自变量的变量（X）的依赖关系</p></blockquote><blockquote><p>其用意在于通过自变量在重复抽样中的已知或设定值，去估计或预测因变量的总体均值</p></blockquote><p>确定关系：确定变量之间的函数关系</p><p>统计关系：随机变量之间的依赖关系</p><p><code>计量经济学关注的是统计关系</code></p><p><strong>线性的含义</strong><br>有两种线性，变量线性和参数线性</p><p>线性回归是指对估计参数为线性的一种回归（即估计参数只以一次方出现），对自变量X则可以是或不是线性的</p><p>判断下列方程是不是线性回归？</p><p>$E(Y|X_i)=\beta_0+\beta_1^2 X_i$ 不是线性回归<br>$E(Y|X_i)=\beta_0+\beta_1 X_1 X_2$ 是线性回归</p><p>随机干扰项 $\varepsilon_i=Y_i-E(Y_i|X_i)$</p><p>残差 $\hat{\varepsilon_i}=e_i=Y_i-\hat{Y_i}$</p><h3 id="小结">小结</h3><ol><li>计量经济学，从字面意思来上讲，叫&quot;经济度量&quot;，属于经济学的一个分支学科，主要致力于量化理论关系。回归分析虽然仅仅是计量经济学分析方法的一种，确实目前最常用的一种方法。</li><li>计量经济学最主要的用途为：描述经济关系、假设检验和预测。根据研究的需要，特定的计量经济学方法会有所不同。</li><li>尽管回归分析设定被解释变量是一个或者多个解释变量的函数，但回归分析本身并不能证明或隐含因果关系。</li><li>回归方程中必须加入随机误差项，用于度量被解释变量没有完全被解释变量解释而形成的误差。随机误差项的组成部分有：①遗漏或者省略变量；② 数据的测量误差；③隐含理论的函数形式与回归方程不同； ④纯随机误差或不可预知的事件。</li><li>估计出的回归方程式真实回归方程的近似代替，是从包含X和Y的样本数据中计算出来的。由于真实回归方程不可知，所以，计量经济分析注重的是估计出的回归方程和回归参数的参数估计值。被解释的变量的特定观测值与其估计值之差成为残差。</li></ol><h3 id="例题-4">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_d2511414d9-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_d4572aacd9-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_d6c6d98ed9-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_d81d9d6ed9-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_db0f4b34d9-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_dcccbbc2d9-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/22/99310_0d33f34ed9-7.png" alt="7.png"></p><h2 id="第二章-最小二乘法">第二章 最小二乘法</h2><p><strong>偏回归系数</strong>：当其他变量相同（保持其他变量不变）时，特定变量对被解释变量的边际影响（贡献）</p><p>n为样本量，k为待估计参数数量，通常情况下$n \geq 5*k$</p><p>最小二乘法估计量$ \hat{\beta} $是确定性变量还是随机变量？为什么？</p><p>$\hat{\beta}$是由Y计算来的，Y是一个随机变量，随机性来自随机干扰项 $\varepsilon$,$\varepsilon$影响Y，Y影响$\hat{\beta}$，所以$\hat{\beta}$是一个随机变量，同时如果Y服从<strong>正态分布</strong>，那么$ \hat{\beta} $也服从<strong>正态分布</strong></p><p>判断估计量优劣的标准是什么？</p><ul><li>估计值的均值是否等于真实值：无偏性</li><li>估计量的方差是否足够小：有效性</li><li>估计量的极限是否趋于真实值：一致性</li></ul><p><strong>控制变量的选择</strong><br>去什么，加什么，因为我们的被解释变量受到多个因素的影响，仅仅用一元线性回归是不够的，以餐厅收入案例为例，虽然我们关心的是居民收入对于餐厅收入的影响，但我们考虑到竞争对手的数量还有人口密度等等会影响餐厅收入，如果不把这两个影响因素去掉，可能得不到真实的回归结果，为了去除这两个因素的影响，我们要把这两个变量加入道方程中去。</p><p><strong>古典假设</strong>：</p><ol><li>回归模型是线性的，模型设定无误且含有误差项。</li><li>误差项的总体均值为0。</li><li>所有解释变量与误差项都不相关</li><li>误差项观测值互不相关（不存在序列相关性）</li><li>误差项具有同方差（不存在异方差性）</li><li>任何一个解释变量都不是其他解释变量的完全线性函数（不存在多重共线性）</li><li>误差项服从正态分布（该假设是选择性的，但通常被采用）</li></ol><p><strong>古典假设小结</strong></p><ol><li>7个古典假设表述为：回归模型是线性的且含有一个均值为0且与解释变量不相关的误差项；各误差项观测值之间不想管；误差项观测值之间互补相关；误差项的方差相同，服从正态分布（不要求）；另外，解释变量之间一定不能相互存在完全的线性函数关系。</li><li>估计量的两个最重要的性质是无偏性和最小方差性。无偏估计量是指被估计参数的期望与真实值相等的估计量。在给定的一类估计量中（例如无偏估计量），茹估计值分布的方差在所有估计量中最小时，则满足最小方差性。</li><li>在古典假设下，普通最小二乘估计量被证明具有最小方差性，线性，无偏性（或称BLUE，即最优线性无偏估计量），即高斯——马尔科夫定理。当一个或多个古典假设不成立时（正态分布假设除外），在某些时候，尽管普通最小二乘法仍然能够提供比随后章节中所讨论的其他可供选择估计的方法得到的更好的估计量，但普通最小二乘估计量不再是BLUE的。</li><li>因为$\hat{\beta_k}$的普通最小二乘估计量的抽样分布是BLUE的，所以$\hat{\beta_k}$具有令人满意的性质。另外，随着被观测样本数量的增加，$\hat{\beta_k}$的抽样分布中的方差（或离散程度）减小。</li><li>计量经济学中有一套标准的记述符号，如下表所示</li></ol><table><thead><tr><th style="text-align:center">总体参数</th><th style="text-align:center">（真实值，但不能观测）</th></tr></thead><tbody><tr><td style="text-align:center">回归参数</td><td style="text-align:center">$\beta_k$</td></tr><tr><td style="text-align:center">参数估计量的期望</td><td style="text-align:center">$E(\hat{\beta_k})$</td></tr><tr><td style="text-align:center">误差项的方差</td><td style="text-align:center">$\sigma^2 或 VAR(\varepsilon_i)$</td></tr><tr><td style="text-align:center">误差项标准差</td><td style="text-align:center">$\sigma$</td></tr><tr><td style="text-align:center">参数估计量的方差</td><td style="text-align:center">$\sigma^2(\hat{\beta_k})$ 或 $VAR(\hat{\beta_k})$</td></tr><tr><td style="text-align:center">参数估计量的标准差</td><td style="text-align:center">$\sigma_{\hat{\beta_k}}$ 或 $\sigma(\hat{\beta_k})$</td></tr><tr><td style="text-align:center">误差项或随机干扰项</td><td style="text-align:center">$\varepsilon_i$</td></tr></tbody></table><table><thead><tr><th style="text-align:center">估计值</th><th style="text-align:center">（由样本观测得到）</th></tr></thead><tbody><tr><td style="text-align:center">回归参数估计值</td><td style="text-align:center">$\hat{\beta_k}$</td></tr><tr><td style="text-align:center">误差项的方差的估计值</td><td style="text-align:center">$s^2 或 VAR(\sigma^2)$</td></tr><tr><td style="text-align:center">误差项标准差的估计值</td><td style="text-align:center">$s$ 或 $SE$</td></tr><tr><td style="text-align:center">参数估计量的方差估计值</td><td style="text-align:center">$s^2(\hat{\beta_k})$ 或 $\widehat{VAR}(\hat{\beta_k})$</td></tr><tr><td style="text-align:center">参数估计量的标准差估计值</td><td style="text-align:center">$\hat{\sigma_{\hat{\beta_k}}}$ 或 $SE(\hat{\beta_k})$</td></tr><tr><td style="text-align:center">残差项</td><td style="text-align:center">$e_i$</td></tr></tbody></table><p><strong>拟合优度</strong><br>OLS估计量是BLUE（最小方差性[有效性]，线性，无偏性），但采用OLS不一定能够得到满意的结果</p><p>从几何意义上说，拟合优度是指样本回归线对样本数据拟合得多好</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_31504084da-9.png" alt="9.png"></p><p><strong>判定系数$(R^2)$</strong><br>$$R^2=\frac{回归平方和}{总平方和}=\frac{ESS}{TSS}=1-\frac{RSS}{TSS} &lt; 1$$</p><p>一般来说，$(R^2)$的值越接近1，表明拟合优度越好；相反，越接近0，意味着回归估计方程不能比样本均值$\bar{Y}$更好的解释$Y_i$的值</p><p>判定系数$(R^2)$是解释变量个数的非减函数，即增加解释变量，$(R^2)$会增加或不变</p><p>$(R^2)$不是越大模型越好</p><ul><li>增加无关的解释变量，使模型失去经济含义</li><li>降低<code>自由度</code>，降低参数估计量的可靠性</li></ul><blockquote><p>自由度：观测样本数    减去待估参数的个数</p></blockquote><p><strong>调整的判定系数</strong></p><blockquote><p>对参数（包括截距项）的个数k进行惩罚，在模型拟合优度（好）与其复杂性（不好）之间进行权衡</p></blockquote><p>$$\bar{R^2}=1-\frac{\sum e_i^2/(n-k)}{\sum y_i^2/(n-1)}=1-(1-R^2)\frac{n-1}{n-k}$$</p><blockquote><p>当模型中新增解释变量时，$\bar{R^2}$变化的方向（上升、下降或者不变）依赖于新变量对回归拟合的贡献是否超过对损失一个额外自由度所作修正的补偿</p></blockquote><ul><li>拟合优度仅是衡量回归总体质量的指标之一</li><li>参数估计值符合经济理论的程度、研究者对参数预期比拟合优度更加重要</li></ul><h3 id="小结-2">小结</h3><ol><li>普通最小二乘法是利用一组数据求的回归参数估计值的最常用的方法。普通最小二乘法使得一个特定样本的残差平方和（$\sum e_   i^2$）最小。</li><li>调整的判定系数$\bar{R^2}$是经过自由度调整后的判定系数，他衡量了Y与他的均值被特定回归方程解释的比例。方程中新增加一个变量时，只有拟合有毒提高的程度超过了自由度下降的损失，调整的判定系数$\bar{R^2}$才会更大，所以，多数研究者在评价回归方程的拟合优度时，都自然地使用调整地判定系数$\bar{R^2}$</li><li>切记，估计方程地拟合有毒只是一个衡量回归整体质量地指标之一。许多其他的标准，包括参数估计值与经济理论地一致性，以及与预期（研究者在搜集数据前做出地预期）的一致性，都比调整的判定系数$\bar{R^2}$更重要。</li></ol><h3 id="例题-5">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_bce57b9cda-11.png" alt="11.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c0eb49a7da-12.png" alt="12.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c375484ada-13.png" alt="13.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c5b58d86da-14.png" alt="14.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_003ac9f1da-18.png" alt="18.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c8449c40da-15.png" alt="15.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_ca7936cbda-16.png" alt="16.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_ce0d5917da-17.png" alt="17.png"></p><h2 id="第三章-假设检验">第三章 假设检验</h2><h3 id="假设检验的基本原理">假设检验的基本原理</h3><p>我们用样本的信息来检验总体的信息</p><p><strong>假设检验</strong>：先对总体的特征作出某种假设，然后通过<strong>抽样研究的统计推理</strong>，对此假设应该拒绝还是被接受做出推断</p><p>基本思想：<strong>小概率原理、反证法</strong></p><p>原假设（$H_0$） 备择假设($H_A$)</p><p>因为拒绝假设比较简单，我们只需要举出一个反例，而接受一个假设相对比较困难，因为我们可能需要穷举所有的情况</p><p>因此我们就可以根据研究者预期来设计假设，我们将希望出现的结果作为备择假设，将不希望出现的结果作为原假设</p><p>如果回归分析希望出现一个正的参数$\beta$,原假设和备择假设应该为：<br>$$H_0:\beta \leq 0; H_A: \beta &gt; 0$$</p><blockquote><p>单侧检验：具有明显的预期</p></blockquote><p>如果回归分析希望参数$\beta$不为零，原假设和备择假设应该设为：<br>$$H_0: \beta = 0; H_A: \beta \ne 0$$</p><blockquote><p>双侧检验： 预期不确定</p></blockquote><p>假设检验是要确定一个标准（判定准则），以便决定<strong>拒绝</strong>或<strong>不拒绝</strong>某个原假设$H_0$</p><p>当拒绝原假设时，通常表述为<strong>统计上显著</strong>;反之，<strong>统计上不显著</strong></p><p><strong>两类错误</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">$H_0$为真</th><th style="text-align:center">$H_0$不为真</th></tr></thead><tbody><tr><td style="text-align:center">拒绝$H_0$</td><td style="text-align:center">第一类错误（弃真）</td><td style="text-align:center">正确</td></tr><tr><td style="text-align:center">不拒绝$H_0$</td><td style="text-align:center">正确</td><td style="text-align:center">第二类错误（纳伪）</td></tr></tbody></table><p>犯第一类错误的概率：$P(H_A|H_0)=\alpha$</p><p>犯第二类错误的概率：$P(H_0|H_A)=\beta$</p><blockquote><p>$\alpha$ 越大 $\beta$越小,我们主要关注第一类错误出现的概率$\alpha$</p></blockquote><p><strong>假设检验的判定准则</strong></p><ul><li>判定准则是比较样本统计量与预先设定的临界值之间的大小</li><li>参数估计值范围分为两个区域：<strong>拒绝域</strong>和“<strong>接受域</strong>”</li></ul><h3 id="假设检验的方法">假设检验的方法</h3><p><strong>置信区间法</strong><br>根据参数估计量的分布，在给定的<strong>置信水平</strong>（如95%）下，构造一个随机<strong>置信区间</strong>；若该随机区间覆盖原假设值，则不拒绝原假设，否则拒绝原假设<br><strong>置信区间的构造</strong><br>首先设定<strong>显著性水平</strong>（第一类错误的概率）$\alpha$,然后确定一个正数 $\delta$,使得随机区间$(\hat{\beta}- \delta, \hat{\beta}+ \delta)$包括参数真实值$\beta$的概率为$1-\alpha$(置信水平)<br>$$P(\hat{\beta}- \delta \leq \beta \leq \hat{\beta}+ \delta)=1-\alpha$$</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_969ce206da-20.png" alt="20.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_b46c86c6da-21.png" alt="21.png"></p><p><strong>显著性假设法</strong><br>显著性检验法直接比较参数估计值和原假设之间的差异大小。若&quot;差异&quot;  较大，则拒绝原假设；反之，不拒绝原假设</p><p><strong>怎样判断差异的大小</strong><br>判断$\hat{\beta}-\beta_0$是否显著异于0的关键在于构造一个函数f($\hat{\beta}-\beta_0$)(称为统计量),该统计量具有确定的分布规律；比较该统计量的值与分布临界值来判断差异是否显著</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_1bd35f12da-22.png" alt="22.png"></p><p>如果得到的P值小于我们要求的显著性水平（5%）的话，我们就拒绝原假设，反之，不拒绝。</p><h3 id="t检验-2">t检验</h3><p>检验单个变量对被解释变量是否由解释力</p><p>$$t=\frac{\hat{\beta}-\beta_0}{se(\hat{\beta})}$$</p><p><strong>单侧T检验的判定方法</strong></p><ul><li>根据<strong>t值</strong>判断，如果$|t_k|&gt;t_c$,<strong>并且</strong>$\beta_k$的符号与$H_A$隐含的符号相同（符合预期），则拒绝$H_0$</li><li>根据<strong>P值</strong>判断：如果P值小于研究所要求的显著性水平，且$\beta_k$的符号与$H_A$隐含的符号相同（符合预期），则拒绝$H_0$</li></ul><blockquote><p>计量经济学分析中，大多数情况采用单侧检验</p></blockquote><blockquote><p>采用双侧检验的情况：估计值得符号没有明确得预期或者是否显著性于某个特定的值</p></blockquote><p><strong>永远牢记：不要把t检验得出的统计显著性等同于理论的有效性</strong></p><p>在回归分析中，t检验不能检验相应变量的相对“重要性”，检验数字特征要用到统计检验，后面会提到<br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_e82d7ec7da-23.png" alt="23.png"></p><p><strong>t检验的陷阱</strong>：随着样本容量的增大，t值会越来越大的原因在于：标准误会随着样本数量增加而减小，标准误越小t统计量就会越大</p><p>对于一个超大规模的样本而言，t检验没有任何意义，因为你几乎可以拒绝任何原假设</p><p>综上所述，<strong>t检验的局限性</strong></p><ul><li>t检验不能检验理论有效性</li><li>t检验不能检验“重要性”</li><li>t检验不是针对总体的检验</li></ul><h3 id="F检验-2">F检验</h3><p>$$F=\frac{(RSS_R-RSS_{UR})/J}{RSS_{UR}/(n-k)}$$<br>其中J为约束条件个数，K为估计的参数个数（包括$\beta_0$）</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_3cc9369fda-24.png" alt="24.png"></p><p>对多个假设的联合检验<strong>或</strong>对线性约束的假设检验不能用t检验，只能用<strong>F检验</strong></p><p><strong>一种检验思路</strong></p><ul><li>将线性约束（原假设）代入线性回归方程，可得<strong>约束最小二乘估计量</strong></li><li>约束最小二乘的拟合将劣于无约束最小二乘的拟合，即<strong>约束导致拟合的损失</strong></li><li>约束最小二乘的RSS将大于无约束最小二乘的RSS，可据此构建统计量</li></ul><p><strong>检验回归模型的总体显著性</strong><br>RSS为残差平方和<br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_b0de6097da-25.png" alt="25.png"></p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_e20bbb72da-26.png" alt="26.png"><br><strong>检验某个偏回归系数等于某个特定值</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_5819e71dda-1.png" alt="1.png"></p><p><strong>检验规模报酬不变</strong></p><p><strong>邹检验</strong><br>结构变化：时间序列回归中，模型的参数在整个样本期间内可能发生变化</p><ul><li>邹检验的假定：两个子时期回归的误差项是独立且具有同方差的正态分布变量</li><li>邹检验只告诉我们不同时期的回归方程是否有差别，并没有告诉我们差别来自截距，斜率还是二者兼有</li><li>邹检验假定我们知道结构转折点</li></ul><h3 id="正态性检验">正态性检验</h3><p>采用JB检验（雅克-贝拉检验）</p><h3 id="小结-3">小结</h3><ol><li>通常，确定被解释变量后，应用回归分析采用六个步骤：<br>a. 查阅文献，建立理论模型<br>b. 确定模型：选择解释变量及函数形式<br>c. 对参数的符号做出假设<br>d. 搜集、检查和整理数据<br>e. 估计和评价方程<br>f. 报告结果</li><li>虚拟变量只能取值0或1，这取决与是否满足某些特定状态条件。虚拟变量的例子就是当为女性时X等于1，为男性时X等于0</li></ol><h3 id="例题-6">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_66fb7a8fda-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_5ddb70aeda-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_6980e992da-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_6a8abdefda-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_6cefa212da-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_6ffd8581da-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_7286f40eda-7.png" alt="7.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_754d6c6eda-8.png" alt="8.png"></p><h2 id="第四章-模型设定">第四章 模型设定</h2><p><strong>正确的方程</strong></p><ul><li>正确的解释变量</li><li>正确的函数形式</li><li>正确的随机误差项</li></ul><p><strong>如何正确的选择解释变量</strong></p><ul><li>最重要的选择依据：（经济理论判断）</li><li>若理论上不明确，则可采用统计方法来判断<ul><li>遗漏变量</li><li>不相干变量</li></ul></li></ul><p><strong>遗漏变量的后果</strong></p><blockquote><p>设定偏误：参数估计量<strong>有偏</strong>且非一致，方差变小</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_05ed6799da-9.png" alt="9.png"></p><p><strong>加入不相干变量的后果</strong></p><blockquote><p>参数估计量<strong>无偏</strong>但非有效（方差变大），t检验失效</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_7c5108f8da-10.png" alt="10.png"></p><p><strong>模型选择准则</strong></p><ul><li>判定系数<br>$$R^2=1-\frac{RSS}{TSS}$$<br>$$\bar{R^2}=1-\frac{\sum e_i^2/(n-k)}{\sum y_i^2/(n-1)}=1-(1-R^2)\frac{n-1}{n-k}$$</li><li>赤池信息准则（AIC）和施瓦茨信息准则（SC）<br>$AIC=\frac{2k}{n}+ln{\frac{RSS}{n}}$ 如果你加入一个新的解释变量那么AIC会增大 $\frac{2}{n}$<br>$SC=\frac{k}{n}lnn+ln{\frac{RSS}{n}}$ 如果加入一个新的解释变量那么SC会增大 $\frac{lnn}{n}$</li></ul><blockquote><p>AIC和SC准则对增加解释变量加大了惩罚，其中SC的惩罚比AIC更严厉。相对而言，AIC和SC的值越低的模型越好。</p></blockquote><p>看下面的例子，可以发现中间的AIC和SC值是最小的，该模型也确实更好<br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_ea8040c5da-1.png" alt="1.png"></p><p><strong>模型设定的四个重要准则</strong></p><ol><li>理论：变量在方程中的含义是不是模糊不清的，从理论上看是不是合理的？</li><li>t检验：变量的待估参数在预期假设下是否显著？</li></ol><blockquote><p>不能简单地将一个t值不显著的变量从方程中排除，要结合理论与实际</p></blockquote><ol start="3"><li>调整的判定系数$\bar{R^2}$或AIC和SC：在变量加入后，方程的整体拟合优度（自由度调整后）是否得到了改善</li><li>偏误：变量加入方程后，其他变量的参数值是否发生了显著性改变？</li></ol><p><strong>模型设定搜索</strong></p><ul><li>数据挖掘<ul><li>适当的数据挖掘也许有助于揭示经济学理论尚未说明的经验规律</li><li>不适当的数据挖掘，比什么都不做更坏：如果你对数据严刑拷打，它就会屈打成招</li></ul></li><li>敏感性分析：稳健性分析<ul><li>几乎所有学术论文的必备步骤和分析内容</li><li>稳健的含义：某种结果对于各种模型设定，变量定义，数据子集都是显著的（或不显著的）</li></ul></li></ul><h3 id="解释变量选择小结">解释变量选择小结</h3><ol><li>由于遗漏变量在某种程度上都与已包含变量之间有相关性，因此，遗漏变量会导致方程中剩余变量的参数估计值产生偏误。</li><li>由遗漏变量所引起的偏误等于遗漏变量的参数乘以已包含变量和未包含变量的简单相关系数的函数。</li><li>方程中包含一个真正的不相关变量并不会因此偏误，但会增加已包含变量参数估计值的方差，因此会使t统计量和调整的判定系数$\bar{R^2}$都降低。</li><li>方程中包含一个变量的四个有用准则：<br>a. 理论<br>b. t检验<br>c. 调整的判定系数$\bar{R^2}$<br>d. 偏误</li><li>回归方程中包含一个变量的最重要的准则是理论，而不是统计上的显著性，否则存在产生错误或不可信结果的风险</li></ol><p><strong>错误函数形式的后果</strong></p><ul><li>影响解释变量的显著性</li><li>解释变量可能有非预期的符号</li><li>严重影响模型解释和变量预测</li></ul><p><strong>函数的选择形式</strong><br><strong>不含常数项的回归</strong><br>$$Y_i=\beta_i X_i+\epsilon_i$$<br>可以证明：</p><ul><li>残差均值不一定为0</li><li>拟合优度的判定系数可能出现负值</li></ul><blockquote><p>除非有非常强的先验预期，否则还是采取含有常数项的模型为好；<strong>即使先验预期为无常数项模型，仍可使用含常数项的模型，再检验其常数项在统计上等于0即可</strong></p></blockquote><p><strong>可线性化</strong>的非线性函数形式</p><ul><li>指数函数</li><li>对数函数</li><li>反函数形式</li><li>多项式形式</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c05791f3da-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_c206fb53da-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_fc20ea32da-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_fecb0efeda-5.png" alt="5.png"></p><p><strong>如何选择函数形式</strong></p><ul><li>选择经济理论给出的特定函数形式</li><li>所选模型的参数应满足一定的先验预期</li><li>当多个模型能很好地拟合数据时，研究者往往选择调的判断系数较高或者AIC和SC较低的模型。<strong>然而，当被解释变量Y被替换时，这些指标不能比较</strong></li></ul><h3 id="函数形式选择小结">函数形式选择小结</h3><ol><li>即使理论上常数项可以等于零，也不能剔除常数项。另外，尽管常数项的估计值在理论上是显著的，也不能对常数项进行推理</li><li>函数形式的选择必须基于潜在的经济理论，也就是说要根据理论上的曲线形状去选择相应的函数形式。除非有特别要求需要选择其他形式，模型中变量的函数形式通常都是选用变量是线性的方程。</li><li>变量是非线性的函数形式包括双对数形式，半对数形式以及多项式形式。双对数形式特别适用于弹性是固定的模型中。半对数形式能用于哪些随着解释变量的增加，解释变量对于被解释变量的影响逐渐变小的模型中。多项式形式通常用于斜率符号会随着解释变量的不断变化而改变的模型中。</li><li>斜率虚拟变量是由一般解释变量和虚拟变量的成绩构成的。其中，这个一般解释变量于被解释变量之间的斜率会因为虚拟变量的设定状态是否被满足有所不同。</li><li>使用非线性函数形式存在一系列的潜在问题。特别地，如果解释变量Y的函数形式不同，则各个模型的调整的判定系数$\bar{R^2}$不能进行比较；此外，如果选择了错误的函数形式对样本范围外进行预测，那么，预测结果的残差可能会非常大。</li></ol><h3 id="例题-7">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_258f61eeda-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_1e5c6bfeda-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_20e2de13da-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/23/99310_2925f4a1da-4.png" alt="4.png"></p><h2 id="第五章-多重共线性">第五章 多重共线性</h2><p><strong>多重共线性定义</strong><br>回归模型中的一些或者全部解释变量之间存在一种完全或不完全的线性关系。</p><p>完全多重共线性：<br>$\lambda_1X_1+\lambda_2X_2+…+\lambda_kX_k =0$</p><p>不完全多重共线性：<br>$\lambda_1X_1+\lambda_2X_2+…+\lambda_kX_k + v_i=0$</p><p>只要不是完全多重共线性，用OLS仍可以得到参数的估计值及其标准误，并且仍是无偏，尽管无偏，但估计量的标准误非常大，即估计的精度很小。</p><p>多重共线性可能会导致估计量的标准误偏大，同时可能导致参数的估计值的符号与预期符号不符。</p><p>若总体中各解释变量X之间<strong>没有</strong>线性关系，样本中各解释变量X之间<strong>也可能</strong>存在线性关系。</p><blockquote><p>多重共线性本质上是一种样本现象。</p></blockquote><p><strong>不完全多重共线性的特征</strong></p><ul><li>偏回归系数的t值会降低，倾向于统计上的不显著;</li><li>估计量（偏回归系数）对模型设定的变化非常敏感，估计系数可能出现<strong>非预期的符号或难以置信的数值</strong>;</li><li>虽然系数不显著，但总的拟合优度$R^2$<strong>却可能</strong>非常高</li><li>可能出现每个偏回归系数的t值都不显著，但回归方程的F值却很显著。</li></ul><p><strong>不完全多重共线性对预测的影响</strong></p><ul><li>如果回归分析的唯一目的是预测，并且如果不完全共线性的结构在样本和未来都保持一致，那么不完全多重共线性不是一个严重的问题</li><li>如果不完全共线性的结构在未来发生变化，则预测是冒险的</li></ul><p><strong>多重共线性的来源</strong></p><ul><li>经济变量之间具有共同变化的趋势<blockquote><p>如经济繁荣时期，基本经济变量都趋于增长；衰退时期又同时趋于下降</p></blockquote></li><li>模型中包含滞后变量<blockquote><p>考察当期收入和前期收入对消费的影响，两期收入间有较强的线性相关性</p></blockquote></li><li>横截面数据之间存在相关性<blockquote><p>生产函数中资本投入与劳动力投入往往出现高度相关的情况，大企业二者都大，小企业都小</p></blockquote></li></ul><p><strong>多重共线性的诊断</strong></p><ul><li>解释变量之间的相关系数 如果有多个变量，采用偏相关系数的方法</li><li>回归模型估计结果 $R^2$F统计量显著，但是单个变量不显著，并且有些变量参数符号不符合预期 经验做法</li><li>方差膨胀因子(VIF)</li></ul><p><strong>多重共线性的补救措施</strong></p><ul><li>剔除支配变量<blockquote><p>支配变量：与被解释变量高度相关，以致于完全掩盖了方程中其他解释变量的影响（如销售量与销售额）</p></blockquote></li><li>增加样本容量<blockquote><p>样本越大，估计越精准</p></blockquote></li><li>剔除多余变量<blockquote><p>潜在的理论假设作为剔除的主要依据</p></blockquote></li><li>变换解释变量<ul><li>一阶差分</li><li>两个变量相除</li><li>构造一个多重共线性的组合<ul><li>主成分分析法</li><li>因子分析法</li></ul></li></ul></li><li>什么都不做</li></ul><h3 id="小结-4">小结</h3><ol><li>完全多重共线性违背了一个解释变量不能是其他或多个解释变量的完全线性函数的古典假设。完全多重共线性会导致回归参数估计值的不确定性，并使得这些估计值具有巨大的标准差，从而使得普通最小二乘法不再适用</li><li>使用“多重共线性”一词时，通常指的是不完全多重共线性。不完全多重共线性指的是两个或多个解释变量之间存在较强的线性关系，以至于能够显著地影响方程中解释变量的参数估计。多重共线性问题既是一种样本现象，同时也是一种理论现象。不同的样本可能存在不同程度的多重共线性。</li><li>严重的多重共线性产生的主要结果是增大了回归参数估计量的方差，同时使得这些参数估计值的t统计量变小，扩大了置信区间。多重共线性不会导致参数估计值有偏，它对于回归方程的整体显著性或者任何一个不是多重共线性的解释变量的参数估计值都几乎没有多少影响。</li><li>由于在不同数据集中多重共线性的程度会有显著的不同，所以，在诊断多重共线性时需要注意的问题就是：在一个特定的样本当中，多重共线性究竟有多严重。</li><li>用来诊断严重多重共线性的两种有用的方法是：<br>a. 解释变量之间的简单相关系数是否很高？ 一般来看，相关系数的绝对值如果大于0.80，则认为很高。<br>b. 方差膨胀因子是否很高？一般来看当 $VIF(\hat{\beta_i}) &gt; 5$,则存在严重的多重共线性。<blockquote><p>如果两个答案中任意一个是“是”，则多重共线性确实存在，但是当答案同时为“否”时，也可能存在多重共线性问题。</p></blockquote></li><li>针对多重共线性有如下三种最为常用的补救措施：<br>a. 什么都不做（这样可以避免方程设定偏误）<br>b. 去除多余的变量<br>c. 增大样本容量</li><li>对于多重共线性的问题，什么都不做往往是最好的补救措施。假如多重共线性没有使t统计量减少到不显著的程度，那么就不需要对多重共线性采取任何补救措施。即使t统计量不显著，针对多重共线性所采取的补救措施也必须谨慎，因为补救所带来的估计成本，可能比从方程中消除多重共线性所获得潜在收益还要大。</li></ol><h3 id="例题-8">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_2a52cea6db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_2d8e6892db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_2f98a836db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_3243fae4db-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_3469286edb-5.png" alt="5.png"></p><h2 id="第六章-序列相关性">第六章 序列相关性</h2><p><strong>序列相关性的形式</strong></p><ul><li>一阶序列相关<blockquote><p>干扰项只与其滞后一期值相关 $\varepsilon_t=f(\varepsilon_{t-1})$</p></blockquote></li><li>高阶序列相关<blockquote><p>干扰项与其滞后多期值相关 $\varepsilon_t=f(\varepsilon_{t-1},\varepsilon_{t-2},…)$</p></blockquote></li></ul><p>序列相关通常假定为线性序列相关，最常见的形式为一阶序列相关<br>$$\varepsilon_t=\rho\varepsilon_{t-1}+u_t$$</p><blockquote><p>其中，$\rho$为一阶自相关系数，且$|\rho|&lt;1$;$u_t$为白噪声序列，满足$E(u_t)=0,Var(u_t)= \sigma_u^2,Cov(u_t,u_t+s)=0,s \ne 0$</p></blockquote><p><strong>根据自相关系数$\rho$，序列相关可分类如下</strong></p><ul><li>$\rho &gt; 0 \to $ 正序列相关</li><li>$\rho &lt; 0 \to $ 负序列相关</li><li>$\rho = 0 \to $ 无序列相关</li></ul><p><strong>序列相关类型</strong></p><ul><li>非纯序列相关<ul><li>由<strong>设定偏误</strong>导致，如遗漏变量、不正确的函数形式等</li></ul></li><li>纯序列相关<ul><li>时间序列数据：对同一总体的连续的观测很可能表现出某种系统的相关性，特别是连续观测时间间隔很短，如一周，一天，甚至同一天多次观测</li></ul></li></ul><p><strong>序列相关的后果</strong><br>在纯序列相关性的情形下</p><ul><li>OLS估计量仍是<strong>无偏的</strong></li><li>OLS估计的假设检验<strong>不可靠</strong></li><li>OLS估计量<strong>不再是有效</strong>的（即最小方差估计量）</li><li>标准误的OLS估计是<strong>有偏的</strong>，且偏差通常是负的，意味着OLS通常会高估参数的t值，导致原本不显著的变量可能变得显著</li></ul><p><strong>序列相关的检验</strong><br>检验思路：<strong>检验序列相关，也就是检验随机误差项之间的相关性及“形式”</strong></p><p>因随机误差项的样本对应物是OLS的残差，因此所有的检验都基于<strong>残差</strong></p><p><strong>常用检验方法</strong></p><ul><li>图解法</li><li>杜宾——沃森（DW）检验</li><li>BG检验</li></ul><p><strong>图解法</strong><br>将残差对时间描点，以发现残差在时间上的特定关联</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_99b5c3a7db-1.png" alt="1.png"></p><p><strong>杜宾——沃森（DW）检验</strong><br>利用方程的残差构成统计量，推断误差项是否存在一阶序列相关</p><p>基本假定</p><ul><li><p>回归模型包含截距项</p></li><li><p>序列相关是<strong>一阶</strong>序列相关</p></li><li><p>回归模型不能把<strong>滞后被解释变量</strong>作为解释变量</p></li><li><p>d检验值为0，意味着序列存在完全正相关</p></li><li><p>d值为2意味着不存在序列相关性</p></li><li><p>d值为4意味着序列存在完全负相关。</p></li><li><p>$0 &lt; d &lt; 2 \to 0 &lt; \rho &lt; 1$</p></li><li><p>$2 &lt; d &lt; 4 \to -1 &lt; \rho &lt; 0$</p></li></ul><p><strong>d统计量的检验</strong></p><ul><li>由于d统计量依赖于残差，而残差又依赖于X，故无法推导出d统计量的准确分布</li><li>D-W根据样本容量n和待估参数k，在给定显著性水平下，给出了d统计量上，下两个临界值$d_U和d_L$</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_f0c1f0badb-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_26faf637db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_29614da7db-4.png" alt="4.png"></p><p><strong>DW检验的缺陷</strong></p><ul><li>当d统计量落在两个不确定区域时，无法判断是否存在序列相关</li><li>当滞后因变量作为解释变量，检验无效</li><li>只能检验一阶序列相关，不适用于高阶序列相关</li><li>若误差项不是IID正态分布，d检验也不可靠</li></ul><p><strong>BG检验</strong></p><p>这里$\varepsilon_t$没有常数项是因为其期望值为0</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_d1e77c77db-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_56814ba8db-6.png" alt="6.png"></p><p><strong>序列相关的补救措施</strong><br>非纯序列相关</p><ul><li>正确的模型设定，特别是出现负的序列相关<br>纯序列相关</li><li>广义最小二乘法：广义差分法<br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_c55a4c5fdb-1.png" alt="1.png"></li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_30533aaddb-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_328db523db-3.png" alt="3.png"></p><blockquote><p>实际中，有时只要迭代两次，就可得到较满意的结果。两次迭代过程也被称为**科克伦-奥科特两步法 **</p></blockquote><p><strong>几点说明</strong></p><ol><li>GLS的DW检验值和调整的$R^2$不能与OLS进行比较</li><li>GLS的估计值通常与OLS的估计值不同</li><li>在小样本中，因相关系数的估计可能有偏，GLS估计的系数可能也是有偏的</li></ol><ul><li><p>AR方法</p></li><li><p>Newey——West方法</p><ul><li>只修正标准误而不会改变系数的估计值</li><li>在大样本估计中，效果更好</li><li>绝大多数学术论文采用此种方法</li></ul></li></ul><h3 id="小结-5">小结</h3><ol><li>序列相关，也叫自相关，违背了古典假设四（即误差项的值彼此不相关）。通常，计量经济学家更多关注的是1阶序列自相关，即误差项当前值是前1期值和序列不相关的误差项u的函数：<br>$$\varepsilon_t=\rho\varepsilon_{t-4}+u_t, -1&lt;\rho&lt;1$$</li><li>纯序列相关是正确设定的回归方程中误差项的相关函数。非纯序列相关是由遗漏了变量或选择了不正确的函数形式等错误设定引起的，可以为正相关（$0&lt;\rho&lt;1$）,也可以为负相关（$-1&lt;\rho&lt;0$）。在经济和商业环境下，纯序列相关几乎都是正相关。</li><li>序列相关性的主要后果是采用普通最小二乘法估计的SE $(\hat{\beta})$是有偏的，导致假设检验不可靠。纯序列相关不会造成参数$\beta$的有偏估计。</li><li>诊断1阶序列相关性最常用得到方法是杜宾——沃森d检验。它用回归估计的残差检验误差项是否存在序列相关性。d检验值为0，意味着序列存在完全正相关，d值为2意味着不存在序列相关性，d值为4意味着序列存在完全负相关。</li><li>消除方程序列相关性的第1步时检查可能存在的设定错误，只有当非纯序列相关存在的可能性很小时，才能考虑修正纯序列相关性。</li><li>广义最小二乘法（GLS）是通过变换方程以消除纯1阶序列相关的方法。运用广义最小二乘法时需要 $\rho$的估计值。</li><li>Newey-West标准差时另一种修正序列相关性的方法。这种方法在考察序列相关性时，在不改变估计量值 $\hat{\beta}$的情况下，调整普通最小二乘估计的标准差SE $(\hat{\beta})$</li></ol><h3 id="例题-9">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_65781cbcdb-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_67b8314adb-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_69770554db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_6ca77114db-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_6db91db6db-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_700c3b04db-6.png" alt="6.png"></p><h2 id="第七章-异方差性">第七章 异方差性</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_f7a988dadb-1.png" alt="1.png"></p><p><strong>异方差类型</strong><br>非纯异方差</p><ul><li>由<strong>设定偏误</strong>导致，如遗漏变量</li><li>函数设定形式不当一般不会导致非纯异方差</li></ul><p><strong>纯异方差</strong></p><ul><li><strong>横截面数据</strong>：被解释变量取值差异较大</li><li>时间序列数据：学习效应，数据采集技术的变化</li></ul><p><strong>纯异方差的后果</strong></p><ul><li>OLS估计量仍然是<strong>无偏</strong>的</li><li>OLS估计量<strong>不再是有效</strong>的（即最小方差估计量）</li><li>标准误的OLS估计量是<strong>有偏</strong>的，且偏差<strong>通常</strong>是负的，意味着OLS通常会高估参数的t值，导致原本不显著的变量可能变得显著</li></ul><blockquote><p>若存在异方差，OSL估计的假设检验不可靠</p></blockquote><p><strong>异方差的检验</strong><br>检验思路：检验异方差，也就是检验随机误差项的方差与比例因子Z或解释变量X之间的相关性及其“形式”</p><p>因随机误差项<strong>方差</strong>的样本对应物是OLS的残差<strong>平方</strong>，因此所有的检验方法都基于<strong>残差平方</strong></p><p><strong>图解法</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_5028b5c5db-2.png" alt="2.png"></p><p><strong>帕克检验</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_52410ba7db-3.png" alt="3.png"></p><p>*<strong>white（怀特）检验</strong><br>基本思想：异方差来源于解释变量及其高次方<br>$$Y_i=\beta_0+\beta_1X_{1i}+\beta_2X_{2i}+\varepsilon_i$$</p><p>步骤1：假设同方差，OLS估计获得残差<br>步骤2：做辅助回归并得到拟合优度$R^2$<br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_6599c024db-4.png" alt="4.png"></p><p>步骤3：在无异方差的假设下有<br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_94218bfcdb-5.png" alt="5.png"></p><p>步骤4：若计算的$nR^2$超过选定显著性水平的临界值，则拒绝同方差假设。</p><blockquote><p>有一个经验判断，如果white检验中不包含交叉项，则主要针对异方差性的检验，如果包含交叉项的话，这个检验就是针对模型设定偏误和异方差性的联合检验</p></blockquote><p><strong>异方差的补救措施</strong></p><ul><li>非纯异方差<ul><li>正确的模型设定</li></ul></li><li>纯异方差<ul><li>广义最小二乘法：加权最小二乘（WLS）<ul><li>使用WLS的前提是知道比例因子Z及其与误差项方差之间的关系，即权重向量P</li></ul></li><li>修正异方差的标准误：White方法<ul><li>只修正标准误而不会改变系数的估计值</li><li>在大样本估计中，效果更好</li><li>绝大多数学术论文采用此种方法</li></ul></li><li>重新定义新变量<ul><li>将某些变量，特别是被解释变量取对数</li><li>根据经济理论，对某些变量进行“规模调整”</li></ul></li></ul></li></ul><h3 id="小结-6">小结</h3><ol><li>古典假定5要求误差项应服从相同方差的分布，而异方差性正是对此假定的违背。同方差的误差项的观测值的分布是，对于所有观测值而言都具有相同的方差；异方差性的误差项观测值的分布是，对于不同观测值而言，方差不完全相同。界面是数据模型中，最常产生异方差性。</li><li>异方差性误差项的方差不等于常数 $\sigma^2$,而等于 $\sigma_i^2$（其中下标表明方差随观测值的不同而变化）。异方差性有许多种，但是最常用的异方差性模型是将方差看成某个其他变量（比例因子Z）的函数<br>$$VAR(\varepsilon_i)=\sigma^2Z_i^2$$<br>比例因子通常是跟被解释变量的规模或者精确度相关联的一个变量</li><li>纯异方差性是指异方差性是由误差项的一个函数所表示的，而该误差项是设定正确的方程回归得到的。纯异方差性是由方程设定偏误（比如遗漏变量）导致的。</li><li>异方差性的主要后果是：最小二乘法的SE$(\hat{\beta})$有偏，从而导致假设检验的结果不可信。纯异方差性并不导致$\beta$本身的偏误。</li><li>检验异方差性的主要方法是BP检验和White检验，他们都是通过分析原方程的残差平方可以被辅助方程解释的程度来检验异方差性的。</li><li>修正异方差性的第一步是检查异方差性是否因为遗漏变量而引起的非纯异方差性。如果方程设定正确，那么，就可以考虑采用HC标准差，重新定义变量等措施对异方差性进行补救。</li></ol><h3 id="例题-10">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_b375e682db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_b4a997c0db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_b70b1d06db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_b96c7fb5db-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_bc63d7fedb-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_be261426db-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_c14e4c42db-7.png" alt="7.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_c381ba78db-8.png" alt="8.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_c54e5b0edb-9.png" alt="9.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_c90f48bddb-10.png" alt="10.png"></p><h2 id="第八章-虚拟变量模型">第八章 虚拟变量模型</h2><p><strong>经济变量</strong><br>- 可以度量的变量：商品需求量，价格，收入，产量等<br>- 无法定量度量；职业，性别，战争，自然灾害等<br><strong>虚拟变量</strong>：定性变量</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_2b391e39db-1.png" alt="1.png"><br>解答：因为如果加入东部，那么三个虚拟变量相加等于1，就会存在多重共线性</p><p><strong>虚拟变量的设置原则</strong></p><ul><li>每一定性变量所需的虚拟变量个数要比该定性变量的类别少1，即如果有m个定性变量，只能在模型中引入m-1个虚拟变量</li><li>在同一方程中，可以引入多个虚拟变量来考察多种定性因素的影响</li></ul><p><strong>虚拟变量的引入</strong></p><ul><li>加法形式：考察<strong>截距的不同</strong><br>$$Y_i=\beta_0+\beta_1X_i+\beta_2D_i+\mu_i$$</li><li>乘法形式：考察<strong>斜率的不同</strong><br>$$C_t=\beta_0+\beta_1X_t+\beta_2D_tX_t+\mu_t$$</li><li>混合形式： <strong>截距和斜率同时发生变化</strong><br>$$Y_i=\beta_0+\beta_1X_i+\beta_3D_i+\beta_4(D_iX_i)+\mu_i$$</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_0de0a155db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_48d8fbf7db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_4b258a20db-4.png" alt="4.png"></p><p><strong>计量经济学中的实验方法</strong><br><strong>随机分配实验</strong></p><ul><li>处理组：参与实验人员</li><li>对照组或控制组：未参与实验人员<br><strong>自然实验</strong></li><li>观测值自然产生，由外生事件引起</li><li>自然时间，政策变动</li></ul><h3 id="例题-11">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_f7a84806db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_f9c6cf69db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_ffd4b727db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_01b79418db-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_04a20d2edb-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_0667430adb-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_08d57cd8db-7.png" alt="7.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_0b295e6edb-8.png" alt="8.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/24/99310_0d7f931edb-9.png" alt="9.png"></p><h2 id="第九章-虚拟应变量模型">第九章 虚拟应变量模型</h2><p><strong>虚拟应变量的概念</strong></p><ul><li>虚拟变量既可以作为解释变量，又可以作为被解释变量（应变量）</li><li>虚拟应变量模型又称为概率模型，离散选择模型<ul><li>二元选择模型</li><li>多元选择模型</li></ul></li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_b32092f5db-1.png" alt="1.png"></p><p>LPM模型存在的问题：</p><ul><li>$\hat{D_i}$的取值可能不在0和1之间</li><li>调整的判定系数$\bar{R^2}$不能准确度量方程的拟合优度</li><li>随机干扰项不服从正态分布，且存在异方差</li></ul><p><strong>Logit模型</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_5b687c48db-2.png" alt="2.png"></p><p><strong>Probit模型</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_aee3d9ecdb-4.png" alt="4.png"></p><blockquote><p>采用<strong>极大似然估计法</strong>来估计Logit模型和Probit模型</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e7e2c668db-9.png" alt="9.png"></p><p>因为这两种方法的分布函数不同，会得到不同的结果，这两组系数不能直接比较，但是二者系数存在一定的关系</p><p>标准正态分布的方差为1，而标准逻辑分布的方差为$\pi^2/3$，因此将Probit系数乘以$\pi/ \sqrt 3$（约1.81)，就会近似得到Logit系数（约为0.55）</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_4f38b362db-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_52c9d7b3db-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_55dfdc04db-7.png" alt="7.png"></p><p><strong>其它虚拟应变量模型</strong></p><ul><li>多元Logit模型<ul><li>被解释变量存在<strong>多种</strong>离散且<strong>无序</strong>的选择</li><li>如择业的选择，交通工具的选择</li><li>采用极大似然估计</li></ul></li><li>序次Logit模型<ul><li>被解释变量存在<strong>多种</strong>离散且<strong>有序</strong>的选择</li><li>如债券的评级，舆论调查结果</li><li>采用极大似然估计</li></ul></li></ul><p><strong>补充</strong></p><ul><li>当被解释变量是虚拟变量时，不能采用线性概率模型（OLS估计方法）</li><li>Logit和Probit模型可用于估计被解释变量是二分应变量（二元选择）的问题</li><li>在解释变量是多元选择问题中，可以采用多元Logit模型或次序Logit模型</li></ul><h3 id="小结-7">小结</h3><ol><li>线性概率模型是用来解释虚拟变量$(D_i)$的参数线性方程，$\hat{D_i}$是$D_i$等于1的概率</li><li>采用普通最小二乘法估计线性概率模型会出现三个主要问题：<br>a. 调整的判定系数$\bar{R^2}$不能准确度量模型的整体拟合优度<br>b. $\hat{D_i}$的期望值不是以0和1为界<br>c. 误差项既不是同方差的，也不是正态分布的</li><li>在度量虚拟被解释变量的整体拟合优度时，可以采用样本观测值被模型正确解释的百分比$\bar{R_P^2}$来代替判定系数$\bar{R^2}$</li><li>二元logit模型是一种采用累积logistic函数的变形来回避线性概率模型无界性问题的虚拟被解释变量模型估计方法。模型形式为：<br>$$L:Pr(D_i=1)=ln(\frac{P_i}{[1-P_i]})=\beta_0+\beta_1X_{1i}+\beta_2X_{2i}$$</li><li>二元logit模型最好在大样本条件下采用最大似然法估计，logit模型的斜率参数表示：在其他解释变量保持不变的情况下，特定解释变量每增加1单位对给定选择的概率的对数的影响。</li><li>二元probit模型是一种利用累计正态分布函数的变形来规避线性概率模型无界性问题的虚拟被解释变量模型估计方法。二元probit模型与二元logit模型的特征非常相似</li></ol><h3 id="例题-12">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d0eea739db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d2a28cf5db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d46bff4fdb-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d53957ccdb-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d6d954b7db-5.png" alt="5.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d843d4addb-6.png" alt="6.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_da2da811db-7.png" alt="7.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_dbb8b170db-8.png" alt="8.png"></p><h2 id="第十章-预测">第十章 预测</h2><p><strong>预测共性</strong></p><ul><li>被预测的变量的都是未知的（样本外）</li><li>仅能预测变量的期望值（随机性）</li></ul><blockquote><p>预测是对被解释样本外的观测值的期望值的估计</p></blockquote><p><strong>计量模型的预测步骤</strong></p><ol><li>搜集相关数据，建立回归模型</li><li>估计模型</li><li>将预测期解释变量的值代入模型，进行预测</li><li>评价预测效果</li></ol><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_a6827a05db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_db77c7bcdb-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_0ff4f299db-3.png" alt="3.png"></p><p><strong>时间序列模型预测</strong><br>时间序列分析：“让数据自己说话”</p><ul><li>传统计量模型以理论为基础，而社会经济现象往往受多种因素影响且这些因素存在错综复杂的联系，使得根据理论建模较为困难</li><li>依据经济变量自身的历史资料，采用一定的统计方法，建立起能反映变量自身规律性的动态模型，以此对经济变量进行分析和预测</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_fe29e0b1db-4.png" alt="4.png"></p><p>平稳性检验：<strong>单位根检验</strong></p><ul><li>存在单位根的时间序列的一阶差分为平稳序列</li><li>常用方法为DF检验，ADF检验</li><li>检验的原假设为：时间序列存在单位根</li></ul><p><strong>时间序列模型预测（平稳）</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_81013502db-5.png" alt="5.png"></p><p><strong>时间序列模型预测（非平稳）</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_c6e785e3db-6.png" alt="6.png"></p><p><strong>预测方法</strong></p><ul><li>动态预测：从预测样本的第一期开始计算<strong>多步预测</strong></li><li>静态预测：利用滞后项被解释变量的实际值计算<strong>1步</strong>预测</li></ul><blockquote><p>静态预测效果更好</p></blockquote><blockquote><p>复杂模型的预测能力不一定强于简单模型</p></blockquote><blockquote><p>预测仅仅是计量经济学的用途之一，不要过分相信计量经济学模型的预测能力！</p></blockquote><h3 id="小结-8">小结</h3><ol><li>预测就是根据样本范围外的观测值来估计被解释变量的期望值。基本方法是将想要预测的变量作为被解释变量估计一个方程，然后将各个解释变量（需预测的观察结果）的值带入方程中计算出预测值。</li><li>一个预测方程在样本范围内拟合得很好，并不能保证也可以对样本范围外得观测值进行准确的预测。</li><li>确切地知道每一个解释变量的值的预测叫做无条件预测，但如果有一个或多个解释变量的值要通过预测得到，那么这种预测叫做条件预测。条件预测所得到的Y的预测值是无偏的（只要X的预测值是无偏的），但是一定会使误差方差变大。</li><li>如果方程的参数是用广义最小二乘法估计得出的（为了修正纯1阶序列相关），那么预测方程为：<br>$$\hat{Y_{T+1}}=\hat{\rho}Y_T+\hat{\beta_0}(1-\hat{\rho})+\hat{\beta_1}({\hat{X_{T+1}}-\hat{\rho}X_T})$$<br>式中，$\rho$代表自相关系数</li><li>如果同时计算出置信区间，预测结果将会更加有意义。置信区间是指被解释变量的真实值落入该区间的次数为某固定百分比（置信水平）的某个区间。计算如下：<br>$$\hat{Y_{T+1}}\pm S_Ft_c$$<br>式中，$S_F$为预测的估计标准差，$t_c$为某置信水平下双侧检验的t的临界值</li><li>ARIMA是一种高度精炼的曲线拟合方法，能用被解释变量（仅仅是被解释变量）的过去值和现在值来精确地预测该变量短期内的值，首先通过d阶差使序列变平稳，差分后的变量其均值和方差固定不变的。ARIMA(p,d,q)表示该模型是由p阶自回归过程（含有$\theta_1 Y_{t-1}$）和q阶的平均移动过程（含有$\phi_1\varepsilon_{t-1}$）来表示d阶差分的被解释变量</li></ol><h3 id="例题-13">例题</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e068a6f7db-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e1e076a9db-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e3c3db68db-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e520f2f4db-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_e7ab0f96db-5.png" alt="5.png"></p><h2 id="第十一章-时间序列模型">第十一章 时间序列模型</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_b353f8bbdc-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_b64aa6a7dc-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_b8a666afdc-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_bb0123cfdc-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_bc69586adc-5.png" alt="5.png"></p><p><strong>有限滞后模型（FDL）模型的估计</strong><br>$$Y_t= \alpha_0+\beta_0X_t+\beta_1X_{t-1}+…+\beta_{p}X_{t-q}+\varepsilon_{t} $$<br>存在的问题</p><ul><li>X的各期滞后项之间可能存在严重的多重共线性</li><li>参数估计值未必会符合经济理论具有平滑递减的特征</li></ul><p><strong>FDL模型估计的假设</strong></p><ol><li>参数是线性的</li><li>解释变量和误差项不存在完全共线性</li><li>零条件均值 <strong>（严格外生）</strong><blockquote><p>$E(\varepsilon_{t}|X)=0$</p></blockquote></li><li>同方差性</li><li>无序列相关</li><li>正态性</li></ol><p><strong>FDL模型的特点</strong></p><ol><li>OLS的无偏性</li><li>OLS的样本方差<br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_aed943f4dc-6.png" alt="6.png"></li><li>$\sigma^2$的无偏估计<br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_07c099d6dc-7.png" alt="7.png"></li><li>高斯-马尔科夫定理<br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_0acded4edc-8.png" alt="8.png"></li><li>正态抽样分布<br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_43d2d2fadc-9.png" alt="9.png"></li></ol><p><strong>例子</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_82f01e81dc-10.png" alt="10.png"></p><p><strong>无限期分布滞后（IDL）模型</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_d4081d01dc-1.png" alt="1.png"></p><p><strong>考伊克模型的特点</strong></p><ul><li>以滞后被解释变量代替了大量被解释变量的滞后项，节省了自由度</li><li>滞后被解释变量与解释变量的相关度较低，缓解了多重共线性<br><strong>考伊克模型的问题</strong></li><li>随机干扰项存在序列相关性</li><li>滞后被解释变量与随机干扰项<strong>不独立</strong></li></ul><blockquote><p>该问题属于内生性问题，导致OLS估计量有偏</p></blockquote><ul><li><p>外生解释变量和内生解释变量</p><ul><li>解释变量X与误差项$\varepsilon$不相关，则称x为<strong>外生解释变量</strong></li><li>解释变量X与误差项$\varepsilon$相关，则称x为<strong>内生解释变量</strong></li></ul></li><li><p>解决内生性问题</p><ul><li>在回归模型中增加遗漏变量进行控制</li><li>工具变量（IV检验），代理变量</li></ul></li></ul><p>简单的回归模型：$y=\beta_0+\beta_1x+\varepsilon$<br>$$Cov(x,\varepsilon) \ne 0 or E(\varepsilon|x) \ne 0$$</p><p>为了得到参数的一致估计，需要额外的信息。假设有一个可观测变量z，它满足两个条件：</p><ol><li>z和 $\varepsilon$不相关，即$Cov(z,\varepsilon)=0$</li><li>z和x相关，即$Cov(z, \varepsilon) \ne 0$<br>则称z是x的工具变量。</li></ol><blockquote><p>普通最小二乘估计是工具二乘估计（IV检验）的特殊形式</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_f6e0164bdc-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_f9e552fbdc-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_fbaed7dddc-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_ff9e488ddc-4.png" alt="4.png"></p><blockquote><p>两组非平稳时间序列进行回归，会产生<strong>虚假的回归现象</strong></p></blockquote><h3 id="小结-9">小结</h3><ol><li>分布滞后项反应Y的当期值是X的当期值和过去值的函数，于是，将X的影响分布于滞后的若干期中。无约束分布滞后模型（特设分布滞后模型）的普通最小二乘估计会产生多重共线性问题，自由度问题和参数随时间的非连续变化问题。</li><li>动态模型通过假设滞后解释变量的参数随滞后项的加长而呈集合呈几何级数衰减回避了分布滞后模型面临的问题。给定这一假设，动态模型可以表述为：<br>$$Y_t=\alpha_0+\beta_0 X_t+\lambda Y_{t-1}+u_t$$<br>式中，$Y_{t-1}$代表滞后被解释变量且$0&lt;\lambda&lt;1$.</li><li>在小样本条件下，动态模型的普通最小二乘估计存在偏误且假设检验不可靠。即使在大样本条件下，如果误差项存在序列相关性，普通最小二乘法在估计动态模型参数时仍会产生偏误。</li><li>在动态模型中，杜宾-沃森d检验有时不能检验出序列相关性，因为d偏向于2。另一种最常用的检测方法是拉格朗日乘数检验。</li><li>Granger因果关系，也称前定关系，描述的是这样一种情形，即若某时间序列变量变动，另一个时间序列变量会发生一致的可预测的变化。即便一个变量前定（Greanger导致）另外一个变量，也不能认为第一变量的变动引起了另一个变量的变动。</li><li>非平稳序列是随时间发生显著变化（例如，均值和方差）的序列。如果被解释变量和至少一个解释变量是非平稳的，回归结果可能产生谬误相关，使得调整的判定系数$\bar{R^2}$和非平稳解释变量的t统计量偏大。</li><li>DF检验可以检验出非平稳性，如果变量是非平稳的（存在单位根），那么，就应该采用DF检验检验方程残差的平稳性，进而检验方差的协整性。如果变量存在单位根但并不协整，那么，把模型的函数形式转换为1阶差分，再估计方程。如果变量存在单位根并且是协整的，那么，以变量的原始形式估计方程。</li></ol><h2 id="第十二章-面板数据模型">第十二章 面板数据模型</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_2abc28eadc-1.png" alt="1.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_444b15a5dc-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_460a3463dc-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_4a0e3594dc-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/05/25/99310_4f0d27eedc-5.png" alt="5.png"></p><h3 id="小结-10">小结</h3><ol><li>随机分配实验被认为是证明一个实验（处理）因素与出现的结果间存在因果关系的黄金准则。随机选择的处理组暴露在实验（处理）下，对照组不受实验因素作用。我们检验组的结果是否有显著性差异。不幸的是，这种实验在经济学的许多领域都不可行。</li><li>如果一个自然发生的时间（如政策的改变）能够被看作模仿了一个随机分配实验过程，则该自然实验能够为经济学中的因果关系提供证据。如果该事件让处理组结果的均值比对照组的均值发生了更显著的变化，则我们有证据表明实验（处理）是使结果发生改变的原因。</li><li>涉及自然实验数据的方程可以用差异中的差分模型来估计，该模型比较了处理组和对照组结果改变量之间的差异。</li><li>面板数据（也称纵向数据）通过在两个或两个以上时间段采集的相同截面样本的相同变量的观测值的方法，结合了时间序列数据和截面数据。面板数据常常是由多年的大规模调查项目得来的，为计量经济学分析提供了丰富的数据资源。</li><li>涉及面板数据的方程可以用固定效应模型或者更先进的随机效应模型进行估计。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由数据范围反推算法复杂度以及算法内容</title>
      <link href="/2022/05/16/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/"/>
      <url>/2022/05/16/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>一般ACM或者笔试题的时间限制为1秒或2秒</p><p>在这种情况下，C++代码操作次数一般控制在$10^7 - 10^8$</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择</p><ol><li>$n \leq 30$, 指数级别， dfs+剪枝，状态压缩DP</li><li>$n \leq 100 \to O(n^3)$ floyed, dp, 高斯消元</li><li>$n \leq 1000 \to O(n^2), O(n^2logn)$ dp, 二分， 朴素版dijkstra，朴素版Prim，Bellman-Ford</li><li>$n \leq  10000\to O(n * \sqrt n)$ 块状链表、分块、莫队</li><li>$n \leq 100000 \to O(nlogn)$ 各种sort，线段树，树状数组，set/map，heap，拓扑排序，dijkstra+heap，prim+heap，Kruskal，spfa，求凸包，求半平面交，二分，CDQ分治，整体二分，后缀数组，树链剖分，动态树</li><li>$n \leq 1000000 \to O(n)$, 以及常数较小的$O(nlogn)$算法单调队列，hash，双指针扫描，并查集，kmp，AC自动机，常数比较小的$O(nlogn)$做法sort、树状数组、heap、dijkstra、spfa</li><li>$n \leq 10000000 \to O(n)$ 双指针扫描，kmp，AC自动机，线性筛素数</li><li>$n \leq 10^9 \to O(\sqrt n)$,判断素数</li><li>$n \leq 10^{18} \to O(logn)$,最大公约数，快速幂，数位DP</li><li>$n \leq 10^{1000} \to O((logn)^2)$ 高精度加减乘除</li><li>$n \leq 10^{100000} \to O(logk*loglogk)$  , k表示位数，高精度加减，FFT/NTT</li></ol>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing周赛</title>
      <link href="/2022/05/14/AcWing%E5%91%A8%E8%B5%9B/"/>
      <url>/2022/05/14/AcWing%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="第51场周赛">第51场周赛</h2><h3 id="上车"><a href="https://www.acwing.com/problem/content/4422/">上车</a></h3><h4 id="题意分析">题意分析</h4><p>只要每辆车差值大于等于2答案加一</p><h4 id="代码">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span> (y - x &gt;= <span class="hljs-number">2</span>) res ++ ;<br>    &#125;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="连通分量"><a href="https://www.acwing.com/problem/content/4423/">连通分量</a></h3><h4 id="题意分析-2">题意分析</h4><p>我们以障碍物为操作对象，我们发现障碍物有周围4个格子，我们可以看一下上下左右四个一共有多少连通块，我们将当前的障碍物变成空地之后，我们就可以让上下左右方向上的空地连通起来，我们本质上是求将上下左右的连通块合并完之后，新的连通块的大小</p><p>求连通块有三种方法，分别是dfs，bfs或者并查集</p><p>我们对于当前四个方向上的格子一共有几个连通块，每一个集合用根节点表示，对于空地来说，如果有abcd四个空地，我们可以求一下每一个区域的代表元素a’b’c’d’，将属于同一个区域里面的连通块去掉，将不同的连通块的大小加上1得到新的连通块的大小</p><h4 id="代码-2">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> p[N * N], s[N * N];<br><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x * m + y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)  p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; g[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n * m; i ++ ) p[i] = i, s[i] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>            <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k ++ )<br>                &#123;<br>                    <span class="hljs-type">int</span> x = i + dx[k], y = j + dy[k];<br>                    <span class="hljs-keyword">if</span> (x &lt; n &amp;&amp; x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-type">int</span> a = <span class="hljs-built_in">find</span>(<span class="hljs-built_in">get</span>(x, y)), b = <span class="hljs-built_in">find</span>(<span class="hljs-built_in">get</span>(i, j));<br>                        <span class="hljs-keyword">if</span> (a != b)<br>                        &#123;<br>                            s[b] += s[a];<br>                            p[a] = b;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>            <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-type">int</span> fathers[<span class="hljs-number">4</span>], cnt = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k ++ )<br>                &#123;<br>                    <span class="hljs-type">int</span> x = i + dx[k], y = j + dy[k];<br>                    <span class="hljs-keyword">if</span> (x &lt; n &amp;&amp; x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                    fathers[cnt ++ ] = <span class="hljs-built_in">find</span>(<span class="hljs-built_in">get</span>(x, y));<br>                &#125;<br>                <span class="hljs-type">int</span> sum = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt)<br>                &#123;<br>                    <span class="hljs-built_in">sort</span>(fathers, fathers + cnt);<br>                    cnt = <span class="hljs-built_in">unique</span>(fathers, fathers + cnt) - fathers;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; cnt; k ++ )<br>                        sum += s[fathers[k]];<br>                &#125;<br>                cout &lt;&lt; sum % <span class="hljs-number">10</span>;<br>            &#125;<br>            <br>        cout &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号"><a href="https://www.acwing.com/problem/content/4424/">信号</a></h3><h4 id="题意分析-3">题意分析</h4><p>如果第 $p$ 号房子内装有信号发射器，则所有房间编号在 $[p−r+1,p+r−1]$ 范围内的房子均可被其发出的无线信号覆盖，而其余房子则不会被其发出的无线信号覆盖。</p><p>至少开启多少个无线信号发射器，才能保证所有房子都被无线信号覆盖到,如果无解输出-1</p><p>时间复杂度只要控制在$O(n^2)$</p><p>本题采用贪心的方法来做，直觉上想如果最左边的区域可以由两个信号发射器覆盖，我们选择更靠右的方案一定是更优的，同理如果一个点可以由多个点覆盖那么一定是更靠右的效果更好</p><h4 id="代码-3">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, r;<br><span class="hljs-type">int</span> q[N], cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; r;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a;<br>        cin &gt;&gt; a;<br>        <span class="hljs-keyword">if</span> (a) q[cnt ++ ] = i;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, last = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (last &gt;= n) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (q[i] - r &gt; last)<br>        &#123;<br>            res = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j + <span class="hljs-number">1</span> &lt; cnt &amp;&amp; q[j + <span class="hljs-number">1</span>] - r &lt;= last) j ++ ;<br>        last = q[j] + r - <span class="hljs-number">1</span>;<br>        res ++ ;<br>        i = j;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (last &lt; n) res = <span class="hljs-number">-1</span>;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stata使用笔记</title>
      <link href="/2022/05/12/stata%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/12/stata%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="b站教学视频"><a href="https://space.bilibili.com/19985250/search/video?keyword=stata">b站教学视频</a></h2><h2 id="导入数据">导入数据</h2><p>use</p><h2 id="画散点图">画散点图</h2><p>scatter 纵坐标变量 横坐标变量</p><p>scatter y x1 x2 …</p><h2 id="回归分析">回归分析</h2><p>reg y x1 x2 x3 …</p><h2 id="假设检验">假设检验</h2><h3 id="正态分布">正态分布</h3><ul><li>正态分布检验指令 sktset + 变量</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_96103944d1-1.png" alt="1.png"></p><blockquote><p>Obs 样本值 Pr（skewness）是对偏度的正态分布检测值 Pr（kurtosis）是对其峰度的正态分布检验，chi（2）是对总体的正态分布检验，我们主要观看的是P值（Prob）如果P值大于0.05我们就认为其符合正态分布，否则不符合</p></blockquote><ul><li>寻找变量正态化的方法 ladder+变量</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_9ac04f1ed1-2.png" alt="2.png"></p><blockquote><p>Formula对数据的处理方法，主要看p值如果P值大于0.05我们就认为其符合正态分布，否则不符合</p></blockquote><ul><li>画出变量进行正态话处理后的图像 gladder+变量</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_9c9332acd1-3.png" alt="3.png"></p><h3 id="t检验">t检验</h3><ul><li>单一样本T检验 ttest + 变量名 = 数值</li></ul><blockquote><p>通过单一样本T检验，我们可以实现样本均值与总体均值的比较。也就是说，是用来比较一组数据的平均值和一个数值有无差异</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_9f913caad1-4.png" alt="4.png"></p><blockquote><p>Mean是平均值，std.err为标准误，std.dev是标准差 95% conf.interval是95%水平的置信区间范围 自由度为观测样本数-1 t为t值 主要看P值如果小于0.05那么这组数据的平均值与给定的数据平均值有显著性差异，如果大于0.05那么则无显著性差异</p></blockquote><ul><li>单一样本T检验修改置信水平 ttest + 变量名 = 数值，level(99)</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_a2afad70d1-5.png" alt="5.png"></p><blockquote><p>数据指标与上图一致，只是置信水平发生变化</p></blockquote><ul><li>独立样本T检验修改置信区间值 ttest 变量名=变量名，unpaired</li></ul><blockquote><p>通过独立样本T检验，我们可以实现两个独立样本的均值检验</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_a612a332d1-6.png" alt="6.png"></p><blockquote><p>其他表项与上述表项类似，主要看P值如果小于0.05那么两组数据有显著性差异，如果大于0.05那么则无显著性差异</p></blockquote><ul><li>独立样本T检验修改置信区间值 ttest 变量名=变量名，unpaired level(数值)</li></ul><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_a88d39fcd1-7.png" alt="7.png"></p><ul><li><p>独立样本T检验两样本方差不同 ttest 变量名=变量名，unpaired unequal</p></li><li><p>配对样本T检验 ttest 变量名=变量名</p></li></ul><blockquote><p>通过配对样本T检验，我们可以实现对成对数据样本均值的比较，其与独立样本T检验的区别是：两个样本来自同一总体，而且数据的顺序不能调换。</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_aadaa1d2d1-8.png" alt="8.png"></p><blockquote><p>主要看P值分析与上面一致</p></blockquote><h3 id="F检验">F检验</h3><blockquote><p>F检验又叫方差齐性检验。从两研究总体中随机抽取样本，要对这两个&gt;样本进行比较的时候，首先要判断两总体方差是否相同，即方差齐性。若两总体方差相等，则直接用t检验，若不等，可采用t’检验或变量变换或秩和检验等方法。<br>从两研究总体中随机抽取样本，要对这两个样本进行比较的时候，首先要判断两总体方差是否相同，即方差齐性。若两总体方差相等，则直接用t检验，若不等，可采用t’检验或变量变换或秩和检验等方法。其中要判断两总体方差是否相等，就可以用F检验。</p></blockquote><p>reg y x1 x2 x3 x4</p><p>test x1 x2 x4</p><p>test x2=0.3</p><p>注意除了y其他都能用test检验</p><h2 id="邹检验">邹检验</h2><h3 id="例题">例题</h3><p>建立鸡肉消费量Y对鸡肉价格PC、人均可支配收入YD的回归模型，采用1974-2002的数据估计参数(变量YEAR)，检验1993年是否存在结构变化(邹检验)，请写出相应的Stata的程序或命令(数据use CHICK6.dta)。</p><h3 id="方法1">方法1</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> CHICK6.dta<br><span class="hljs-keyword">reg</span> Y PC YD<br><span class="hljs-keyword">scalar</span> ssr = <span class="hljs-built_in">e</span>(rss)<br><span class="hljs-keyword">reg</span> Y PC YD <span class="hljs-keyword">if</span> year &lt; 1993<br><span class="hljs-keyword">scalar</span> srr1 = <span class="hljs-built_in">e</span>(rss)<br><span class="hljs-keyword">reg</span> Y PC YD <span class="hljs-keyword">if</span> year &gt;= 1993<br><span class="hljs-keyword">scalar</span> srr2 = <span class="hljs-built_in">e</span>(rss)<br><span class="hljs-keyword">gene</span> f = ((ssr - ssr1 - ssr2) / 3) / (srr1 + srr2) / (29 -  6)<br></code></pre></td></tr></table></figure><h3 id="方法2">方法2</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> CHICK6.dta<br><span class="hljs-keyword">reg</span> Y PC YD<br><span class="hljs-keyword">estat</span> sbknown,<span class="hljs-keyword">break</span>(1993)<br></code></pre></td></tr></table></figure><h2 id="循环结构举例">循环结构举例</h2><p><a href="https://blog.csdn.net/Hedy_mail/article/details/108351037">参考博客</a></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">scaler j = 1<br><span class="hljs-keyword">while</span> j &lt;= num&#123;<br>    <span class="hljs-keyword">matrix</span> pvalue[j, 1] = 2*(1-t(<span class="hljs-built_in">rowsof</span>(x)-<span class="hljs-built_in">colsof</span>(X), <span class="hljs-built_in">abs</span>(tvalue[j, 1])))<br>    <span class="hljs-keyword">scalar</span> j = j + 1 <span class="hljs-comment">// 更新时也用scalar</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="正态性JB检验：-jb6-X">正态性JB检验： jb6 X</h2><blockquote><p>需要提前安装 ssc install jb6</p></blockquote><ul><li>输出的第二个数大于0.05则可认为数据符合正态分布</li></ul><h2 id="多重共线性检验之VIF判断">多重共线性检验之VIF判断</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">estat</span> <span class="hljs-keyword">vif</span><br></code></pre></td></tr></table></figure><blockquote><p>先回归再检测，如果vif大于5认为存在严重的多重共线性</p></blockquote><h2 id="序列相关性">序列相关性</h2><h3 id="序列相关性检验">序列相关性检验</h3><blockquote><p>先回归再检验</p></blockquote><ul><li><p>DW检验:estat dwatson</p></li><li><p>(简写) estat dwa<br><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_3c9c8bdbd1-1.png" alt="1.png"></p></li><li><p>BG/LM检验 (拉格朗日乘数检验)</p><blockquote><p>DW检验有许多限制，只能用于阶序列相关性的检验，方程包含一个常数，而且方程不含滞后被解释变量，还有DW检验会随着被解释变量的个数增加，不确定区域也会扩大</p></blockquote><ul><li>estat bgo</li><li>estat bgo, lags(1/2)</li><li>estat bgo, small lags(1/2)</li><li>lags用来设置自相关系数</li><li>Prob&lt;0.05时拒绝原假设，认为存在自相关</li><li>small specifies that the p-values of the test statistics be obtained using the F or t distribution instead of the default chi-squared or normal distribution.</li></ul></li></ul><h3 id="自相关图和bg检验">自相关图和bg检验</h3><p>estat bgodfrey, lags( p ) nomiss()</p><p>以上为BG检验原始语句，lags( p )用来指定BG检验的滞后阶数p，默认为lags(1),选择项nomiss()表示进行不添加0的BG检验，默认是以0代替缺失值，即DM方法</p><p>关于如何确认滞后阶数，简单的方法是看自相关图，画图自相关图后，阴影部分时95%的置信区间，点落在95%的置信区间之外或者附近，表明显著不为0，也就是有自相关</p><h3 id="序列相关的补救之GLS方法">序列相关的补救之GLS方法</h3><blockquote><p>自动估计相关系数和阶数，两条命令代表相关系数的两种迭代方法<br>- prais Y X1 X2 X3<br>- prais Y X1 X2 X3, corc</p></blockquote><h3 id="序列相关的补救之NW方法">序列相关的补救之NW方法</h3><blockquote><p>lag(3)代表最高自相关阶数为3<br>newey Y PC PB YD, lag(3)</p></blockquote><h2 id="异方差检验">异方差检验</h2><p><a href="https://blog.csdn.net/Clytie_Lion/article/details/120510724">参考博客</a></p><h3 id="异方差的怀特检验">异方差的怀特检验</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">reg</span> VOL TOT SAT <span class="hljs-comment">// 先回归</span><br><span class="hljs-keyword">estat</span> <span class="hljs-keyword">imtest</span>, white<br></code></pre></td></tr></table></figure><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_3fab8ef2d1-2.png" alt="2.png"></p><h3 id="异方差的补救">异方差的补救</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//补救措施1 怀特调整</span><br><span class="hljs-keyword">reg</span> PCON <span class="hljs-keyword">REG</span> PRICE, robust<br><span class="hljs-comment">//补救措施2 变换方程形式(双对数)</span><br><span class="hljs-keyword">gen</span> lnPCON = <span class="hljs-built_in">ln</span>(PCON)<br><span class="hljs-keyword">gen</span> lnREG = <span class="hljs-built_in">ln</span>(<span class="hljs-keyword">REG</span>)<br><span class="hljs-keyword">gen</span> lnPRICE = <span class="hljs-built_in">ln</span>(PRICE)<br><span class="hljs-keyword">reg</span> lnPCON lnREG lnPRICE<br><span class="hljs-comment">//补救措施3 重新定义定义变量</span><br><span class="hljs-keyword">gen</span> PCON1 = PCON / POP<br><span class="hljs-keyword">gen</span> REG1 = <span class="hljs-keyword">REG</span> / POP<br><span class="hljs-keyword">reg</span> PCON1 REG1 PRICE<br></code></pre></td></tr></table></figure><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_42398d09d1-3.png" alt="3.png"></p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_4590028cd1-4.png" alt="4.png"></p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/12/99310_485e9575d1-5.png" alt="5.png"></p><h3 id="例题-2">例题</h3><p>建立图书馆藏书量VOL对师生人数TOT，学生高考成绩SAT的回归模型，请写出线性回归模型的stata命令，采用white法检验异方差命令，采用White调整异方差的命令</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">reg</span> VOL TOT SAT<br><span class="hljs-keyword">estat</span> <span class="hljs-keyword">imtest</span>, white<br><span class="hljs-keyword">reg</span> VOL TOT SAT, robust<br></code></pre></td></tr></table></figure><p>结果如下：</p><blockquote><p>这个结果用的是CHICK6.dta的数据，但意思大同小异</p></blockquote><p>怀特检验，我们主要H0是同方差假设，HA是异方差假设，看P值，如果P值&lt;0.05说明我们要拒绝原假设，即原序列有着异方差性</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/13/99310_de5e842ad2-1.png" alt="1.png"></p><p>怀特检验修正</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/13/99310_e1e7d20ad2-2.png" alt="2.png"></p><blockquote><p>画自相关图<br>ac e1</p></blockquote><h2 id="8A-SAT互动练习">8A SAT互动练习</h2><p>简单来说，本次练习就是寻找最合适的解释变量，来解释被解释变量。</p><p>首先肯定要选择GPA，APMATH以及APENG为我们的解释变量，然后AP因为APMATH以及APENG已经可以解释所以不用，然后看ESL和RACE因为样本中不是亚洲人就是白种人，如果英语不是母语，很大概率是亚洲人，并且在相关系数表中，ESL和RACE的相关系数为0.8461&gt;0.8太大了，因此ESL和RACE只用选一个就可以了，在考试中我认为ESL个具有代表性，因为如果你不是母语者那么你学习过程中肯定有一定的困难，所以采用ESL作为解释变量，而GENDER和PEPR在我看来都有充足的解释力，而且前文也提到了性别对于SAT成绩的巨大影响。</p><p>综上所述，我们先用 GPA APMATH APENG ESL GENDER PEPR进行回归分析</p><p>预测符号</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">符号</th></tr></thead><tbody><tr><td style="text-align:center">GPA</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">APMATH</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">APENG</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">ESL</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">GEND</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">PREP</td><td style="text-align:center">+</td></tr></tbody></table><p>开始回归</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/13/99310_eee6f902d2-1.png" alt="1.png"></p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/13/99310_f09be2efd2-2.png" alt="2.png"></p><p>我们首先看系数与我们的设想一不一致，然后看p值，在t检验中，p值如果&lt;0.05则说明该解释变量有显著的解释力，反之则没有。<br>我们发现PREP与我们的预期不符。表面上看，变量PREP是一个有影响力的变量，因为几乎可 以肯定PREP课程可以提高修读了该课程学生的SAT测试成绩。问题是学生修读PREP课程的 决定与他以前的（或者预期的）SAT测试成绩有关。我们相信那些感觉自己需要修读PREP课 程的学生会做出正确的判断，同时，我们认为这些课程会使他们的成绩达到与那些没有选修 PREP课程的学生的成绩不相上下。因而，该变量对SAT成绩没有显著的影响。<br>所以去除PREP</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/13/99310_f541fe6ed2-3.png" alt="3.png"></p><p>发现一个问题，其他变量p值都挺好的，但到了ESL就拉了，从感性角度出发，但是ESL有充分理由留在这里，这启发我们，数据统计出来的只是一个参考，具体问题，要结合具体的情况分析。</p><h2 id="stata命令">stata命令</h2><ul><li>导入数据<ul><li>命令行 ——use “路径”<ul><li>例：use “D:\stata\auto.dta”</li></ul></li><li>标签——文件——打开——选择文件</li></ul></li><li>计算函数<ul><li>exp()</li><li>log()</li><li>log10()</li><li>sqrt()</li><li>abs()</li></ul></li><li>数据操作<ul><li>导入数据<ul><li>命令行——use “路径”<ul><li>例：use “D:\stata\auto.dta”</li></ul></li><li>标签——文件——打开——选择文件</li></ul></li><li>删除数据行<ul><li>drop in 1/n //删除前n行</li><li>drop in n 删除n行</li><li>duplicates drop //删除重复行</li></ul></li><li>导出dta文件为excel<ul><li>save name.dta, replace \ export excel using name</li></ul></li></ul></li><li>变量操作<ul><li>新建变量<ul><li>命令行——generate 新变量名=新变量产生方法<ul><li>例: generate newprice = price + 4(price是已有变量)</li></ul></li></ul></li><li>删除变量<ul><li>命令行——clear</li></ul></li><li>变量值排序<ul><li>命令行——sort预排序变量<ul><li>默认从小到大</li><li>例:sort price</li></ul></li></ul></li><li>查看变量值分布<ul><li>命令行——tabulate 变量</li></ul></li><li>变量的分组<ul><li>命令行——generate 新变量 = autocode(旧变量，分类数，下界，上界)</li><li>举例<ul><li>generate newmpg = autocode(mpg, 3, 10, 40)</li><li>结果:新变量newmpg将只取20，30，40中的值</li></ul></li></ul></li></ul></li><li>矩阵操作<ul><li>设置系统能容纳的矩阵大小<ul><li>命令行: set matsize 数值</li></ul></li><li>创建矩阵A<ul><li>创建单位矩阵<ul><li>matrix define A = l(n) // 创建n维单位矩阵</li></ul></li></ul></li><li>手动输入值构造<ul><li>Mat A=[1,2,3\4,5,6]</li></ul></li><li>创建每个值相等的矩阵<ul><li>matrix A = J(行数，列数，每个元素的值)</li></ul></li><li>通过变量构造<ul><li>mkmat 变量1 变量2 变量3，matrix(A) //会将三个变量作为矩阵的三列</li></ul></li><li>通过矩阵构造<ul><li>matrix A = []//类似输入值构造，只不过换成了矩阵，注意行列对齐</li><li>matrix A = 矩阵运算式</li><li>matrix A = invsym(B)// B是一个可逆矩阵，A得到其逆矩阵</li><li>matrix diag = vecdiag(A)//提取A的对角元素得到列向量diag</li><li>matrix R = cholesky(A) // S = RR’，对S进行分解</li></ul></li><li>创建对角矩阵<ul><li>mat D = diag(v) // 其中v是n * 1或 1 * n矩阵</li></ul></li><li>显示矩阵A<ul><li>mat list A</li></ul></li><li>提取矩阵某行某列<ul><li>X[1…2, 3…4]得到X第1、2行和第3、4列形成的矩阵</li><li>X[1…, 3…]得到第1行到最后一行，第3列到最后一列</li></ul></li><li>矩阵运算<ul><li>取逆：invsym(A)</li><li>转置：A’</li></ul></li><li>设计矩阵列名<ul><li>matrix colnames A = 第一列名 第二列名 第三列名</li></ul></li><li>其他矩阵相关函数<ul><li>scalar m = rowsof(A)//返回矩阵A的行数给标量m</li><li>scalar n = colsof(A)//返回矩阵A的列数给标量n</li></ul></li></ul></li><li>绘图<ul><li>散点图<ul><li>Twoway scatter y x</li></ul></li><li>折线图<ul><li>Twoway line y x</li></ul></li><li>带数据点标记折线图<ul><li>twoway connected y x</li></ul></li><li>垂直线图<ul><li>twoway dropline y x</li></ul></li><li>lowess图<ul><li>twoway lowess y x</li></ul></li><li>脉冲图<ul><li>twoway spike y x</li></ul></li></ul></li><li>循环结构<ul><li>见文档</li></ul></li><li>得到data集中的所有行数<ul><li>scalar n = _N</li></ul></li><li>单词表<ul><li>Obs(objects)有效观测样本</li><li>Std.Dev(Standard deviation)标准差</li><li>Wgt(Weight)权重</li><li>Varlance方差</li><li>Skewness偏度<ul><li>用来衡量数据的不对称性</li><li>&lt;0时，概率分布左偏，有一个向左的尾</li><li><blockquote><p>0时，概率分布右偏，有一个向右的尾</p></blockquote></li><li>=0时，数据相对均匀地排布在平均值两侧</li></ul></li><li>Kurtosis峰度<ul><li>用来衡量数据的集中性</li><li>取值范围&gt;=1，峰度值越大概率分布图越高尖</li><li>完全服从正态分布的数据峰度为3</li></ul></li></ul></li><li>统计、假设检验<ul><li>查看变量的统计指标值<ul><li>命令行——summarize [变量1 变量2 …][,detail]<ul><li>后面不加变量名：输出所有变量的统计指标值</li><li>后面加变量名，变量名之间空格隔开：输出所选变量的统计指标值<ul><li>例：summarize price mpg</li></ul></li><li>后面加,detail：显示更多的统计指标值<ul><li>例：summarize price mpg,detail</li></ul></li></ul></li><li>命令行——tabstat 变量1 [变量2 …],stats(指标1 [指标2 …])</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计量经济学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>春季每日一题2022</title>
      <link href="/2022/05/09/%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982022/"/>
      <url>/2022/05/09/%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982022/</url>
      
        <content type="html"><![CDATA[<p>之前的有时间补先按照顺序做吧</p><h2 id="DAY-5-09">DAY 5-09</h2><h3 id="更多奇怪的照片"><a href="https://www.acwing.com/problem/content/3362/">更多奇怪的照片</a></h3><h3 id="题意分析-6">题意分析</h3><p>给定一个序列n，每个点只能选一次，要全部选完，然后组成偶奇交替的序列</p><p>可以记录奇数和偶数出现的次数，因为要求最大分组，用奇数+偶数=奇数 奇数+奇数=偶数来构造，每用一个在数目上减去。</p><p>可以证明按照这种处理方法如果还剩下若干个偶数，或者若干个奇数没有办法配对，那么可以把偶数加到前面的偶数组中，奇数只能剩下1个，否则的话，2个奇数能够凑成偶数，能够继续构造，因此这种方法一定有解，并且一定是最优解,如果奇数只剩下1个，那么答案要减一，因为如果只剩下1个奇数没法配对，那么当前一定是匹配偶数，前一个一定是奇数，现在剩下一个没法配对成功，那么就要把前一个分组删除，把它和最后一个奇数合并，构成一个偶数，因此答案减一，本题就做完了。</p><h3 id="代码-9">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> odd, even;<br><span class="hljs-type">int</span> n, res;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span>) odd ++ ;<br>        <span class="hljs-keyword">else</span> even ++ ;<br>    &#125;<br>    <br>    <span class="hljs-comment">//  cout &lt;&lt; odd &lt;&lt; &quot; &quot; &lt;&lt; even &lt;&lt; endl;</span><br>    <br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (even) even -- , res ++ ;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (odd &gt;= <span class="hljs-number">2</span>) odd -= <span class="hljs-number">2</span>, res ++ ;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (odd) odd -- , res ++ ;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// cout &lt;&lt; odd &lt;&lt; endl;</span><br>        i ++ ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (odd == <span class="hljs-number">1</span>) res -- ;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DAY-05-10">DAY 05-10</h2><h3 id="舒适的奶牛"><a href="https://www.acwing.com/problem/content/3374/">舒适的奶牛</a></h3><h3 id="题意分析-7">题意分析</h3><p>题目要求的是每次加入奶牛后舒服的奶牛数量，那么我们当读入一个奶牛时，我们发现它只会改变它周围四个点的性质，那么我们检查下该点和其周围的奶牛就可以了，用st[i][j]表示这个位置有没有算过答案，如果算过答案–</p><p>时间复杂度为$O(n)$</p><h3 id="代码-10">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, res;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>        <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (g[a][b]) cnt ++ ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">3</span>) st[x][y] = <span class="hljs-literal">true</span>, res ++ ;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">4</span> &amp;&amp; st[x][y]) res -- ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);<br>        g[x][y] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-built_in">check</span>(x, y);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = x + dx[j], b = y + dy[j];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= n) <span class="hljs-keyword">continue</span>;<br>           <span class="hljs-keyword">if</span> (g[a][b]) <span class="hljs-built_in">check</span>(a, b);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DAY-05-11">DAY 05-11</h2><h3 id="牛的学术圈-II"><a href="https://www.acwing.com/problem/content/3749/">牛的学术圈 II</a></h3><h3 id="题意分析-8">题意分析</h3>]]></content>
      
      
      <categories>
          
          <category> 自律 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期前集训动态规划题解</title>
      <link href="/2022/05/08/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/08/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018年提高组题解</title>
      <link href="/2022/05/08/NOIP2018%E5%B9%B4%E6%8F%90%E9%AB%98%E7%BB%84%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/08/NOIP2018%E5%B9%B4%E6%8F%90%E9%AB%98%E7%BB%84%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>跑步打卡</title>
      <link href="/2022/05/08/%E8%B7%91%E6%AD%A5%E6%89%93%E5%8D%A1/"/>
      <url>/2022/05/08/%E8%B7%91%E6%AD%A5%E6%89%93%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<h1>DAY1 2022-05-06</h1><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_cd1bfa23ce-2.jpg" alt="2.jpg"></p><h1>DAY2 2022-05-07</h1><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_d0ecd836ce-1.jpg" alt="1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 自律 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自律 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.4与课后课程笔记</title>
      <link href="/2022/05/08/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1-4%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/05/08/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1-4%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="63090d27778130e42dc621a21b59b4d00e57a5753c313f9304d4ddbf157b63f7">83bc12dacc7a0d781bd8e05336f2838b92390b858277e4757d82da37f5df1719</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成电讲坛观后感</title>
      <link href="/2022/05/08/%E6%88%90%E7%94%B5%E8%AE%B2%E5%9D%9B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>/2022/05/08/%E6%88%90%E7%94%B5%E8%AE%B2%E5%9D%9B%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h1>成电讲坛观后感</h1><p>在成电讲坛中，我开阔了我的视野，在社会各界的大咖身上获得了宝贵的知识和经验，受益终身。</p><p>杨教练为大家播放了世界顶级冲浪运动员的冲浪视频，冲浪运动的力量与美感，人类与浪花的博弈与共生令同学们沉醉。冲浪运动同滑板和滑雪有许多共同之处——最显著的地方即是三个运动都需要一块木板。冲浪运动在夏威夷真正起源，作为一项严肃的运动保有其独特的宗教意义，而古老的文化作为竞技运动和生活方式影响着现代人。接着，杨教练介绍了中国冲浪项目的起源和发展。上世纪六十年代冲浪运动传入亚洲，七十年代传入中国。中国的冲浪项目起步虽晚，但是后劲十足。2010年我国就举办了第一届国际冲浪赛；2017年中国冲浪国家队成立，国家队培训基地揭牌；21年国家管理体系建立，冲浪运动在我国的发展如火如荼。最后，杨教练介绍了国家冲浪体系。体系分为教练员体系和学员体系。</p><p>周文彰教授在社会主义的经典构想和新中国的初期探索，社会主义初级阶段和党的基本路线，中国特色社会主义一创立就成为党的旗帜，中国特色社会主义在实践中不断发展，习近平新时代中国特色社会主义思想和中国特色社会主义新时代以及做中国特色社会主义得到奋斗者六个方面生动的诠释了中国特色社会主义的发展历程，讲座高屋建瓴，从一定高度和深度对中国特色社会主义的历史脉络进行了细致的分析和讲解，我从中收益匪浅。</p><p>尧教授讲到，智力主要分为流体智力与晶体智力。流体智力主要来源于遗传，25岁左右就会逐渐降低；而晶体智力主要通过学习获得，直到65岁左右才会下降。因此“学习改变人生”也不是没有道理，同时尧教授也希望同学们“活到老，学到老”。脑智是可以调控的，尧教授也为同学们分享了几个调控脑智的方法，包括音乐、学习、药物和物理干预。随后尧教授总结道：“生物智能的核心原理是大脑可塑性，而大脑是一个复杂的系统，我们可以通过多样的、内在的、外部的、局部的、全面的综合干预来调控脑智。但这样的干预离不开科学的把控，需要建立在评估的基础上，趋利避害，辩证统一。”</p><p>“收藏其实很简单”，樊馆长从人生中第一个藏品——自己幼儿园时期的成绩单讲起，围绕收藏的张张老照片，生动地向同学们介绍了自己波折、丰富又充满趣味的人生经历，以及最终是如何走向收藏、走向博物馆建设的道路。樊馆长回顾自己的人生经历时讲到，相比于“不想当将军的兵不是好兵”而言，他更倾向“不想当副班长的兵不是好兵”。他认为人确实要有“将军”的梦想，但更要有层次的设定目标，一步一个目标才能走得更成功。</p><p>“未来10年，将是世界经济新旧动能转换的关键10年”，于施洋教授以习近平总书记的讲话为引，提出了国家建设全国一体化的国家大数据中心的伟大目标。“东数西算”，正是在数据要素参与分配的大环境下，为促进东西部算力资源优势互补和数据资源汇聚流通而提出的大工程。于施洋用详实的数据，分析了算力在国家经济发展、企业运作中的重要作用，并提出数据、算力的大爆炸促进5G时代分布式人工智能体系发展的智能大爆炸的展望。</p><p>我们跟随谢云宁校友一起探索星海处的快捷星门，人类仰望太空之时，就注定我们将不再平凡，科幻是科学的翅膀，借助于它，我们平凡人也可以挣脱地心引力，在讲座的最后，谢云宁勉励同学们可以多读些科幻作品，多看点科幻电影，像哆啦A梦一般打开科幻世界的大门。同时他也希望科幻作品可以帮助同学们开阔视野，也为我们留下一个永远的心灵的慰藉。</p><p>最后希望自己也能像讲座的大咖一样，努力学习知识，将来好好报效祖国，回馈社会。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期前集训图论题解</title>
      <link href="/2022/05/07/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E5%9B%BE%E8%AE%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/07/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E5%9B%BE%E8%AE%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>把之前写的题解上传到博客上</p><h1><a href="http://121.48.165.90/contest/170/problem/A">A题</a></h1><h2 id="题意分析-9">题意分析</h2><p>求全局最小割</p><h2 id="解题思路">解题思路</h2><p>Stoer_Wagner板题<br>Stoer_Wagner<br>每次在当前的无向图 G( V , E ) 中不断维护一个点集 A ,开始点集 A 包含一个任选的点 a . 当 A ≠ V 时选取属于V但不属于A且最大的点 v 加入点集 A ，直到 A=V 时结束。 此时令倒数第二次加入A的点为 s ，最后一次加入的点为 t ，则s-t最小割为割 ( A-{t} , {t} ) ，此时的全局最小割即为操作中的 s-t 最小割的最小值。 总的复杂度为$O((E+V)logV)$</p><h2 id="代码-11">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">550</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> edge[N][N], dist[N];<br><span class="hljs-type">bool</span> vis[N], bin[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">contract</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;s, <span class="hljs-type">int</span> &amp;t)</span>                        </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    <br>    <span class="hljs-type">int</span> i, j, k, mincut, maxc;<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        k = <span class="hljs-number">-1</span>; maxc = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<span class="hljs-keyword">if</span>(!bin[j] &amp;&amp; !vis[j] &amp;&amp; dist[j] &gt; maxc)<br>        &#123;<br>            k = j;  maxc = dist[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> mincut;<br>        s = t;  t = k;<br>                mincut = maxc;<br>        vis[k] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= n; j++)<span class="hljs-keyword">if</span>(!bin[j] &amp;&amp; !vis[j])<br>            dist[j] += edge[k][j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> mincut;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Stoer_Wagner</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> mincut, i, j, s, t, ans;<br>    <span class="hljs-keyword">for</span>(mincut = inf, i = <span class="hljs-number">1</span>; i &lt; n; i ++ )<br>    &#123;<br>        ans = <span class="hljs-built_in">contract</span>(s, t);<br>                bin[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(mincut &gt; ans)mincut = ans;<br>        <span class="hljs-keyword">if</span>(mincut == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= n; j++)<span class="hljs-keyword">if</span>(!bin[j])<br>            edge[s][j] = (edge[j][s] += edge[j][t]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mincut;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(edge, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(edge));<br>    <span class="hljs-built_in">memset</span>(bin, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(bin));<br>    <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>        <span class="hljs-keyword">while</span> (m --)<br>        &#123;<br>            <span class="hljs-type">int</span> a, b, c;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>            edge[a][b] += c, edge[b][a] += c;<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">Stoer_Wagner</span>());<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/C">C题</a></h1><p>双端队列+广度优先搜索<br>首先把电路板上每一个格子点(交叉点)看作无向图中的节点,我们认为两个节点x和y是某个小方格的两个对角,那么如果说x和y的线段’',那么我们可以认为边权为0,反之如果x和y线段是’/’,那么我们的边权视为1,说明要旋转一次才能够连上.<br>现在我们得到了一张完美的边权0或1的无向图,那么和普通广搜一样,我们唯一的改变就是,如果说当前新状态的边权为0,那么我们就放到队头先走,因为我们要满足两端性和单调性,而为了这个单调性,如果说当前新状态边权为1,那么我们就只能压入到队尾.<br>具体小细节就看代码吧.hh</p><h2 id="代码-12">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;PII&gt; q;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br><br>    <span class="hljs-type">char</span> cs[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;\\/\\/&quot;</span>;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> ix[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, iy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br>    d[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push_front</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop_front</span>();<br><br>        <span class="hljs-keyword">if</span> (t.x == n &amp;&amp; t.y == m) <span class="hljs-keyword">return</span> d[n][m];<br><br>        <span class="hljs-keyword">if</span> (st[t.x][t.y]) <span class="hljs-keyword">continue</span>;<br>        st[t.x][t.y] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = t.x + dx[i], b = t.y + dy[i];<br>            <span class="hljs-type">int</span> ca = t.x + ix[i], cb = t.y + iy[i];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt; n || b &lt; <span class="hljs-number">0</span> || b &gt; m) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-type">int</span> w = g[ca][cb] != cs[i];<br>            <span class="hljs-type">int</span> dist = d[t.x][t.y] + w;<br>            <span class="hljs-keyword">if</span> (dist &lt; d[a][b])<br>            &#123;<br>                d[a][b] = dist;<br>                <span class="hljs-keyword">if</span> (!w) q.<span class="hljs-built_in">push_front</span>(&#123;a, b&#125;);<br>                <span class="hljs-keyword">else</span> q.<span class="hljs-built_in">push_back</span>(&#123;a, b&#125;);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, g[i]);<br><br>        <span class="hljs-keyword">if</span> (n + m &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO SOLUTION\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">bfs</span>());<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/E">E题</a></h1><h2 id="题意分析-10">题意分析</h2><p>多次询问从1号节点到给定终点的简单路径上的最小点权</p><h2 id="求解思路">求解思路</h2><p>首先考虑如果图就是一棵树，显然此时路径唯一，因此只需dfs一遍即可。  然后我们可以发现，每个点到根的简单路径可能经过的点只可能是路径上点双上的点。因此我们可以考虑用tarjan算法求解点双，显然，在求完点双后，如果用点来代替点双，那么图就可以转化成树  因此我们可以离线询问，在转化后的树上直接dfs一遍即可求解。</p><h2 id="代码-13">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n, m, q, cnt;<br><span class="hljs-type">int</span> w[N * <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> dfn[N * <span class="hljs-number">2</span>], low[N], ts, stk[N], tp;<br><span class="hljs-type">int</span> idf[N * <span class="hljs-number">2</span>], f[N * <span class="hljs-number">2</span>], siz[N * <span class="hljs-number">2</span>], dep[N * <span class="hljs-number">2</span>], son[N * <span class="hljs-number">2</span>], top[N * <span class="hljs-number">2</span>], ans[N * <span class="hljs-number">2</span>];<br><span class="hljs-type">bool</span> st[N];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; G[N], T[N * <span class="hljs-number">2</span>];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    low[u] = dfn[u] = ++ ts;<br>    stk[++ tp] = u;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!dfn[v])<br>        &#123;<br>            <span class="hljs-built_in">tarjan</span>(v);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br>            <br>            <span class="hljs-keyword">if</span> (low[v] == dfn[u])<br>            &#123;<br>                cnt ++ ;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x != v; -- tp)<br>                &#123;<br>                    x = stk[tp];<br>                    T[cnt].<span class="hljs-built_in">push_back</span>(x);<br>                    T[x].<span class="hljs-built_in">push_back</span>(cnt);<br>                   <span class="hljs-comment">// printf(&quot;    BCC #%d has vertex #%d\n&quot;, cnt - n, x);</span><br>                &#125;<br>                T[u].<span class="hljs-built_in">push_back</span>(cnt);<br>                T[cnt].<span class="hljs-built_in">push_back</span>(u);<br>                <span class="hljs-comment">//printf(&quot;    BCC #%d has vertex #%d\n&quot;, cnt - n, u);</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[v]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    ans[u] = <span class="hljs-built_in">min</span>(w[u], ans[fa]);<br>    <span class="hljs-comment">// cout &lt;&lt; &quot;u:&quot; &lt;&lt; u &lt;&lt; endl;</span><br>    st[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (u &gt; n)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : T[u])<br>            ans[u] = <span class="hljs-built_in">min</span>(w[x], ans[u]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : T[u])<br>        <span class="hljs-keyword">if</span> (!st[x])<br>            <span class="hljs-built_in">dfs</span>(x, u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(w, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> w);<br>    <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> ans);<br>    <br>     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);<br>     <br>     cnt = n;<br>     <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>     &#123;<br>         <span class="hljs-type">int</span> a, b;<br>         <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>         <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span> || b &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>         a = -a, b = -b;<br>         G[a].<span class="hljs-built_in">push_back</span>(b);<br>         G[b].<span class="hljs-built_in">push_back</span>(a);<br>     &#125;<br>     <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br>     <br>     <span class="hljs-built_in">tarjan</span>(<span class="hljs-number">1</span>);<br>     <br>    <span class="hljs-comment">//  for (int i = 1; i &lt;= cnt; i ++ )</span><br>    <span class="hljs-comment">//     cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; w[i] &lt;&lt; endl;</span><br>     <br>     <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>     <br>    <span class="hljs-comment">//   for (int i = 1; i &lt;= cnt; i ++ )</span><br>    <span class="hljs-comment">//     cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; ans[i] &lt;&lt; endl;</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans[x]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/F">F题</a></h1><h2 id="题意分析-11">题意分析</h2><p>本题是一个差分约束的简单题<br>差分约束<br>形如$x_i \leq x_j + c_k$的不等式组，假设我们存在 $j \xrightarrow{c} i$ 如果求得是最短路一定存在$dist_i \leq dist_j + c$, 我们在这个图上随便找一个起点，然后求一下每个点到起点的最短距离，每一个差分约束问题都等价于一个单源最短路问题，<br>差分约束：<br>步骤：<br>[1]首先将每个不等式$x_i \leq x_j + c_k$, 转换成一条从$x_j$走到$x_i$，长度为$c_k$的一条边<br>[2]找到一个超级源点，使得该源点一定可以遍历到所有边<br>[3]从源点求一遍单源最短路,注意如果在图中存在负环，说明方程矛盾,也就是不等式无解，等价于图中有负环<br>有负环，则方程无解，无负环则$dist_i$是方程组的一个解<br>如果是最长路,原方程$x_i \leq x_j + c_k$不等号方向改变变为$x_j \geq x_i - c_k$，$i \xrightarrow{-c} j$ 正环表示无解.</p><ol><li>可以求不等式组的可行解 源点需要满足的条件：从源点出发，一定可以走到所有的边</li><li>如何求最大值或者最小值<br>结论1：如果求的是最小值，则应该求最长路，如果求的是最大值，则应该求最短路。<br>求最值的时候一定会告诉我们一个绝对值<br>问题1：如何转化 $x_i \leq c$,其中c是一个常数，这类不等式<br>方法：建立一个超级源点，0，然后建立$0\xrightarrow{c} i$的边即可<br>以求$x_i$的最大值为例，所有从$x_i$出发构成的不等式链$x_i\leq x_j+c_1\leq x_k+c_1+c_2… \leq x_0(c_0)+c_1+c_2 … $所计算出的上界，最终$x_i$的最大值应该等于所有上界的最小值。我们可以发现每一条这样的不等式就是从$0 \to i$走过的最短路径</li></ol><h2 id="解题思路-2">解题思路</h2><p>构造不等式<br>$a_u\leq a_v+w$也就是形成$v\xRightarrow{w} u$边<br>$a_i\leq a_0(0)+w$<br>有前面的分析知，采用最短路，如果存在负环，则说明无解。</p><h2 id="代码-14">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e3</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">1e4</span> +<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx;<br><span class="hljs-type">int</span> dist[N], cnt[N], q[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">1</span>;<br>    dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (hh != tt)<br>    &#123;<br>        <span class="hljs-type">int</span> t = q[ -- tt];<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                    q[tt ++ ] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;b, &amp;a, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, i, <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">spfa</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/I">I题</a></h1><h2 id="题意分析-12">题意分析</h2><p>本题是2-SAT算法的板题<br>2-SAT算法思想<br>一般的SAT算法为NP完全问题，但是对于2-SAT算法有比较好的解决方法。<br>我们采用图论的方法解决2-SAT问题，我们用$x_i$表示$x_i=1$ 用$\neg x_i$表示$x_i=0$<br>我们可以发现$a\to b \Leftrightarrow \neg a∪$b<br>所以我们可以将所有的条件表示为$ a∪b \Leftrightarrow \neg a\to b $我们将这些所有的推导关系，对应到我们图论中的边<br>对于每个命题，他会对应两个点我们会建立$x 和 \neg x$</p><p>因此我们可以建立一个有向图，有向图里面的一个路径就代表我们的一个传递关系<br>下面我们讨论下何时无解，我们如果说从一个取值开始，如果$x_1\to … \to \neg x_1$ 并且$\neg x_1\to … \to x_1$,存在矛盾，此时一定无解。即如果$x_i与 \neg x_i$在同一个强连通分量中，则代表无解。<br>若任何一个上述条件不成立，是否一定有解，首先我们先来看一下如何判断第一个条件，我们可以用tarjan算法来做，然后看第二个问题，答案是一定有解，构造解的方式如下，我们可以枚举所有$x_i \neg x_i$,我们缩完点后，按照拓扑排序，我们直接看一下$x_i与 \neg x_i$在tarjan中的编号，谁更靠后，我们取哪个条件，这样的话就可以给出来一组解。</p><p>下面我们来证明一下这个构造方式的正确性</p><ol><li>我们给出的解每一个$x_i$只有一种值</li><li>对于每一个连通分量来说，如果我们选择了这个分量中的某个点，那必须选择该分量中的所有条件，如果我们选择了一个块，那么一定存在一个块与它里面的条件完全相反，因为$a\to b \Leftrightarrow \neg b \to \neg a$,原命题和逆否命题等价，我们不妨设一个块更靠后</li><li>a∪b一定成立，假设$\neg a $<br>意味着$\neg a$在后面一定取到b<br>所以一定满足</li></ol><h2 id="代码-15">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dfn[N], low[N], ts, stk[N], top;<br><span class="hljs-type">int</span> id[N], cnt;<br><span class="hljs-type">bool</span> ins[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    dfn[u] = low[u] = ++ ts;<br>    stk[ ++ top] = u, ins[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dfn[j])<br>        &#123;<br>            <span class="hljs-built_in">tarjan</span>(j);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ins[j])<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[j]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (low[u] == dfn[u])<br>    &#123;<br>        cnt ++ ;<br>        <span class="hljs-type">int</span> y;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            y = stk[top -- ], id[y] = cnt, ins[y] = <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">while</span> (y != u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> i, j, a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;i, &amp;a, &amp;j, &amp;b);<br>        i -- , j -- ;<br>        <span class="hljs-built_in">add</span>(i * <span class="hljs-number">2</span> + !a, j * <span class="hljs-number">2</span> + b);<br>        <span class="hljs-built_in">add</span>(j * <span class="hljs-number">2</span> + !b, i * <span class="hljs-number">2</span> + a);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i ++ )<br>        <span class="hljs-keyword">if</span> (!dfn[i])<br>            <span class="hljs-built_in">tarjan</span>(i);<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">if</span> (id[i * <span class="hljs-number">2</span>] == id[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>])<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/J">J题</a></h1><h2 id="题意分析-13">题意分析</h2><p>tarjan板题<br>tarjan思想<br>Tarjan 算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。</p><ul><li>定义:<br>o DFN(u)为节点u 搜索的次序编号(时间戳);<br>o LOW(u)为u 或 u的子树能够追溯到的最早的栈中节点的次序号;<br>由定义可以得出，当 DFN(u)=LOW(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</li><li>算法：</li></ul><ol><li>当首次搜索到点u时DFN[u]=LOW[u]=time;</li><li>每当搜索到一个点，把该点压入栈顶;</li><li>当u和v有边相连时:<br>1）如果v不在栈中（树枝边），DFS(v)，并且LOW[u] = min{LOW(u),LOW(v)};<br>2）如果v在栈中（前向边/后向边），此时LOW[u] = min{LOW[u],DFN[v]}</li><li>当DFN[u]=LOW[u]时，将它以及在它之上的元素弹出栈，此时，弹出栈的结点构成一个强连通分量;</li><li>继续搜索，知道图被遍历完毕。<br>由于在这个过程中每个点只被访问一次，每条边也只被访问一次，所以Tarjan算法的时间复杂度是O(n+m).<br>2.2. 算法伪代码</li></ol><h2 id="本题具体步骤">本题具体步骤</h2><ol><li>建图。</li><li>dfs过程中按dfs序（时间戳）更新dfn数组，同时初始的low数组为dfn.</li><li>当前dfs对象为a，枚举与a相连的点b。   如果b已经搜索过则更新low[a]为low[a]和dfn[b]里面的小值。   如果b未搜索过，则搜索b,然后更新low[a]为low[a]和low[b]里面的小值。同时判断当前点是否为割点（low[b]&gt;=dfn[a]），当前边是否为桥（low[b]&gt;dfn[a]）。</li><li>维护一个栈，当扫描到割点时将栈中点弹出至b，并将这些点加入答案（割点不出栈但是统计至答案中）。</li><li>则极大点双连通分量数量可由4统计出。</li><li>极大点双连通分量包含边数的最大值则由每个极大点双统计。对于每个分量，枚举其中的点如果两点间有一条边则边数加1。 （注意，如果根节点只有一个儿子则不为割点）</li></ol><h2 id="代码-16">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, M = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> dfn[N], low[N], timestamp, stk[N], top;<br><span class="hljs-type">bool</span> cut[N], is_bridge[M];<br><span class="hljs-type">int</span> dcc_cnt, bridge_cnt, cut_cnt;<br>vector&lt;<span class="hljs-type">int</span>&gt; dcc[N];<br><span class="hljs-type">int</span> root;<br><span class="hljs-type">int</span> g[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> from)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> son = <span class="hljs-number">0</span>;<br>    low[u] = dfn[u] = ++ timestamp;<br>    stk[ ++ top] = u;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (i == (from ^ <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!dfn[j])<br>        &#123;<br>            son ++ ;<br>            <span class="hljs-built_in">tarjan</span>(j, i);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>            <span class="hljs-keyword">if</span> (low[j] &gt; dfn[u]) is_bridge[i] = <span class="hljs-literal">true</span>, is_bridge[i ^ <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (low[j] &gt;= dfn[u])<br>            &#123;<br>                dcc_cnt ++ ;<br>                <span class="hljs-type">int</span> y;<br>                <span class="hljs-keyword">do</span><br>                &#123;<br>                    y = stk[top -- ];<br>                    dcc[dcc_cnt].<span class="hljs-built_in">push_back</span>(y);<br>                &#125;<span class="hljs-keyword">while</span> (y != j);<br>                dcc[dcc_cnt].<span class="hljs-built_in">push_back</span>(u);<br>                <br>                <span class="hljs-keyword">if</span> ((u == root &amp;&amp; son &gt; <span class="hljs-number">1</span>) || (u != root &amp;&amp; low[j] &gt;= low[u]))<br>                    cut[u] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != e[from])<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>        g[a][b] ++ ; g[b][a] ++ ;<br>    &#125;<br><br><br>    <span class="hljs-keyword">for</span> (root = <span class="hljs-number">1</span>; root &lt;= n; root ++ )<br>        <span class="hljs-keyword">if</span> (!dfn[root])<br>            <span class="hljs-built_in">tarjan</span>(root, <span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-built_in">memset</span>(dfn, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dfn);<br>    timestamp = top = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (cut[i])<br>            cut_cnt ++ ;<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i = i + <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span> (is_bridge[i])<br>            bridge_cnt ++ ;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= dcc_cnt; k ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dcc[k].<span class="hljs-built_in">size</span>(); i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; dcc[k].<span class="hljs-built_in">size</span>(); j ++ )<br>                cnt += g[dcc[k][i]][dcc[k][j]];<br>        <br>            res = <span class="hljs-built_in">max</span>(res, cnt);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>, cut_cnt, bridge_cnt, dcc_cnt, res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/K">K题</a></h1><h2 id="题意分析-14">题意分析</h2><p>题意分析给定n个点，n-1条边，m个询问，询问两个节点之间的距离。</p><h2 id="注意事项">注意事项</h2><ul><li>无向图</li></ul><h2 id="解题思路-3">解题思路</h2><p>因为任意两个节点相互连通，而且有n-1条边，所有该图是一个树，我们将1号点看为根节点，然后求最近公共祖先，答案res = depth[a] + depth[b] - 2 * depth[p]，其中p为最近公共祖先<br>最近公共祖先<br>在一个有根树书里面，每个节点会有好几个祖先，为了一般化，我们把这个节点自己也是自己的祖先<br>向上标记法$O(n)$<br>我们先从一个点开始往上走走到根节点，标记自己走过的点，然后另一个点开始向上走，直到第一个碰到被标记的点，该点即为最近公共祖先<br>倍增法 预处理$O(nlogn)$ 查询O(logn)<br>预处理fa[i,j]，从i开始，向上走$2^j$步所能走到的节点 $0\leq j \leq logn$,可以采用递推的方式来做<br>首先当j=0，f(i,j)=i的父节点<br>当j&gt;0时，先跳$2^{j-1}$步，然后再跳先跳$2^{j-1}$步<br>即f(i,j)=f(f(i, j-1),j -1)<br>depth[i]表示深度，我们可以规定根节点的深度为1，下一层为2，深度为到根节点的距离加一<br>哨兵:如果从i开始跳$2^j$步会跳过根节点，那么fa[i,j]=0,depth[0]=0<br>求最近公共祖先的分两步：<br>[1]先将两个点跳到同一层,基于类似二进制拼凑的方式，假设x比y要深，他们差depth[x]-depth[y],只要我跳$2^k$步能跳到y前面，我就跳，否则就不跳<br>[2]让两个点同时往上跳，一直跳到它们的最近公共祖先的下一层<br>预处理$O(nlogn)$ 查询O(logn)</p><h2 id="代码-17">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2</span> * N;<br><br><span class="hljs-type">int</span> n, m, root = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> depth[N], fa[N][<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(depth, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> depth);<br>    depth[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, depth[root] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = root;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-type">int</span> t = q[hh ++ ];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (depth[j] &gt; depth[t] + <span class="hljs-number">1</span>)<br>            &#123;<br>                depth[j] = depth[t] + <span class="hljs-number">1</span>;<br>                q[ ++ tt] = j;<br>                fa[j][<span class="hljs-number">0</span>] = t;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">19</span>; k ++ )<br>                    fa[j][k] = fa[fa[j][k - <span class="hljs-number">1</span>]][k - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (depth[a] &lt; depth[b]) <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">19</span>; k &gt;= <span class="hljs-number">0</span>; k -- )<br>        <span class="hljs-keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])<br>            a = fa[a][k];<br>            <br>    <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span> a;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">19</span>; k &gt;= <span class="hljs-number">0</span>; k -- )<br>        <span class="hljs-keyword">if</span> (fa[a][k] != fa[b][k])<br>        &#123;<br>            a = fa[a][k];<br>            b = fa[b][k];<br>        &#125;<br>        <br>    <span class="hljs-keyword">return</span> fa[a][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n- <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br>    <br>    <span class="hljs-built_in">bfs</span>();<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">lca</span>(a, b);<br>        <span class="hljs-type">int</span> res = depth[a] + depth[b] - <span class="hljs-number">2</span> * depth[p];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/L">L题</a></h1><h2 id="题意分析-15">题意分析</h2><p>比较裸露，求最小生成树计数</p><h2 id="解题思路-4">解题思路</h2><p>我们发现对于所有最小生成树，每种边权的边数是一样的。<br>那就可以首先找到最小生成树，然后枚举每种边权w，把其它边权，在生成树里的边加上，然后求有几种方案选出边权为w的边，把他们加上，使得得到了一棵树。<br>然后乘起来。<br>那么这个方案数就可以用Matrix-Tree定理计算。<br>矩阵求行列式，基本方法就是高斯消元。</p><h2 id="代码-18">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXM = <span class="hljs-number">1005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">10000</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P1 = <span class="hljs-number">1000000007</span>;<br><span class="hljs-function">ll <span class="hljs-title">pwr</span><span class="hljs-params">(ll x, ll y)</span></span>&#123;<br>        x %= P1;<br>        y = (y % (P1 - <span class="hljs-number">1</span>) + (P1 - <span class="hljs-number">1</span>)) % (P1 - <span class="hljs-number">1</span>);<br>        ll ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (y)&#123;<br>                <span class="hljs-keyword">if</span> (y &amp; <span class="hljs-number">1</span>) ans = ans * x % P1;<br>                x = x * x % P1;<br>                y &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>&#125; e[MAXM];<br><span class="hljs-type">int</span> p[MAXN];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fdrt</span><span class="hljs-params">(<span class="hljs-type">int</span> nw)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (p[nw] == nw) <span class="hljs-keyword">return</span> nw;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p[nw] = <span class="hljs-built_in">fdrt</span>(p[nw]);<br>&#125;<br><span class="hljs-type">int</span> a[MAXM * <span class="hljs-number">2</span>], asz;<br><span class="hljs-type">int</span> b[MAXN][MAXN];<br><span class="hljs-type">int</span> pos[MAXN];<br><span class="hljs-function">ll <span class="hljs-title">getdet</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span></span>&#123;<br>        ll ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= len; j++)&#123;<br>                        <span class="hljs-keyword">if</span> (b[j][i])&#123;<br>                                <span class="hljs-built_in">swap</span>(b[i], b[j]);<br>                                ans = -ans;<br>                                <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= len; j++)&#123;<br>                        <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">continue</span>;<br>                        ll d = <span class="hljs-built_in">pwr</span>(b[i][i], <span class="hljs-number">-1</span>) * b[j][i] % P1;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= len; k++) b[j][k] = (b[j][k] - b[i][k] * d) % P1;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) ans = ans * b[i][i] % P1;<br>        <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;<br>        <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + m + <span class="hljs-number">1</span>, [&amp;](Edge u, Edge v)&#123;<br>                <span class="hljs-keyword">return</span> u.w &lt; v.w;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] = i;<br>        ll ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>                asz = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= m &amp;&amp; e[j].w == e[i].w; j++)&#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fdrt</span>(e[j].u) == <span class="hljs-built_in">fdrt</span>(e[j].v)) <span class="hljs-keyword">continue</span>;<br>                        a[++asz] = <span class="hljs-built_in">fdrt</span>(e[j].u);<br>                        a[++asz] = <span class="hljs-built_in">fdrt</span>(e[j].v);<br>                &#125;<br>                <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + asz + <span class="hljs-number">1</span>);<br>                asz = <span class="hljs-built_in">unique</span>(a + <span class="hljs-number">1</span>, a + asz + <span class="hljs-number">1</span>) - a - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= asz; u++)&#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= asz; v++)&#123;<br>                                b[u][v] = <span class="hljs-number">0</span>;<br>                        &#125;<br>                &#125;<br>                <span class="hljs-comment">// cout &lt;&lt; &quot;asz &quot; &lt;&lt; asz &lt;&lt; &#x27;\n&#x27;;</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= m &amp;&amp; e[j].w == e[i].w; j++)&#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fdrt</span>(e[j].u) == <span class="hljs-built_in">fdrt</span>(e[j].v)) <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-type">int</span> u1 = <span class="hljs-built_in">lower_bound</span>(a + <span class="hljs-number">1</span>, a + asz + <span class="hljs-number">1</span>, <span class="hljs-built_in">fdrt</span>(e[j].u)) - a;<br>                        <span class="hljs-type">int</span> v1 = <span class="hljs-built_in">lower_bound</span>(a + <span class="hljs-number">1</span>, a + asz + <span class="hljs-number">1</span>, <span class="hljs-built_in">fdrt</span>(e[j].v)) - a;<br>                        <span class="hljs-built_in">assert</span>(u1 != v1);<br>                        b[u1][u1]++;<br>                        b[v1][v1]++;<br>                        b[u1][v1]--;<br>                        b[v1][u1]--;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= m &amp;&amp; e[j].w == e[i].w; j++)&#123;<br>                        p[<span class="hljs-built_in">fdrt</span>(e[j].u)] = <span class="hljs-built_in">fdrt</span>(e[j].v);<br>                        i = j;<br>                &#125;<br>                <span class="hljs-type">int</span> lst = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= asz; j++)&#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fdrt</span>(a[j]) != a[j]) <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-keyword">if</span> (lst != <span class="hljs-number">-1</span>)&#123;<br>                                b[lst][lst]++;<br>                                b[j][j]++;<br>                                b[lst][j]--;<br>                                b[j][lst]--;<br>                        &#125;<br>                        lst = j;<br>                &#125;<br><br>                ll nm = (<span class="hljs-built_in">getdet</span>(asz - <span class="hljs-number">1</span>) % P1 + P1) % P1;<br>                ans = ans * nm % P;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fdrt</span>(i) != <span class="hljs-built_in">fdrt</span>(<span class="hljs-number">1</span>)) ans = <span class="hljs-number">0</span>;<br>        cout &lt;&lt; (ans % P + P) % P &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/N">N题</a></h1><h2 id="题意分析-16">题意分析</h2><p>最小直径生成树<br>最小直径生成树<br>求解直径最小生成树，首先需要找到图的绝对中心，图的绝对中心可以存在于一条边上或某个结点上，该中心到所有点的最短距离的最大值最小。 到绝对中心距离最远的结点至少有两个。 令d(i,j)为(i,j)的最短路径长，跑个floyd。 图的绝对中心可能在某条边上，枚举每一条边w=(u,v)，假设图的绝对中心就在这条边上。那么距离 u 的长度为 x ，距离 v 的长度就是 w-x。 对于图中的任意一点 i ，图的绝对中心 c 到 i 的距离为 d(c,i)=min{ d(u,i)+x ,  d(v,i)+(w−x) }<br>随着图的绝对中心 c 在边上的改变会生成一个距离与 c 位置的函数图像。d(c,i)的函数图像是一个两条斜率相同的线段构成的折线段。<br>对于图上的任意一结点，图的绝对中心到最远距离结点的函数就写作  f=max{ d(c,i)}, i∈[1,n] 函数图像如下 并且这些折线交点中的最低点，横坐标就是图的绝对中心的位置。<br>记录 rk(i,j) 表示 i 到其他所有结点中第 j 小的那个结点。 对每条边分别处理 折线中的拐点最多有 n 个 把点按照 d(v,i) 从大到小依次枚举 记录 p 表示已经枚举的点中d(u,i)最大的 接下来枚举能产生新拐点当且仅当  d(u,i)&gt;d(u,p)  （因为已经按d(v,i)排过序了） 每个拐点都更新一次答案就好 总时间O(n^3)</p><h2 id="代码-19">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> LL INF = <span class="hljs-number">1e16</span>;<br><br><span class="hljs-type">int</span> n, m;<br>LL d[N][N], val[N], rk[N][N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    LL w;<br>&#125;edges[M];<br>LL res = INF;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> val[a] &lt; val[b];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">floyd</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) <br>    &#123;<br>      rk[i][j] = j;<br>      val[j] = d[i][j];<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(rk[i] + <span class="hljs-number">1</span>, rk[i] + <span class="hljs-number">1</span> + n, cmp);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res = <span class="hljs-built_in">min</span>(res, d[i][rk[i][n]] * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <br>  &#123;<br>    <span class="hljs-type">int</span> u = edges[i].a, v = edges[i].b;<br>    LL w = edges[i].w;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = n, i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i -- ) <br>    &#123;<br>      <span class="hljs-keyword">if</span> (d[v][rk[u][i]] &gt; d[v][rk[u][p]]) <br>      &#123;<br>        res = <span class="hljs-built_in">min</span>(res, d[u][rk[u][i]] + d[v][rk[u][p]] + w);<br>        p = i;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i != j) d[i][j] = INF;<br>            <span class="hljs-keyword">else</span> d[i][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        LL c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        edges[i] = &#123;a, b, c&#125;;<br>        d[a][b] = d[b][a] = c;<br>    &#125;<br>    <br>    <span class="hljs-built_in">solve</span>();<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/O">O题</a></h1><h2 id="题意分析-17">题意分析</h2><p>求起点到其他所有点的最短路</p><h2 id="注意事项-2">注意事项</h2><ul><li>非负权值，有向道路</li></ul><h2 id="解题思路-5">解题思路</h2><p>dijkstra算法板子题，采用堆优化方法$O(nlogm)$</p><h2 id="代码-20">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">typedef</span> pair&lt;LL, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> LL INF = <span class="hljs-number">1e17</span>;<br><br><span class="hljs-type">int</span> n, m, S;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br>LL w[M];<br>LL dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, LL c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) dist[i] = INF;<br>    dist[S] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, S&#125;);<br>    <br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        PII t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-type">int</span> ver = t.y;<br>        <br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; ~i; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i])<br>            &#123;<br>                dist[j] = dist[ver] + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S);<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        LL c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dijkstra</span>();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (dist[i] == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, dist[i]);<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/Q">Q题</a></h1><h2 id="题意分析-18">题意分析</h2><p>有n个点排成一行，在第i,j 个点之间连边的代价为 |i-j| × D+Ai+Aj.求将它们连成一棵树的最小代价。<br>解题思路<br>如果这题的n&lt;=5000，那么我们就可以直接连边，然后跑一遍Prim算法便可获得答案。<br>先引入一个经典的性质：MST不可能包含一个环上的严格最大边。<br>考虑将所有点对半折开，左半部分和右半部分的建边分治处理，只考虑横跨两部分的建边。 若左半部分的点为j，右半部分的点为i。边权就可以转换成：（Ai + i × D) + (Aj - j × D)<br>既然 i 和 j 独立出来，那么只需要选出右半部分 min{Ai + i × D}所对应的i，选出左边半部分min{Aj  - j × D}所对应的j。 将 j与右半部分所有点连边，i同理。 那么这样就只有O(nlogn) 条边，然后用跑一遍最小生成树定理即可。</p><h2 id="代码-21">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">4e6</span> + <span class="hljs-number">10</span>, N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> LL INF = <span class="hljs-number">1e17</span>;<br><br><span class="hljs-type">int</span> n, m, cnt;<br>LL lmin[N], rmin[N], D;<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    LL w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge</span>(l, mid); <span class="hljs-built_in">merge</span>(mid + <span class="hljs-number">1</span>, r);<br>    <br>    LL Lmin = INF, Rmin = INF;<br>    <span class="hljs-type">int</span> lid, rid;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= mid; i ++ )<br>        <span class="hljs-keyword">if</span> (Lmin &gt; lmin[i])<br>            Lmin = lmin[i], lid = i;<br>            <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= r; i ++ )<br>        <span class="hljs-keyword">if</span> (Rmin &gt; rmin[i])<br>            Rmin = rmin[i], rid = i;<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= mid; i ++ )<br>        edges[cnt ++ ] = &#123;rid, i, Rmin + lmin[i]&#125;;<br>        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= r; i ++ )<br>        edges[cnt ++ ] = &#123;lid, i, Lmin + rmin[i]&#125;;<br>        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x != p[x]) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lld&quot;</span>, &amp;n, &amp;D);<br>   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        LL a;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a);<br>        lmin[i] = (LL)a - i * D;<br>        rmin[i] = (LL)a + i * D;<br>    &#125;<br>    <br>    <span class="hljs-built_in">merge</span>(<span class="hljs-number">1</span>, n);<br>    <span class="hljs-built_in">sort</span>(edges, edges + cnt);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b;<br>        LL w = edges[i].w;<br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (a != b)<br>        &#123;<br>            res += w;<br>            p[a] = b;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/R">R题</a></h1><h2 id="最小有向树形图">最小有向树形图</h2><p>1 无环<br>2 每个点入度为1<br>朱刘算法<br>1 贪心的从每个点的所有入边中找一条权值最小的边<br>2 从选出的边中判断是否存在环<br>2.1 不存在环，结束，把所有边权值加上作为答案<br>2.2 存在环，进入第3步<br>3 将所有环缩点，构造新图G’，缩点前把所有边权值加上<br>3.1 环内的边 2-&gt;3 3-&gt;4 4-&gt;2<br>删去<br>3.2 终点在环内的边 1-&gt;4 1-&gt;2<br>权值 w’ = w - 终点入边权值<br>w[1-&gt;4]’ = w[1-&gt;4] - w[3-&gt;4] = 5 - 1 = 4<br>w[1-&gt;2]’ = w[1-&gt;2] - w[4-&gt;2] = 4 - 2 = 2<br>3.3 其他边 4-&gt;5<br>不变<br>每次缩一次点,点数最少-1,所以总共最多迭代n次算法结束。</p><h2 id="证明：">证明：</h2><p>首先有性质：<br>1 环中的边一定至少要去掉一条边<br>2 ⭐ 一定存在一个最优解，只去一条边<br>假设去了两条环内边，则说明环内有两个点的入边权值变大<br>3 缩点前和缩点后的树形图的最小权值相等–则要求G的最小权和==G’的最小权和<br>任给G中的一个树形图一定能找到一种变换变换到对应的G’<br>任给G’中的一个树形图一定能找到对应的G</p><h2 id="代码-22">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">101</span>, M = <span class="hljs-number">10001</span>, INF = <span class="hljs-number">0x7fffffff</span>;<br><br><span class="hljs-type">int</span> n, m, s, u[M], v[M], w[M], id[N], pre[N], minw[N], src, idx;<br><span class="hljs-type">int</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">zhuliu</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    w[<span class="hljs-number">0</span>] = INF;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(pre));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>            <span class="hljs-keyword">if</span>(u[i] != v[i] &amp;&amp; (!pre[v[i]] || minw[v[i]] &gt; w[i]))<br>            &#123;<br>                pre[v[i]] = u[i];<br>                minw[v[i]] = w[i];<br>            &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">if</span>(i != s &amp;&amp; !pre[i])<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(id, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(id));<br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>        vis[s] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">if</span>(i != s)&#123;<br>                ret += minw[i];<br>                <span class="hljs-type">int</span> j = i;<br>                <span class="hljs-keyword">while</span>(!vis[j])&#123;<br>                    vis[j] = i;<br>                    j = pre[j];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j != s &amp;&amp; vis[j] == i)&#123;<br>                    id[j] = ++idx;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = pre[j]; k != j; k = pre[k])<br>                        id[k] = idx;<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">if</span>(idx == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">if</span>(!id[i])<br>                id[i] = ++idx;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (id[u[i]] != id[v[i]])<br>                w[i] -= minw[v[i]];<br>            u[i] = id[u[i]], v[i] = id[v[i]];<br>        &#125;<br>        s = id[s];<br>        n = idx;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;u[i], &amp;v[i], &amp;w[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-built_in">zhuliu</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/S">S题</a></h1><h2 id="题意分析-19">题意分析</h2><p>一般图最大匹配<br>带花树流程<br>我们给所有点黑白染色。假设开始增广的点是黑点。 把所有黑点压进队列中顺次处理。对于一个黑点u，找与他相邻的点v，会出现一下几种情况： 1、u,v已经被缩成一个点了（这两个点在一朵花里），不管他。 2、v是白点，说明已经被匹配了，也不管。 3、v还没有被染色。那就先把这个点染成白的，然后尝试去与他匹配。如果v还没有匹配就匹配上，增广成功，然后一路跳回取反。如果v已经被匹配了，那么匹配他的点就是个黑点，染色，然后压进队列。 4、v也是黑点。这时候染色发生了冲突，说明遇见了奇环。这时候就需要找到两个点的lca，然后把这整个环缩成一个点。美其名曰，开花。</p><ol><li>找x和y的LCA（的根）p。找LCA可以用各种方法 直接朴素也行。</li><li>在pre数组中把x和y接起来（表示它们形成环了！）</li><li>从x、y分别走到p，修改并查集使得它们都变成一家人，同时沿路把pre数组接起来</li></ol><h2 id="代码-23">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> e[N][N];<br><span class="hljs-type">int</span> p[N], pre[N], match[N], col[N];<br><span class="hljs-type">int</span> cnt, st[N];<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) <span class="hljs-keyword">return</span> p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aug</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-keyword">while</span> (v) <span class="hljs-comment">// 修改增广路</span><br>    &#123;<br>        t = match[pre[v]];<br>        match[v] = pre[v];<br>        match[pre[v]] = v;<br>        v = t;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    cnt ++ ;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">while</span> (st[u] != cnt)<br>    &#123;<br>        st[u] = cnt;<br>        u = <span class="hljs-built_in">find</span>(pre[match[u]]);<br>        <span class="hljs-keyword">if</span> (v) <span class="hljs-built_in">swap</span>(u, v);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shrink</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">find</span>(u) != r)<br>    &#123;<br>        pre[u] = v;<br>        v = match[u];<br>        <span class="hljs-keyword">if</span> (col[v] == <span class="hljs-number">2</span>)<br>        &#123;<br>            col[v] = <span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">push</span>(v);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(u) == u) p[u] = r;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(v) == v) p[v] = r;<br>        u = pre[v];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(col, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> col);<br>    <span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> pre);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br>    <br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) q.<span class="hljs-built_in">pop</span>();<br>    col[s] = <span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(s);<br>    <br>    <span class="hljs-type">int</span> u;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v ++ ) <span class="hljs-keyword">if</span> (e[u][v])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!col[v])<br>            &#123;<br>                pre[v] = u;<br>                <span class="hljs-keyword">if</span> (!match[v]) &#123;<span class="hljs-built_in">aug</span>(v);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>                <span class="hljs-keyword">else</span>&#123;col[v] = <span class="hljs-number">2</span>;col[match[v]] = <span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(match[v]);&#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(u) == <span class="hljs-built_in">find</span>(v)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (col[v] == <span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-type">int</span> r = <span class="hljs-built_in">lca</span>(u, v);<br>                    <span class="hljs-built_in">shrink</span>(u, v, r);<br>                    <span class="hljs-built_in">shrink</span>(v, u, r);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        e[a][b] = e[b][a] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (!match[i] &amp;&amp; <span class="hljs-built_in">bfs</span>(i))<br>            res ++ ;<br>            <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="http://121.48.165.90/contest/170/problem/T">T题</a></h1><h2 id="题意分析-20">题意分析</h2><p>给一张有向图，问从图中最少需要选出多少条互不相交的简单路径（不走重点的一条有向链），才能让图中的所有点都被这些路径经过一次？</p><h2 id="解题思路-6">解题思路</h2><p>将本题转换成求二分图的最小路径覆盖<br>最小路径覆盖<br>最小路径覆盖<br>DAG(有向无环图)<br>用最少的互不相交的路径 将所有点覆盖<br>将所有点拆成两个点，出点和入点<br>原图有边i→j<br>则有    i→j’<br>出点 入点<br>原图变为从左边(出点)连向右边(入点)的二分图<br>则最少互不相交的路径=n-m(最大点覆盖数量)</p><p>原图中的每条路径 转化到新图中<br>每个点最多只有一个出度一个入度<br>&lt;=&gt; 新图中的任意两条边之间不相交<br>&lt;=&gt; 新图中的边都是匹配边</p><p>每个路径终点 对应 一个左侧非匹配点(3作为终点 在新图中没出边)<br>&lt;=&gt; 让左侧非匹配点最少 n-m<br>&lt;=&gt; 让左侧匹配点最多 m<br>&lt;=&gt; 找最大匹配边数 m</p><h2 id="代码-24">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">410</span>, M = <span class="hljs-number">6e4</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> match[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j]))<br>            &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b + n);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res ++ ;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n - res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期前集训数据结构题解</title>
      <link href="/2022/05/07/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/07/%E6%9A%91%E6%9C%9F%E5%89%8D%E9%9B%86%E8%AE%AD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>还是有点菜，好多题没做，而且有点摆烂，下一个专题好好做，争取进前十</p><h1>B题</h1><h2 id="题意分析-27">题意分析</h2><p>实现一个满足区间加，区间乘和区间求和的数据结构，区间长度最大$10^5$，操作次数最大$10^5$。</p><h2 id="解题思路-7">解题思路</h2><p>这个是一个朴素的线段数模板，要采用懒标记修改。<br>面对这两种操作，可以联想到线段树的一个非常好的功能就是lazytag，只计算出确实需要访问的区间的真实值，其他的保存在lazytag里面，这样可以近似O(NlogN)的运行起来。在尝试着写了只有一个lazetag的程序之后我们发现一个lazytag是不能够解决问题的，那就上两个，分别表示乘法意义上的lazytag和加法意义上的lazytag。紧接着想到pushdown操作之后我们又发现必须在向下传递lazytag的时候人为地为这两个lazytag规定一个先后顺序，排列组合一下只有两种情况：</p><p>①加法优先，即规定好segtree[root<em>2].value=((segtree[root</em>2].value+segtree[root].add)*segtree[root].mul)%p，问题是这样的话非常不容易进行更新操作，假如改变一下add的数值，mul也要联动变成奇奇怪怪的分数小数损失精度，我们内心是很拒绝的；</p><p>②乘法优先，即规定好segtree[root<em>2].value=(segtree[root</em>2].value<em>segtree[root].mul+segtree[root].add</em>(本区间长度))%p，这样的话假如改变add的数值就只改变add，改变mul的时候把add也对应的乘一下就可以了，没有精度损失，看起来很不错。</p><h2 id="代码-31">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>, d = <span class="hljs-number">998244353</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br>ll a[maxn], t[maxn * <span class="hljs-number">4</span>], add[maxn * <span class="hljs-number">4</span>], mul[maxn * <span class="hljs-number">4</span>];<br>ll n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">ls</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x &lt;&lt; <span class="hljs-number">1</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(ll p)</span></span>&#123;<br>t[p] = (t[<span class="hljs-built_in">ls</span>(p)] + t[<span class="hljs-built_in">rs</span>(p)]) % d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(ll p, ll l, ll r, ll k)</span></span>&#123;<br>t[p] = (t[p] * k) % d;<br>add[p] = (add[p] * k) % d;<br>mul[p] = (mul[p] * k) % d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(ll p, ll l, ll r, ll k)</span></span>&#123;<br>t[p] = (t[p] + k * (r - l + <span class="hljs-number">1</span>)) % d;<br>add[p] = (add[p] + k) % d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p, ll l, ll r)</span></span>&#123;<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">f1</span>(<span class="hljs-built_in">ls</span>(p), l, mid, mul[p]);<br><span class="hljs-built_in">f2</span>(<span class="hljs-built_in">ls</span>(p), l, mid, add[p]);<br><span class="hljs-built_in">f1</span>(<span class="hljs-built_in">rs</span>(p), mid + <span class="hljs-number">1</span>, r, mul[p]);<br><span class="hljs-built_in">f2</span>(<span class="hljs-built_in">rs</span>(p), mid + <span class="hljs-number">1</span>, r, add[p]);<br>add[p] = <span class="hljs-number">0</span>;<br>mul[p] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll p, ll l, ll r)</span></span>&#123;<br>add[p] = <span class="hljs-number">0</span>;<br>mul[p] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(l == r)&#123;<br>t[p] = a[l];<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(<span class="hljs-built_in">ls</span>(p), l, mid);<br><span class="hljs-built_in">build</span>(<span class="hljs-built_in">rs</span>(p), mid + <span class="hljs-number">1</span>, r);<br><span class="hljs-built_in">push_up</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update1</span><span class="hljs-params">(ll L, ll R, ll l, ll r, ll p, ll k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;<br><span class="hljs-built_in">f1</span>(p, l, r, k);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-built_in">push_down</span>(p, l, r);<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L &lt;= mid) <span class="hljs-built_in">update1</span>(L, R, l, mid, <span class="hljs-built_in">ls</span>(p) , k);<br><span class="hljs-keyword">if</span>(R &gt; mid) <span class="hljs-built_in">update1</span>(L, R, mid + <span class="hljs-number">1</span>, r, <span class="hljs-built_in">rs</span>(p), k);<br><span class="hljs-built_in">push_up</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update2</span><span class="hljs-params">(ll L, ll R, ll l, ll r, ll p, ll k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;<br><span class="hljs-built_in">f2</span>(p, l, r, k);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-built_in">push_down</span>(p, l, r);<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L &lt;= mid) <span class="hljs-built_in">update2</span>(L, R, l, mid, <span class="hljs-built_in">ls</span>(p), k);<br><span class="hljs-keyword">if</span>(R &gt; mid) <span class="hljs-built_in">update2</span>(L, R, mid + <span class="hljs-number">1</span>, r, <span class="hljs-built_in">rs</span>(p), k);<br><span class="hljs-built_in">push_up</span>(p);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll L, ll R, ll l, ll r, ll p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> t[p];<br><span class="hljs-built_in">push_down</span>(p, l, r);<br>ll res = <span class="hljs-number">0</span>;<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L &lt;= mid) res += <span class="hljs-built_in">query</span>(L, R, l, mid, <span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">if</span>(R &gt; mid) res += <span class="hljs-built_in">query</span>(L, R, mid + <span class="hljs-number">1</span>, r, <span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> res % d;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ll op, x, y, k;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;op);<br><span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;k);<br><span class="hljs-built_in">update1</span>(x, y, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, k);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;k);<br><span class="hljs-built_in">update2</span>(x, y, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, k);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">3</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">query</span>(x, y, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>C题</h1><h2 id="题意分析-28">题意分析</h2><p>待修改的主席树</p><h2 id="解决思路">解决思路</h2><p>思路是，把二分答案的操作和查询小于一个值的数的数量两种操作结合起来。最好的方法是使用 线段树套主席树。</p><p>说是主席树其实不准确，因为并不是对线段树的可持久化，各个线段树之间也没有像主席树各版本之间的强关联性，所以称为动态开点权值线段树更为确切。</p><p>思路类似于线段树套平衡树，即对于线段树所维护的每个区间，建立一个动态开点权值线段树，表示其所维护的区间的值。</p><p>在修改操作进行时，先在线段树上从上往下跳到被修改的点，删除所经过的点所指向的动态开点权值线段树上的原来的值，然后插入新的值，要经过$O(logn)$个线段树上的节点，在动态开点权值线段树上一次修改操作是$O(logn)$的，所以修改操作的时间复杂度为O(log^2n) 。</p><p>在查询答案时，先取出该区间覆盖在线段树上的所有点，然后用类似于静态区间k小值的方法，将这些点一起向左儿子或向右儿子跳。如果所有这些点左儿子存储的值大于等于k，则往左跳，否则往右跳。由于最多只能覆盖$O(logn)$个节点，所以最多一次只有这么多个节点向下跳，时间复杂度为$O(log^2n)$。</p><p>由于线段树的常数较大，在实现中往往使用常数更小且更方便处理前缀和的 树状数组 实现。</p><h2 id="代码-32">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LC o &lt;&lt; 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RC o &lt;&lt; 1 | 1</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1000010</span>;<br><span class="hljs-type">int</span> n, m, a[maxn], u[maxn], x[maxn], l[maxn], r[maxn], k[maxn], cur, cur1, cur2,<br>    q1[maxn], q2[maxn], v[maxn];<br><span class="hljs-type">char</span> op[maxn];<br>set&lt;<span class="hljs-type">int</span>&gt; ST;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">segment_tree</span>  <span class="hljs-comment">// 封装的动态开点权值线段树</span><br>&#123;<br>  <span class="hljs-type">int</span> cur, rt[maxn * <span class="hljs-number">4</span>], sum[maxn * <span class="hljs-number">60</span>], lc[maxn * <span class="hljs-number">60</span>], rc[maxn * <span class="hljs-number">60</span>];<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; o)</span> </span>&#123; o = ++cur; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> o, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (l == r &amp;&amp; sum[o]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, l);<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">print</span>(lc[o], l, mid);<br>    <span class="hljs-built_in">print</span>(rc[o], mid + <span class="hljs-number">1</span>, r);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; o, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> (!o) o = ++cur;<br>    sum[o] += v;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid)<br>      <span class="hljs-built_in">update</span>(lc[o], l, mid, x, v);<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-built_in">update</span>(rc[o], mid + <span class="hljs-number">1</span>, r, x, v);<br>  &#125;<br>&#125; st;<br><br><span class="hljs-comment">// 树状数组实现</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> o)</span> </span>&#123; <span class="hljs-keyword">return</span> (o &amp; (-o)); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> o, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (; o &lt;= n; o += <span class="hljs-built_in">lowbit</span>(o)) st.<span class="hljs-built_in">update</span>(st.rt[o], <span class="hljs-number">1</span>, n, x, v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gtv</span><span class="hljs-params">(<span class="hljs-type">int</span> o, <span class="hljs-type">int</span>* A, <span class="hljs-type">int</span>&amp; p)</span> </span><br><span class="hljs-function"></span>&#123;<br>  p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (; o; o -= <span class="hljs-built_in">lowbit</span>(o)) A[++p] = st.rt[o];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;<br>  <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, siz = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur1; i++) siz += st.sum[st.lc[q1[i]]];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur2; i++) siz -= st.sum[st.lc[q2[i]]];<br>  <span class="hljs-keyword">if</span> (siz &gt;= k) <br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur1; i++) q1[i] = st.lc[q1[i]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur2; i++) q2[i] = st.lc[q2[i]];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(l, mid, k);<br>  &#125; <br>  <span class="hljs-keyword">else</span> <br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur1; i++) q1[i] = st.rc[q1[i]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur2; i++) q2[i] = st.rc[q2[i]];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(mid + <span class="hljs-number">1</span>, r, k - siz);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a + i), ST.<span class="hljs-built_in">insert</span>(a[i]);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <br>  &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, op + i);<br>    <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-string">&#x27;C&#x27;</span>)<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, u + i, x + i), ST.<span class="hljs-built_in">insert</span>(x[i]);<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, l + i, r + i, k + i);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = ST.<span class="hljs-built_in">begin</span>(); it != ST.<span class="hljs-built_in">end</span>(); it++)<br>    mp[*it] = ++cur, v[cur] = *it;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = mp[a[i]];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-string">&#x27;C&#x27;</span>) x[i] = mp[x[i]];<br>  n += m;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">upd</span>(i, a[i], <span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <br>  &#123;<br>    <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-string">&#x27;C&#x27;</span>) <br>    &#123;<br>      <span class="hljs-built_in">upd</span>(u[i], a[u[i]], <span class="hljs-number">-1</span>);<br>      <span class="hljs-built_in">upd</span>(u[i], x[i], <span class="hljs-number">1</span>);<br>      a[u[i]] = x[i];<br>    &#125; <br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">gtv</span>(r[i], q1, cur1);<br>      <span class="hljs-built_in">gtv</span>(l[i] - <span class="hljs-number">1</span>, q2, cur2);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, v[<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, n, k[i])]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>D题</h1><h2 id="题意分析-29">题意分析</h2><p>平衡树裸题</p><h2 id="解决思路-2">解决思路</h2><p>众所周知Treap = BST + heap</p><p>堆不多说了。</p><p>说说这个BST，就是说一个根节点p，左儿子一定小于他，右儿子大于它。</p><p>也就是BST的中序遍历是严格单调递增的。</p><p>那么就可以进行一些操作了。</p><p>首先为了维护这个BST我们需要一个左旋zag和右旋zig，分别表示将根节点和左右儿子交换位置，使交换后还满足BST的性质。</p><p>这个相当于一个模拟了，代码放在后面。</p><p>然后就是插入。</p><p>这个可以从根节点开始，看看往左儿子走还是往右儿子走，一直走到空或者和自己相等的节点，然后进行插入。</p><p>删除的话也是一样，从根节点走，走到了这个节点就删除掉，如果走到的节点为空，那就不用管了，因为这个节点不存在。</p><p>还有就是删除的时候如果遇到了叶节点可以直接删除，不会影响BST的性质。</p><p>接着就是几个奇怪的操作。</p><p>先说最大最小，就是一直往左走或者一直往右走。</p><p>然后是查排名和排名对应的数，一样的，排名可以一点点走，然后分类讨论，这个可以看代码注释。</p><p>排名对应的数也是一样，但这个得判断一下个数，所以BST里要有cnt和size两个变量表示节点个数和当前这个节点有多少个。</p><p>最后是前驱和后继，具体定义参见题目描述。</p><p>方法也是一样，前驱就是左边最大的，后继就是右边最小的，可以用递归写，会简单很多。</p><p>但是有的时候BST会退化成一条链，时间复杂度就大大降低了，但是只要BST够随机，期望高度就是log n。</p><p>所以的话就把它和堆集合在了一起，变成了平衡树。</p><h2 id="代码-33">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">1e8</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> key, val;<br>    <span class="hljs-type">int</span> cnt, Size;<br>&#125;tr[N];<br><br><span class="hljs-type">int</span> root, idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[p].Size = tr[tr[p].l].Size + tr[tr[p].r].Size + tr[p].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_node</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[ ++ idx].key = key;<br>    tr[idx].val = <span class="hljs-built_in">rand</span>();<br>    tr[idx].cnt = tr[idx].Size = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> idx;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zig</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> q = tr[p].l;<br>    tr[p].l = tr[q].r, tr[q].r = p, p = q;<br>    <span class="hljs-built_in">pushup</span>(tr[p].r), <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zag</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> q = tr[p].r;<br>    tr[p].r = tr[q].l, tr[q].l = p, p = q;<br>    <span class="hljs-built_in">pushup</span>(tr[p].l), <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">get_node</span>(-INF), <span class="hljs-built_in">get_node</span>(INF);<br>    root = <span class="hljs-number">1</span>, tr[root].r = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">pushup</span>(root);<br><br>    <span class="hljs-keyword">if</span> (tr[<span class="hljs-number">1</span>].val &lt; tr[<span class="hljs-number">2</span>].val) <span class="hljs-built_in">zag</span>(root);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) p = <span class="hljs-built_in">get_node</span>(key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tr[p].key == key) tr[p].cnt ++ ;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tr[p].key &gt; key)<br>    &#123;<br>        <span class="hljs-built_in">insert</span>(tr[p].l, key);<br>        <span class="hljs-keyword">if</span> (tr[tr[p].l].val &gt; tr[p].val) <span class="hljs-built_in">zig</span>(p);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">insert</span>(tr[p].r, key);<br>        <span class="hljs-keyword">if</span> (tr[tr[p].r].val &gt; tr[p].val) <span class="hljs-built_in">zag</span>(p);<br>    &#125;<br><br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span> (tr[p].key == key)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (tr[p].cnt &gt; <span class="hljs-number">1</span>) tr[p].cnt -- ;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tr[p].l || tr[p].r)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)<br>            &#123;<br>                <span class="hljs-built_in">zig</span>(p);<br>                <span class="hljs-built_in">remove</span>(tr[p].r, key);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">zag</span>(p);<br>                <span class="hljs-built_in">remove</span>(tr[p].l, key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> p = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tr[p].key &gt; key) <span class="hljs-built_in">remove</span>(tr[p].l, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">remove</span>(tr[p].r, key);<br><br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_rank_by_key</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (tr[p].key == key) <span class="hljs-keyword">return</span> tr[tr[p].l].Size + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (tr[p].key &gt; key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_rank_by_key</span>(tr[p].l, key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_rank_by_key</span>(tr[p].r, key) + tr[tr[p].l].Size + tr[p].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_key_by_rank</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> rank)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> -INF;<br>    <span class="hljs-keyword">if</span> (tr[tr[p].l].Size &gt;= rank) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_key_by_rank</span>(tr[p].l, rank);<br>    <span class="hljs-keyword">if</span> (tr[tr[p].l].Size + tr[p].cnt &gt;= rank) <span class="hljs-keyword">return</span> tr[p].key;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_key_by_rank</span>(tr[p].r, rank - tr[tr[p].l].Size - tr[p].cnt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_prev</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> -INF;<br>    <span class="hljs-keyword">if</span> (tr[p].key &gt;= key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_prev</span>(tr[p].l, key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tr[p].key, <span class="hljs-built_in">get_prev</span>(tr[p].r, key));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">if</span> (tr[p].key &lt;= key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_next</span>(tr[p].r, key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(tr[p].key, <span class="hljs-built_in">get_next</span>(tr[p].l, key));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">build</span>();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> opt, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;opt, &amp;x);<br>        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) <span class="hljs-built_in">insert</span>(root, x);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) <span class="hljs-built_in">remove</span>(root, x);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">get_rank_by_key</span>(root, x) - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">4</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">get_key_by_rank</span>(root, x + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">5</span>) <br>        &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">get_prev</span>(root, x);<br>            <span class="hljs-keyword">if</span> (t == -INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">get_prev</span>(root, x));<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">get_next</span>(root, x);<br>            <span class="hljs-keyword">if</span> (t == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NOT FOUND&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">get_next</span>(root, x));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>E题</h1><h2 id="题意分析-30">题意分析</h2><p>动态求逆序对</p><h2 id="解决思路-3">解决思路</h2><p>可以用CDQ思路解决</p><p>CDQ分治能够快速的找出来三维偏序的问题,也就是对于一个n的序列，每个i有多少个j使得$a_j \leq a_i,$   $b_j  \leq b_i,$ $c_j  \leq c_i$</p><p>假设$a_i$ 不等于$a_j$</p><p>我们首先看一下一维版本我们将所有的元素按照第一关键字排序，对于i来说一共有i-1个j满足条件</p><p>然后看一下二维版本，将所有元素按照双关键字排序，也就是我们以a按照第一关键子排序，以b按照第二关键字排序，我们可以从前往后扫描，当我们扫描第i个元素的时候，所有满足要求的j一定在第i个元素前面，i前面的序列必然满足$a_j \leq a_i$，i的后面必然不满足，我们要做的是在前面i-1个元素中有多少个元素满足$b_j \leq b_i$</p><blockquote><p>双关键字排序的作用是对于i来说，满足要求的j一定是在i的前面，如果我们按照A来排，那么这个性质就不一定会成立。</p></blockquote><ul><li><p>我们可以用树状数组来做，我们可以将b离散化到1-n之间的数，但我们要求前面有多少个数小于等于$b_i$时，相当于求$b_i$的前缀和，然后我们求完后，将第i个元素插入到树状数组里面，将树状数组里面$b_i$这个位置加一。</p></li><li><p>我们也可以用分治做法来做，分治的话类似于归并排序求逆序对，我们现在想求的是对于当前区间，每一个i满足要求的j有多少个，我们可以将所有的i，j对分为3类（i在后，j在前）</p></li></ul><ol><li>i，j都在左侧 $\to$ 递归左边</li><li>i，j都在右侧 $\to$ 递归右边</li><li>i在右侧，j在左侧，因为一定满足第一维性质，所以我们只需要考虑第二维性质，我们需要找出$b_j \leq a_i$的个数，我们每次合并的时候，按照b进行维护序列，可以使用双指针算法，我们i和j从左往右枚举，每次i向后移动一格，j向后移动，找到大于$b_i$的位置<br>算法复杂度$O(nlogn)$</li></ol><p>最后讨论三维问题<br>对于每个i来说，我们都要求满足$a_j \leq a_i,$   $b_j  \leq b_i,$ $c_j  \leq c_i$的j的数目有多少。</p><p>我们的做法是按照三关键字排序，这样做的好处是，所有满足要求的j一定是在i的左侧</p><p>我们可以将所有&lt;i, j&gt; 分成三类 （i在j右边）</p><ol><li>i，j都在左侧</li><li>i，j都在右侧</li><li>i在左，j在右</li></ol><p>对于a条件来说这个限制一定成立，我们不用考虑，我们可以在归并分治的过程中，将区间的所有元素按照b进行排序，我们对于右侧任意一个元素i来说，我们要求的是在左侧有多少个j满足$b_j \leq b_i, c_j \leq c_i$ ,第二维限制我们可以用双指针算法来解决，对于每一个i我们找到第一个$b_j &gt; b_i$的位置（线性复杂度）那么从区间起点到j-1的位置就是满足$b_j \leq b_i$的区间，然后我们需要在这个区间里面找到$c_j \leq c_i$ 的个数，这个可以采用树状数组的方法来解决，我们可以把所有的c离散化，变成从1~n的某个数，我们要想求$c_j \leq c_i$ 的个数相当于求1-$c_i$的总和，即求前缀和，每一次j往后移动一格，相当于在树状数组里面加上$c_j$</p><p>时间复杂度为$O(nlog^2n)$,一共有$logn$层，每层复杂度为$nlogn$</p><p>如果出现$a_j = a_i,$   $b_j  = b_i,$ $c_j = c_i$,我们可以发现排完序后这两个数一定挨在一起，我们对于后面这个元素我们可以正确求解，但对于前面这个元素来讲，它只考虑它前面的元素，没有考虑右侧的部分，那么他就会把和他相等的元素漏掉，对于这样完全相同的元素，我们要进行判重，在序列中去除掉，再记录下每个元素出现了多少次。我们对于同一种元素我们还要更新下答案，如果有k个元素和第i个元素完全相同，那么答案还需要加上k</p><p>首先我们可以发现<br>$p_i$ i的下标</p><p>$A_i$ 元素的值</p><p>$T_i$ 表示元素i被删除的时间，定义删除的时序，如果没有被删我们任意给他分配一个后面的数，为了方便起见，只要有序就可以，我们可以倒着来分配，第一次删除的时候我们的时间戳是n，第二次是n-1，第m次删除的数位n-m+1，剩下的数按照某种顺序分配就可以，那这样的话，每一个数都会有一个唯一的时间戳，至于为什么要倒着分配，是因为你如果倒着来赋值的话，会发现第三维要满足的关系为$T_i \leq T_j$ 这是一个前缀和，如果正着赋值的话，会求一个后缀和，树状数组比较好处理前缀和。</p><p>然后我们考虑下怎么去统计答案，我们要统计的是每一次删除之前有多少个逆序对，因此我们统计的时候应该按照时间来看，我们要按照被删除的时间算答案，对于每一个时间戳$T_j$来说，我们要求和$T_j$可以构成逆序对的数目有多少个，我们把结果存到S[$T_j$]的数组里面，S[i]表示的是和第i个时间被删除的这个元素构成的逆序对的数量（只考虑$T_j$时刻仍然存在的元素）</p><p>我们规定每个数对（i，j），我们看一下那个数更后被删除我们就把这个数对累加到靠后删除的数对，这样不会导致逆序对被多算。</p><p>我们要求的是删除一个元素之前统计整个序列的逆序对数，相当于求两个数都在第i个时刻之后的部分的总数，这些数应该就是$S_1+S_2+…+S_i$也就是$S_i$的前缀和</p><p>现在问题就转换成如何求S[$T_j$]，我们看一下$T_j$的性质</p><ol><li>$T_i &lt; T_j$</li><li>第一种情况 $P_i &lt; P_j, A_i &gt; A_j$ 第二种情况 $P_j &lt; P_i, A_j &gt; A_i$</li></ol><p>因此我们要求两种偏序关系</p><ol><li>$T_i &lt; T_j, P_i &lt; P_j, A_i &gt; A_j$</li><li>$T_i &lt; T_j, P_j &lt; P_i, A_j &gt; A_i$</li></ol><p>然后本题可以把顺序倒过来处理。</p><h2 id="代码-34">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span><br>&#123;<br>    <span class="hljs-type">int</span> a, t, res;<br>&#125;q[N], w[N];<br><span class="hljs-type">int</span> tr[N], pos[N];<br>LL ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l, mid), <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-type">int</span> i = mid, j = r;<br>    <span class="hljs-keyword">while</span> (i &gt;= l &amp;&amp; j &gt; mid)<br>        <span class="hljs-keyword">if</span> (q[i].a &gt; q[j].a) <span class="hljs-built_in">add</span>(q[i].t, <span class="hljs-number">1</span>), i -- ;<br>        <span class="hljs-keyword">else</span> q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j -- ;<br>    <span class="hljs-keyword">while</span> (j &gt; mid) q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j -- ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt;= mid; k ++ ) <span class="hljs-built_in">add</span>(q[k].t, <span class="hljs-number">-1</span>);<br>    <br>    j = l, i = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (j &lt;= mid &amp;&amp; i &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].a &lt; q[j].a) <span class="hljs-built_in">add</span>(q[i].t, <span class="hljs-number">1</span>), i ++ ;<br>        <span class="hljs-keyword">else</span> q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j ++ ;<br>    <span class="hljs-keyword">while</span> (j &lt;= mid) q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j ++ ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = mid + <span class="hljs-number">1</span>; k &lt; i; k ++ ) <span class="hljs-built_in">add</span>(q[k].t, <span class="hljs-number">-1</span>);<br>    <br>    i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].a &lt; q[j].a) w[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> w[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">while</span> (i &lt;= mid) w[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= mid) w[k ++ ] = q[j ++ ];<br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; j &lt; k; j ++ , i ++ ) q[i] = w[j]; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    m = n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q[i].a);<br>        pos[q[i].a] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        q[pos[x]].t = j ++ ;<br>        pos[x] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>            <br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) ans[q[i].t] = q[i].res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ ) ans[i] += ans[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans[i]);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>I题</h1><h2 id="题意分析-31">题意分析</h2><p>并查集裸题</p><h2 id="解决思路-4">解决思路</h2><p>~~ 势能分析没听懂，不管他了 ~~</p><p>要考虑并查集的优化，按秩合并，然后路径压缩就可以解决，比较简单，不再赘述。</p><h2 id="代码-35">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (frS==frT&amp;&amp;(frT=(frS=frBB)+fread(frBB,1,1&lt;&lt;15,stdin),frS==frT)?EOF:*frS++)</span><br><span class="hljs-type">char</span> frBB[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>],*frS=frBB,*frT=frBB;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span></span>&#123;<br>    x=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c))c=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c))&#123;x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;c=<span class="hljs-built_in">getchar</span>();&#125;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e6</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> siz[N], p[N];<br><span class="hljs-type">int</span> ans[N], top;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x != p[x]) <span class="hljs-keyword">return</span> p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">read</span>(n); <span class="hljs-built_in">read</span>(m);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i, siz[i] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> op, a, b;<br>        <span class="hljs-built_in">read</span>(op); <span class="hljs-built_in">read</span>(a); <span class="hljs-built_in">read</span>(b);<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) <br>        &#123;<br>            a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>            <span class="hljs-keyword">if</span> (siz[a] &gt; siz[b]) <span class="hljs-built_in">swap</span>(a, b);<br>            p[a] = b;<br>            siz[b] += siz[a];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(a) == <span class="hljs-built_in">find</span>(b)) ans[ ++ top] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> ans[ ++ top] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>, a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = top; i &gt; <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ans[i]) res = (res + a) % mod;<br>        a = (a * <span class="hljs-number">2</span>) % mod;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>J题</h1><h2 id="题意分析-32">题意分析</h2><p>有n个物品和n张钱，每个物品必须用面值不小于他的钱支付，可以修改k张钱面值，求最小的总支付面值</p><h2 id="解决方法">解决方法</h2><p>要使花的钱最少，即让每一次交易中，纸币面值与商品价值的差值之和最小。（贪心）<br>由此可推出以下两点：</p><ol><li><p>【贪心地购买】在不需要使用魔法的情况下，如何保证差值尽可能小？</p><ol><li>将$w_i,v_i$排序<br>由于</li><li>魔法改变纸币面值而商品价值固定（不会被操作打乱）</li><li>对于价值更高的商品，可能存在的能买下它的纸币数量更少。<br>因此</li><li>对商品价值 从大到小枚举进行操作。</li></ol></li><li><p>答案是每次从能买得起 的纸币中挑选面值 最小的纸币</p></li><li><p>【贪心的魔法】如何更加高效地使用魔法？<br>如果要使用魔法，只会存在两种情况：买不起，小改大；钱太多，大改小<br>（优先”小改大“，保证尽量有解；”小改大“之后有剩余魔法才考虑”大改小“）</p></li><li><p>如果想买下当前最贵的商品，需要把小纸币改大，则使用魔法之前不存在能买得起该商品的纸币，且一定刚好将某个小纸币改大到要买的商品的价值 。 此时不确定是对哪个小纸币使用魔法，但是由于纸币数量刚好和商品数量相同，如果有解，则在一一 枚举商品之后一定存在被挑剩下的小纸币（挑选方式后续说明）</p></li><li><p>如果当前状态下不需要使用魔法把小纸币改大即可买下所有商品。</p></li></ol><p>用一个新数组记录每个对应关系中纸币面值与商品价值的差值。</p><p>后续将差值排序，取前k大的差值修改为零，即相当于将那k组对应关系中的大纸币改小到要买的商品的价值 。</p><ul><li>NIE的判断条件</li></ul><p>枚举到商品$v_i$时，<br>不存在买得起商品 的纸币，<br>且使用魔法的剩余次数为0</p><h2 id="代码-36">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> w[N], v[N], c[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res;<br><span class="hljs-type">int</span> stk[N], top, cnt;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br>        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v[i]);<br>        <br>    <span class="hljs-built_in">sort</span>(w + <span class="hljs-number">1</span>, w + n + <span class="hljs-number">1</span>, cmp);<br>    <span class="hljs-built_in">sort</span>(v + <span class="hljs-number">1</span>, v + n + <span class="hljs-number">1</span>, cmp);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">while</span> (w[j] &gt;= v[i])<br>        &#123;<br>            stk[ ++ top] = w[j];<br>            j ++ ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!top)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NIE&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            m -- ;<br>            res += v[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> t = stk[top -- ];<br>            c[ ++ cnt] = t - v[i];<br>            res += t;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span> + cnt, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>        res -= c[i];<br>        <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>K题</h1><h2 id="题意分析-33">题意分析</h2><p>一个n*n的矩阵(1≤n≤500)，m(1≤m≤10^5)次操作，每次修改矩阵中的一个值或查询一个矩形中的最大值和最小值</p><h2 id="解决思路-5">解决思路</h2><p>线段树可以维护一维的信息，通过线段树套线段树来维护二维的信息。</p><p>外层的线段树维护第一个维度上的信息，即第1到n行，对于每个节点各开一个内层线段树，这个线段树维护在外层线段树节点对应的行中1到n列的信息</p><p>注意单点修改时非叶子节点和叶子节点的更新方式不同，修改时现在外层线段树找到要修改的叶子节点，修改内层线段树，之后根据叶子结点的内层线段树修改外层非叶子节点的内层线段树</p><p>我们考虑用树套树如何实现在二维平面上进行单点修改，区域查询。我们考虑外层的线段树，最底层的1到n个节点的子树，分别代表第1 到第n行的线段树。那么这些底层的节点对应的父节点，就代表其两个子节点的子树所在的一片区域。</p><h2 id="代码-37">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">1e8</span>;<br> <br><span class="hljs-type">int</span> n,q,mx[N][N],mi[N][N];<br><span class="hljs-type">int</span> fg,xo,mians,mxans;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd2</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> v)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(fg) mi[xo][o]=v,mx[xo][o]=v;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            mi[xo][o]=<span class="hljs-built_in">min</span>(mi[<span class="hljs-number">2</span>*xo][o],mi[<span class="hljs-number">2</span>*xo+<span class="hljs-number">1</span>][o]);<br>            mx[xo][o]=<span class="hljs-built_in">max</span>(mx[<span class="hljs-number">2</span>*xo][o],mx[<span class="hljs-number">2</span>*xo+<span class="hljs-number">1</span>][o]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> m=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(y&lt;=m) <span class="hljs-built_in">upd2</span>(l,m,<span class="hljs-number">2</span>*o,y,v);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">upd2</span>(m+<span class="hljs-number">1</span>,r,<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>,y,v);<br>    mi[xo][o]=<span class="hljs-built_in">min</span>(mi[xo][<span class="hljs-number">2</span>*o],mi[xo][<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>]);<br>    mx[xo][o]=<span class="hljs-built_in">max</span>(mx[xo][<span class="hljs-number">2</span>*o],mx[xo][<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>]);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd1</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> v)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) &#123;<br>        fg=<span class="hljs-number">1</span>;<br>        xo=o;<br>        <span class="hljs-built_in">upd2</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,y,v);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> m=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(x&lt;=m) <span class="hljs-built_in">upd1</span>(l,m,<span class="hljs-number">2</span>*o,x,y,v);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">upd1</span>(m+<span class="hljs-number">1</span>,r,<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>,x,y,v);<br>    fg=<span class="hljs-number">0</span>,xo=o;<br>    <span class="hljs-built_in">upd2</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,y,v);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qy2</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> pre,<span class="hljs-type">int</span> ly,<span class="hljs-type">int</span> ry)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(ly&lt;=l&amp;&amp;ry&gt;=r) <br>    &#123;<br>        mians=<span class="hljs-built_in">min</span>(mians,mi[pre][o]);<br>        mxans=<span class="hljs-built_in">max</span>(mxans,mx[pre][o]);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> m=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(ly&lt;=m) <span class="hljs-built_in">qy2</span>(l,m,<span class="hljs-number">2</span>*o,pre,ly,ry);<br>    <span class="hljs-keyword">if</span>(ry&gt;m) <span class="hljs-built_in">qy2</span>(m+<span class="hljs-number">1</span>,r,<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>,pre,ly,ry);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qy1</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> o,<span class="hljs-type">int</span> lx,<span class="hljs-type">int</span> rx,<span class="hljs-type">int</span> ly,<span class="hljs-type">int</span> ry)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(lx&lt;=l&amp;&amp;rx&gt;=r) <br>    &#123;<br>        <span class="hljs-built_in">qy2</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,o,ly,ry);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> m=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(lx&lt;=m) <span class="hljs-built_in">qy1</span>(l,m,<span class="hljs-number">2</span>*o,lx,rx,ly,ry);<br>    <span class="hljs-keyword">if</span>(rx&gt;m) <span class="hljs-built_in">qy1</span>(m+<span class="hljs-number">1</span>,r,<span class="hljs-number">2</span>*o+<span class="hljs-number">1</span>,lx,rx,ly,ry);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;v),<span class="hljs-built_in">upd1</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,i,j,v);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-type">int</span> op;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;op);<br>        <span class="hljs-type">int</span> x,y,x1,y1;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>) <br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;x1,&amp;y1);<br>            mians=inf;<br>            mxans=<span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">qy1</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,x,x1,y,y1);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,mxans,mians);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;v);<br>            <span class="hljs-built_in">upd1</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,x,y,v);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>L题</h1><h2 id="题意分析-34">题意分析</h2><p>求区间众数</p><h2 id="解决思路-6">解决思路</h2><p>可以采用分块的思想</p><p>分块的思想其实就是一个朴素的暴力做法。<br>我们把一个区间分成$\sqrt{n}$段，对于查询的区间，我们可以将其分成最多两个不完整段（长度$\leq \sqrt{n}$）和不超过$\sqrt{n}$个完整段。因此我们可以把$O(N)$复杂度变为$O(logn)$</p><p>对于这个题首先预处理i~j块的众数个数，如果求出i~j-1的众数个数了，现在要求i~j的众数个数，是不是就很简单了，众数个数要么是i~j-1的众数个数，要么就是第j块中数字出现的次数，那么就可以枚举第j块的数字，如果我们预处理出前i块数字j出现的次数（定义为sum[i][j]）,那么第j块出现的数字a[p]（其中p处于第j块中）在i~j块出现的次数为sum[j][ a[p] ]-sum[i-1][ a[p] ]。并且sum数字的预处理很简单。</p><p>预处理完成后，就是查询问题，查询其实和预处理的原理是一样的，假设L属于第x块，R属于第y块，那么此区间的众数个数要么是x+1~y-1块的众数个数，要么是L~第x块结束中数字出现的次数，要么就是第y块开始~R中数字出现的次数，由于x+1~y-1块的众数个数已经处理，那么只需要O（1）即可知道，另外两块就可以直接暴力统计个数就行（这里需要注意只需要初始化这两块中出现的数字，这样初始化复杂度只有sqrt（n），初值应为sum[y-1][p]-sum[x][p]，p为块中出现的数字），另外注意处理L和R处于同一块的情况，这样区间众数问题就解决了。</p><h2 id="代码-38">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> p, q , t, n, m;<br><span class="hljs-type">int</span> l, r, L, pos, lan;<br><span class="hljs-type">int</span> most[N],maxn[N],sum[<span class="hljs-number">1600</span>][N],a[N], b[<span class="hljs-number">100</span>],temp[N], c[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">discrete</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+n+<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> sz=<span class="hljs-built_in">unique</span>(c+<span class="hljs-number">1</span>,c+n+<span class="hljs-number">1</span>)-c<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i]=<span class="hljs-built_in">lower_bound</span>(c+<span class="hljs-number">1</span>,c+sz+<span class="hljs-number">1</span>,a[i])-c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-built_in">swap</span>(l,r);<br><br>p=l/L;<br>q=r/L;<br><span class="hljs-keyword">if</span>(l % L == <span class="hljs-number">1</span>)<br>p++;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l % L) p += <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span> p++;<br><span class="hljs-type">int</span> ans;<br><span class="hljs-keyword">if</span>(q-p&lt;<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">int</span> maxx=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)<br>&#123; <br>temp[a[i]]++;<br><span class="hljs-keyword">if</span>(temp[a[i]]&gt;maxx)<br>maxx=temp[a[i]],ans=a[i];<br><span class="hljs-keyword">if</span>(temp[a[i]]==maxx&amp;&amp;c[a[i]]&lt;c[ans])<br>ans=a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++) temp[a[i]]--;<br><br><span class="hljs-keyword">return</span> c[ans];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pos=b[p<span class="hljs-number">-1</span>] + q- p + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> maxx=maxn[pos];ans=most[pos];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt;= L*(p<span class="hljs-number">-1</span>); i++)<br>&#123;<br>sum[pos][a[i]]++;<br><span class="hljs-keyword">if</span>(sum[pos][a[i]]&gt;maxx)<br>maxx=sum[pos][a[i]],ans=a[i];<br><span class="hljs-keyword">if</span>(sum[pos][a[i]]==maxx&amp;&amp;c[a[i]]&lt;c[ans])<br>ans=a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=L*q+<span class="hljs-number">1</span>;i&lt;=r;i++)<br>&#123;<br>sum[pos][a[i]]++;<br><span class="hljs-keyword">if</span>(sum[pos][a[i]]&gt;maxx)<br>maxx=sum[pos][a[i]],ans=a[i];<br><span class="hljs-keyword">if</span>(sum[pos][a[i]]==maxx&amp;&amp;c[a[i]]&lt;c[ans])<br>ans=a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=L*(p<span class="hljs-number">-1</span>);i++) sum[pos][a[i]]--;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=L*q+<span class="hljs-number">1</span>;i&lt;=r;i++) sum[pos][a[i]]--;<br><br><span class="hljs-keyword">return</span> c[ans] ;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]),c[i]=a[i];<br><span class="hljs-built_in">discrete</span>();<br>t=<span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0</span>*n,<span class="hljs-number">1.0</span>/<span class="hljs-number">3.0</span>);L=n/t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++) b[i]=b[i<span class="hljs-number">-1</span>],b[i]+=t-i+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=t-i+<span class="hljs-number">1</span>;j++)<br>&#123;<br>pos=b[i<span class="hljs-number">-1</span>]+j;<br><span class="hljs-type">int</span> maxx=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> ans;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=L*(i<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;k&lt;=L*(i+j<span class="hljs-number">-1</span>);k++)<br>&#123;<br>sum[pos][a[k]]++;<br><span class="hljs-keyword">if</span>(sum[pos][a[k]]&gt;maxx)<br>maxx=sum[pos][a[k]],ans=a[k];<br><br><span class="hljs-keyword">if</span>(sum[pos][a[k]]==maxx&amp;&amp;c[a[k]]&lt;c[ans])<br>ans=a[k];<br>&#125;<br>most[pos]=ans;maxn[pos]=maxx;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,lan=<span class="hljs-built_in">ask</span>(l,r));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>M题</h1><h2 id="题意分析-35">题意分析</h2><p>给你一棵树有N个节点，这棵树的节点编号从 1 到 N。每个节点都有一个颜色。<br>要求你得到以下操作的答案：U V : 询问从 U 到 V 的路径上有多少个不同的颜色。</p><h2 id="解决方法-2">解决方法</h2><p>可以使用树上莫队解决<br>这道题其实就是将基本莫队那道例题搬到了树上，求树中任意两个点之间最短路径的数字个数。对于在树上维护某些路径的信息，普遍的做法是将数转换成一个序列，此题用的是欧拉序列。</p><p>欧拉序列：</p><p>从根节点向下dfs，记录所有遇到的点，最终返回到根节点，故每个点都会在序列中出现两次。</p><p>观察上面的欧拉序列，我们可以发现这样几个性质，假设 X在欧拉序中出现地比 Y早：</p><p>如果 X是 Y 的祖先，那么从 X 到 Y 的路径上经过的节点为：欧拉序中 X 第一次出现的位置到 Y 第一次出现的位置的区间内只出现过一次的节点（如1到4）。<br>如果 X 和 Y 有一个公共祖先 $(P \not = X, P \not = Y)$  ，那么从 X 到 Y 的路径上经过的节点为：欧拉序列中 X 第二次出现的位置到 Y 第一次出现的位置的区间内所有只出现过一次的节点，另外再加上 P ，如（4到6经过的数字在欧拉序中为4236再加上祖先1）。<br>如此，我们就可以将树转换成一个序列，对于每次询问，先判断 X 是否为 Y 的祖先，然后将询问的两个节点转变为欧拉序列中对应的下标，然后用莫队维护欧拉序列即可。当然，如果 X 和 Y 有一个不同于他们的公共祖先，那么还得在维护完区间后再加上他们的公共祖先。</p><p>4.2 莫队的加数操作<br>需要注意的是，此题莫队需要维护的是区间内只出现过一次的节点对应的数字的种数，我们用  记录某个数字在区间内出现过几次，用 标记某个节点是否在询问的路径上（如果在欧拉序中对应的区间内只出现过一次则在路径上，记为1）。我们考虑在当前序列中加入一个节点，如果这个节点当前状态  ，说明此节点之前出现过一次，现在又出现了一次，则不存在于路径上，则更新 ，我们可以发现加入一个节点其实就是将该节点的  异或上1。更新完  后，如果  变为1了，说明有新节点加入路径，则将该节点对应的数字维护到  中，同时更新 ；如果  变为 0， 则删去该节点对应的数字，更新  ，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;res)</span> </span>&#123;<br>    sta[x] ^= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (sta[x]) &#123;<br>        <span class="hljs-keyword">if</span> (!cnt[w[x]]) res++;<br>        cnt[w[x]]++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cnt[w[x]]--;<br>        <span class="hljs-keyword">if</span> (!cnt[w[x]]) res--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>梳理一遍代码流程：</p><p>由于数字取值在  范围，所以首先进行离散化操作。<br>求出树的欧拉序列。<br>求出每个节点的深度，同时将倍增计算lca的预处理完成。<br>将每次询问的两个节点转换成欧拉序的左右端点。<br>莫队维护计算所有询问。</p><h2 id="代码-39">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m, len;<br><span class="hljs-type">int</span> w[N];<br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> depth[N], f[N][<span class="hljs-number">16</span>];<br><span class="hljs-type">int</span> seq[N], top, first[N], last[N];<br><span class="hljs-type">int</span> cnt[N], st[N], ans[N];<br><span class="hljs-type">int</span> que[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span><br>&#123;<br>    <span class="hljs-type">int</span> id, l, r, p;<br>&#125;q[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>    seq[ ++ top] = u;<br>    first[u] = top;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j != father) <span class="hljs-built_in">dfs</span>(j, u);<br>    &#125;<br>    seq[ ++ top] = u;<br>    last[u] = top;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(depth, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> depth);<br>    depth[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, depth[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    que[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-type">int</span> t = que[hh ++ ];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (depth[j] &gt; depth[t] + <span class="hljs-number">1</span>)<br>            &#123;<br>                depth[j] = depth[t] + <span class="hljs-number">1</span>;<br>                f[j][<span class="hljs-number">0</span>] = t;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">15</span>; k ++ )<br>                    f[j][k] = f[f[j][k - <span class="hljs-number">1</span>]][k - <span class="hljs-number">1</span>];<br>                que[ ++ tt] = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (depth[a] &lt; depth[b]) <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">15</span>; k &gt;= <span class="hljs-number">0</span>; k -- )<br>        <span class="hljs-keyword">if</span> (depth[f[a][k]] &gt;= depth[b])<br>            a = f[a][k];<br>    <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">15</span>; k &gt;= <span class="hljs-number">0</span>; k -- )<br>        <span class="hljs-keyword">if</span> (f[a][k] != f[b][k])<br>        &#123;<br>            a = f[a][k];<br>            b = f[b][k];<br>        &#125;<br>    <span class="hljs-keyword">return</span> f[a][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x / len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Query&amp; a, <span class="hljs-type">const</span> Query&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">get</span>(a.l), j = <span class="hljs-built_in">get</span>(b.l);<br>    <span class="hljs-keyword">if</span> (i != j) <span class="hljs-keyword">return</span> i &lt; j;<br>    <span class="hljs-keyword">return</span> a.r &lt; b.r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span>&amp; res)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[x] ^= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (st[x] == <span class="hljs-number">0</span>)<br>    &#123;<br>        cnt[w[x]] -- ;<br>        <span class="hljs-keyword">if</span> (!cnt[w[x]]) res -- ;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (!cnt[w[x]]) res ++ ;<br>        cnt[w[x]] ++ ;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]), nums.<span class="hljs-built_in">push_back</span>(w[i]);<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    nums.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        w[i] = <span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), w[i]) - nums.<span class="hljs-built_in">begin</span>();<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add_edge</span>(a, b), <span class="hljs-built_in">add_edge</span>(b, a);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">bfs</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-keyword">if</span> (first[a] &gt; first[b]) <span class="hljs-built_in">swap</span>(a, b);<br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">lca</span>(a, b);<br>        <span class="hljs-keyword">if</span> (a == p) q[i] = &#123;i, first[a], first[b]&#125;;<br>        <span class="hljs-keyword">else</span> q[i] = &#123;i, last[a], first[b], p&#125;;<br>    &#125;<br><br>    len = <span class="hljs-built_in">sqrt</span>(top);<br>    <span class="hljs-built_in">sort</span>(q, q + m, cmp);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, L = <span class="hljs-number">1</span>, R = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> id = q[i].id, l = q[i].l, r = q[i].r, p = q[i].p;<br>        <span class="hljs-keyword">while</span> (R &lt; r) <span class="hljs-built_in">add</span>(seq[ ++ R], res);<br>        <span class="hljs-keyword">while</span> (R &gt; r) <span class="hljs-built_in">add</span>(seq[R -- ], res);<br>        <span class="hljs-keyword">while</span> (L &lt; l) <span class="hljs-built_in">add</span>(seq[L ++ ], res);<br>        <span class="hljs-keyword">while</span> (L &gt; l) <span class="hljs-built_in">add</span>(seq[ -- L], res);<br>        <span class="hljs-keyword">if</span> (p) <span class="hljs-built_in">add</span>(p, res);<br>        ans[id] = res;<br>        <span class="hljs-keyword">if</span> (p) <span class="hljs-built_in">add</span>(p, res);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans[i]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>N题</h1><h2 id="题意分析-36">题意分析</h2><p>给定n(1≤n≤5×10^4)个元素， m(1≤m≤5×10^4)次操作，每次操作修改一个元素或查询一个区间上某个元素的排名或区间上第k小的值</p><h2 id="解决方法-3">解决方法</h2><ol><li>线段树中的每个点表示一个区间，单独开一个平衡树存储这个区间内的点</li><li>修改操作：在外层线段树中查询要修改的节点（logn），对这个节点的内层平衡树做修改（logn）</li><li>排名查询：在外层线段树中将查询的区间拆开（ logn，最多有logn个 ），在内层平衡树中可以查询到比k小的元素个数（ logn ），加起来计算可以得到结果</li><li>第k小：排名查询+二分，复杂度（log^3n）</li></ol><h2 id="代码-40">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2000010</span>, INF = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> s[<span class="hljs-number">2</span>], p, v;<br>    <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> _v, <span class="hljs-type">int</span> _p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        v = _v, p = _p;<br>        size = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;tr[N];<br><span class="hljs-type">int</span> L[N], R[N], T[N], idx;<br><span class="hljs-type">int</span> w[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[x].size = tr[tr[x].s[<span class="hljs-number">0</span>]].size + tr[tr[x].s[<span class="hljs-number">1</span>]].size + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = tr[x].p, z = tr[y].p;<br>    <span class="hljs-type">int</span> k = tr[y].s[<span class="hljs-number">1</span>] == x;<br>    tr[z].s[tr[z].s[<span class="hljs-number">1</span>] == y] = x, tr[x].p = z;<br>    tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br>    tr[x].s[k ^ <span class="hljs-number">1</span>] = y, tr[y].p = x;<br>    <span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (tr[x].p != k)<br>    &#123;<br>        <span class="hljs-type">int</span> y = tr[x].p, z = tr[y].p;<br>        <span class="hljs-keyword">if</span> (z != k)<br>            <span class="hljs-keyword">if</span> ((tr[y].s[<span class="hljs-number">1</span>] == x) ^ (tr[z].s[<span class="hljs-number">1</span>] == y)) <span class="hljs-built_in">rotate</span>(x);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">rotate</span>(y);<br>        <span class="hljs-built_in">rotate</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!k) root = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; root, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (u) p = u, u = tr[u].s[v &gt; tr[u].v];<br>    u = ++ idx;<br>    <span class="hljs-keyword">if</span> (p) tr[p].s[v &gt; tr[p].v] = u;<br>    tr[u].<span class="hljs-built_in">init</span>(v, p);<br>    <span class="hljs-built_in">splay</span>(root, u, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_k</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (u)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (tr[u].v &lt; v) res += tr[tr[u].s[<span class="hljs-number">0</span>]].size + <span class="hljs-number">1</span>, u = tr[u].s[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> u = tr[u].s[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root;<br>    <span class="hljs-keyword">while</span> (u)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (tr[u].v == x) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (tr[u].v &lt; x) u = tr[u].s[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> u = tr[u].s[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-built_in">splay</span>(root, u, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> l = tr[u].s[<span class="hljs-number">0</span>], r = tr[u].s[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (tr[l].s[<span class="hljs-number">1</span>]) l = tr[l].s[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (tr[r].s[<span class="hljs-number">0</span>]) r = tr[r].s[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">splay</span>(root, l, <span class="hljs-number">0</span>), <span class="hljs-built_in">splay</span>(root, r, l);<br>    tr[r].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">pushup</span>(r), <span class="hljs-built_in">pushup</span>(l);<br>    <span class="hljs-built_in">insert</span>(root, y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    L[u] = l, R[u] = r;<br>    <span class="hljs-built_in">insert</span>(T[u], -INF), <span class="hljs-built_in">insert</span>(T[u], INF);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++ ) <span class="hljs-built_in">insert</span>(T[u], w[i]);<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_k</span>(T[u], x) - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (a &lt;= mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, a, b, x);<br>    <span class="hljs-keyword">if</span> (b &gt; mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, a, b, x);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">update</span>(T[u], w[p], x);<br>    <span class="hljs-keyword">if</span> (L[u] == R[u]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (p &lt;= mid) <span class="hljs-built_in">change</span>(u &lt;&lt; <span class="hljs-number">1</span>, p, x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">change</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, p, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, res = -INF;<br>    <span class="hljs-keyword">while</span> (u)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (tr[u].v &lt; v) res = <span class="hljs-built_in">max</span>(res, tr[u].v), u = tr[u].s[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> u = tr[u].s[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, res = INF;<br>    <span class="hljs-keyword">while</span> (u)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (tr[u].v &gt; v) res = <span class="hljs-built_in">min</span>(res, tr[u].v), u = tr[u].s[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> u = tr[u].s[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_pre</span>(T[u], x);<br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>, res = -INF;<br>    <span class="hljs-keyword">if</span> (a &lt;= mid) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query_pre</span>(u &lt;&lt; <span class="hljs-number">1</span>, a, b, x));<br>    <span class="hljs-keyword">if</span> (b &gt; mid) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query_pre</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, a, b, x));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_suc</span>(T[u], x);<br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>, res = INF;<br>    <span class="hljs-keyword">if</span> (a &lt;= mid) res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">query_suc</span>(u &lt;&lt; <span class="hljs-number">1</span>, a, b, x));<br>    <span class="hljs-keyword">if</span> (b &gt; mid) res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">query_suc</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, a, b, x));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> op, a, b, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;op);<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, a, b, x));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e8</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, a, b, mid) + <span class="hljs-number">1</span> &lt;= x) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;x);<br>            <span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>, a, x);<br>            w[a] = x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>Z题</h1><h2 id="题意分析-37">题意分析</h2><p>给定n(1≤n≤$10^6$)个元素，m(1≤m≤$10^5$)次操作，每次向里面的某个位置插入一个数或查询某一位置上的数</p><h2 id="解决方法-4">解决方法</h2><p>采用块状链表解决</p><h2 id="块状链表">块状链表</h2><p>把原来的序列分成若干块，每一块会用双向链表维护，每一段长度不定</p><ul><li>插入一段 $O(\sqrt(n))$ 首先分裂节点，然后在分裂点插入序列</li><li>删除一段 $O(\sqrt(n))$ 首先删除开头节点的后半部分，然后删除中间完整节点，最后删除结尾节点的前半部分</li><li>合并块状链表 遍历整个块状链表，若下一个点可以合并至当前点，则合并，该操作是保证时间复杂度的关键 $O(\sqrt(n))$</li></ul><h2 id="例题-3"><a href="https://www.acwing.com/problem/content/949/">例题</a></h2><h2 id="rope">rope</h2><p>这里介绍下rope容器<br>Rope其主要是结合了链表和数组各自的优点，链表中的节点指向每个数据.<br>时间复杂度为$O(n \sqrt n)$可以在很短的时间内实现快速的插入、删除和查找字符串，是一个很厉害的神器！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ext/rope&gt;</span><span class="hljs-comment">///头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_cxx;<br>rope &lt;<span class="hljs-type">int</span>&gt; x;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    x.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">///在末尾加x</span><br>    x.<span class="hljs-built_in">insert</span>(pos, x); <span class="hljs-comment">///在pos位置加入x</span><br>    x.<span class="hljs-built_in">erase</span>(pos, x); <span class="hljs-comment">///从pos位置删除x个元素</span><br>    x.<span class="hljs-built_in">copy</span>(pos, len, x); <span class="hljs-comment">///从pos开始len个元素用x代替</span><br>    x.<span class="hljs-built_in">replace</span>(pos, x); <span class="hljs-comment">///从pos开始全部换为x</span><br>    x.<span class="hljs-built_in">substr</span>(pos, x); <span class="hljs-comment">///提取pos开始x个元素</span><br>    x.<span class="hljs-built_in">at</span>(x)/[x]; <span class="hljs-comment">///访问第x个元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码-41">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext/rope&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_cxx;<br><br>rope&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;S:&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> t : s)<br>        cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        s.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> opt, k, pos;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;opt, &amp;k);<br>        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pos);<br>            s.<span class="hljs-built_in">insert</span>(pos - <span class="hljs-number">1</span>, k);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s.<span class="hljs-built_in">at</span>(k - <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django框架学习</title>
      <link href="/2022/05/06/Django%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/06/Django%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web学习</title>
      <link href="/2022/05/06/Web%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/06/Web%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习</title>
      <link href="/2022/05/06/Linux%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/06/Linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2022/05/06/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2022/05/06/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2022/05/06/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2022/05/06/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>斜率优化DP</title>
      <link href="/2022/05/06/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP/"/>
      <url>/2022/05/06/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列优化DP</title>
      <link href="/2022/05/06/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP/"/>
      <url>/2022/05/06/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位DP</title>
      <link href="/2022/05/06/%E6%95%B0%E4%BD%8DDP/"/>
      <url>/2022/05/06/%E6%95%B0%E4%BD%8DDP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形DP</title>
      <link href="/2022/05/06/%E6%A0%91%E5%BD%A2DP/"/>
      <url>/2022/05/06/%E6%A0%91%E5%BD%A2DP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间DP</title>
      <link href="/2022/05/06/%E5%8C%BA%E9%97%B4DP/"/>
      <url>/2022/05/06/%E5%8C%BA%E9%97%B4DP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态压缩DP</title>
      <link href="/2022/05/06/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
      <url>/2022/05/06/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机模型</title>
      <link href="/2022/05/06/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/05/06/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长上升子序列模型</title>
      <link href="/2022/05/06/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/05/06/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://www.acwing.com/problem/content/1019/">怪盗基德的滑翔翼</a></h1><h2 id="题意分析-21">题意分析</h2><p>有n个楼房，怪盗基德可以任意选择一个楼房作为起点，可以向左滑行，也可以向右滑行，一旦方向确定就不能改变了，求最多滑行的建筑，即左右的最长下降子序列。</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_107a40dbce-1.png" alt="1.png"></p><p>当确定完方向和起点后，最长的距离是什么呢？</p><p>假设起点是a[i]</p><pre><code>如果往左飞，最长距离是从1号点开始以a[i]的结尾的最长上升子序列如果往右飞，最长距离是从n号点开始以a[i]的结尾的最长上升子序列</code></pre><p>因此我们就可以把该问题转换成在两个方向上求解最长上升子序列模型的问题</p><p>时间复杂度$O(n^2)$</p><h2 id="代码-25">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n, res;<br><span class="hljs-type">int</span> f[N], a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T -- )<br>    &#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];<br>        <br>        res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        &#123;<br>            f[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ )<br>                <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                    f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>                    <br>            res = <span class="hljs-built_in">max</span>(res, f[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -- )<br>        &#123;<br>            f[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j -- )<br>                <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                    f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>                    <br>            res = <span class="hljs-built_in">max</span>(res, f[i]);<br>        &#125;<br>        <br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/1016/">登山</a></h1><h2 id="题意分析-22">题意分析</h2><p>条件1：要按照编号递增的顺序来浏览 $\to$ 子序列<br>条件2：相邻两个景点的高度不能相同<br>条件3：一旦开始下降，就不能上升 $\to$ 走过的路线必然是先严格单调上升再严格单调下降</p><p>目标：求最多浏览多少景点，求第k类最大长度</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_af49dd79ce-1.png" alt="1.png"></p><p>因为左右两边互不相关，我们先让左边最大，而且右边最大，就可以让我们整个值取得最大值左边的最大值是从1号点开始以a[k]的结尾的最长上升子序列，右边的最大值是从n号点开始以a[k]的结尾的最长上升子序列</p><p>用f[i],g[i]分别维护从1，n号节点开始的最长上升子序列，res=max(f[i] + g[i] - 1)，减一是因为第i个节点算了两次。</p><p>时间复杂度$O(n^2)$</p><h2 id="代码-26">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, res;<br><span class="hljs-type">int</span> f[N], g[N], a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ )<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -- )<br>    &#123;<br>        g[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j -- )<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                g[i] = <span class="hljs-built_in">max</span>(g[i], g[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) res = <span class="hljs-built_in">max</span>(res, f[i] + g[i] - <span class="hljs-number">1</span>);<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/484/">合唱队形</a></h1><h2 id="题意分析-23">题意分析</h2><p>和上面那个题本质一模一样</p><p>答案等于n-上面那个题求出的答案</p><h2 id="代码-27">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, res;<br><span class="hljs-type">int</span> f[N], g[N], a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ )<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i -- )<br>    &#123;<br>        g[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j -- )<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                g[i] = <span class="hljs-built_in">max</span>(g[i], g[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) res = <span class="hljs-built_in">max</span>(res, f[i] + g[i] - <span class="hljs-number">1</span>);<br>    <br>    cout &lt;&lt; (n - res) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/1014/">友好城市</a></h1><h2 id="题意分析-24">题意分析</h2><p>有一条笔直的河流，河流的两侧有不同的城市，城市位置各不相同，一个城市只能连一条边，每个城市都会唯一的匹配一个城市，求最多选出多少互不相交的边。<br><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_b4006094ce-1.png" alt="1.png"></p><p>条件1：每个城市上只能建立一座桥<br>条件2：所有的桥与桥之间互不相交</p><p>目标：可以建立多少桥？</p><p>对于任何一个合法的建桥方式，一定对应一个单调上升子序列，反过来，一个单调上升的子序列也对应着一个合法的建桥方式</p><p>我们的做法是先按照一个点排序，然后对另一个点做LIS问题即可。</p><h2 id="代码-28">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;<br><br><span class="hljs-type">int</span> n, res;<br>PII q[N];<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  i &lt; n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;q[i].x, &amp;q[i].y);<br>    <br>    <span class="hljs-built_in">sort</span>(q, q + n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++ )<br>            <span class="hljs-keyword">if</span> (q[i].y &gt; q[j].y)<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 注意这里因为q[i].y不是有序的所以答案要在1~n的区间里面找      </span><br>        res = <span class="hljs-built_in">max</span>(res, f[i]);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br># [拦截导弹](https://www.acwing.com/problem/content/1012/)<br>## 题意分析<br><br>## 代码<br>```CPP<br><br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/189/">导弹防御系统</a></h1><h2 id="题意分析-25">题意分析</h2><h2 id="代码-29">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/274/">最长公共上升子序列</a></h1><h2 id="题意分析-26">题意分析</h2><h2 id="代码-30">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字三角形模型</title>
      <link href="/2022/05/06/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/05/06/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://www.acwing.com/problem/content/1017/">摘花生</a></h1><p>从集合角度考虑DP问题</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_b8a87768ce-1.png" alt="1.png"></p><h2 id="代码-5">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> w[N][N], f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T -- )<br>    &#123;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>             cin &gt;&gt; w[i][j];<br>             <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]) + w[i][j];<br>                <br>        cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/1020/">最低通行费</a></h1><p>2n - 1 步可以推出来不能走回头路，本质上这个题可以直接用摘花生的题目思路来做</p><h2 id="代码-6">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N][N], f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//这里要考虑边界问题，不能从i=0，j=0的地方走过去，要初始化一下</span><br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            cin &gt;&gt; w[i][j];<br>    <br>    <span class="hljs-comment">//只有（1，1）点才可以从（0，1）走过来</span><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]) + w[i][j];<br>            <br>    cout &lt;&lt; f[n][n] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/1029/">方格取数</a></h1><h2 id="题意分析-4">题意分析</h2><p>这个题是两次摘花生，但每个数只能摘一次</p><p>我们简单回顾一下摘花生的那个题<br>只走一次：</p><p>f[i,j]表示所有从(1,1)走到(i,j)路径上的最大值</p><p>f[i,j] = max(f[i-1,j],f[i,j-1])+w[i,j]</p><p>走两次：</p><p>f[i1,j1,i2,j2]表示所有从(1,1)(1,1)分别走到(i1,j1),(i2,j2)的路径的最大值</p><p>如何处理同一个格子不能被重复选择</p><p>只有在i1+j1==i2+j2时，两条路径的格子才可能重合</p><p>因此我们可以进行一个优化</p><p>f[k, i1, i2] 表示表示所有从(1,1)(1,1)分别走到(i1,k-i1),(i2,i-i2)的路径的最大值，k表示两条路线的横纵下标之和</p><p>从最后一步考虑，两条路线共有2*2=4种情况<br><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_37569210ce-1.png" alt="1.png"></p><p>考虑第一种情况其他类似<br><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_6cb43315ce-2.png" alt="2.png"></p><p>前面一部分有好多种途径它的数值刚好等于f(k-1,i1-1,i2-1),后面一部分要分情况考虑如果i1==i2，表示两个坐标重合那么就加上w[i1][k-i1]，否则加上w[i1][k-i1]+w[i1][k-i2]，然后在四种情况下求一个MAX</p><p>走过后不用删除格子里面的值，为什么？</p><p>因为你只有在k的那个时间点才有可能走到1号路径或者2号路径走到的格子，错过了，就不会做过去了。</p><h2 id="代码-7">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N][N], f[N][N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> a, b, c;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c) w[a][b] = c;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">2</span> *n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>; i1 &lt;= n; i1 ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i2 = <span class="hljs-number">1</span>; i2 &lt;= n; i2 ++ )<br>            &#123;<br>                <span class="hljs-type">int</span> j1 = k - i1, j2 = k - i2;<br>                <span class="hljs-keyword">if</span> (j1 &gt;= <span class="hljs-number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="hljs-number">1</span> &amp;&amp; j2 &lt;= n)<br>                &#123;<br>                    <span class="hljs-type">int</span> &amp;x = f[k][i1][i2];<br>                    <span class="hljs-type">int</span> t;<br>                    <span class="hljs-keyword">if</span> (i1 == i2) t = w[i1][j1];<br>                    <span class="hljs-keyword">else</span> t = w[i1][j1] + w[i2][j2];<br>                    <br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2 - <span class="hljs-number">1</span>]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2 - <span class="hljs-number">1</span>]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2]);<br>                    x += t;<br>                &#125;<br>            &#125;<br>            <br>    cout &lt;&lt; f[<span class="hljs-number">2</span> * n][n][n] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="acwing.com/problem/content/277/">传纸条</a></h1><h2 id="题意分析-5">题意分析</h2><p>目标：</p><pre><code>集合：所有从左上走到右下，走两遍的方案属性：Max状态表示：状态表示有意义，状态计算好计算这个题和上面的题类似</code></pre><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_e3d78c55ce-1.png" alt="1.png"></p><p>下面证明传纸条为何可以使用方格取数的代码</p><h2 id="证明">证明</h2><p>首先， 从右下角回传可以等价为从左上角同时传两次。要想两个路径除了起点和终点之外没有交点，那么肯定有一条路径完全位于另一条的上方。<br>现在考虑路径有交点的情况：</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_25473d19ce-2.png" alt="2.png"></p><p>这种情况其实转换起来很简单，只要把位于红色线段上方的蓝色线段交换颜色就可以了，也就是说当红色处于蓝色的下方的时候，将红色的路径换成从蓝色的那段走是等效的（因为两条路径加起来经过的节点完全没有变）。</p><p>就可以得到：</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_28045a82ce-3.png" alt="3.png"></p><p>但是这个时候虽然满足了红色路径完全在蓝色的上方，但是却有交点。但是因为所有节点的权值都为非负数，那么可以证明这种情况永远不可能是最优解。比如以交点（2，2）为例，蓝色从（3，1）绕道或者红色从（1，3）处绕道一定不会比两条路径都从（2，2）处走差。</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_2a6e4bbfce-4.png" alt="4.png"></p><p>绕过交点之后，可以得到蓝色虚线的方案，该方案一定不会比之前的两个实线的方案更差。（当然该方案也不一定是最优的，还要确定应该由蓝色还是红色来走原来的交点的位置。</p><h2 id="结论">结论</h2><p>不论是在 <code>方格取数</code> 中，还是在本题中，最优解永远不会由两段相交的路径组成。<br>那么代码中的相关位置的判断在事实上是起到了上述的确定是让蓝色还是红色走虚线的效果。</p><h2 id="代码-8">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">60</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> w[N][N], f[<span class="hljs-number">2</span> * N][N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>            cin &gt;&gt; w[i][j];<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt;= n + m; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>; i1 &lt;= n; i1 ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i2 = <span class="hljs-number">1</span>; i2 &lt;= n; i2 ++ )<br>            &#123;<br>                <span class="hljs-type">int</span> j1 = k - i1, j2 = k - i2;<br>                <span class="hljs-keyword">if</span> (j1 &gt;= <span class="hljs-number">1</span> &amp;&amp; j1 &lt;= m &amp;&amp; j2 &gt;= <span class="hljs-number">1</span> &amp;&amp; j2 &lt;= m)<br>                &#123;<br>                    <span class="hljs-type">int</span> t;<br>                    t = w[i1][j1];<br>                    <span class="hljs-keyword">if</span> (i1 != i2) t += w[i2][j2];<br>                    <span class="hljs-type">int</span> &amp;x = f[k][i1][i2];<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2 - <span class="hljs-number">1</span>]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2 - <span class="hljs-number">1</span>]);<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2]);<br>                    x += t;<br>                &#125;<br>            &#125;<br>            <br>    cout &lt;&lt; f[n + m][n][n] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2022/05/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题知识图谱">背包问题知识图谱</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/05/08/99310_40bb11a0ce-1.png" alt="1.png"></p><h2 id="简单回顾">简单回顾</h2><h3 id="01背包问题">01背包问题</h3><p>每个物品只能选择1次,体积循环的时候要从大到小</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_551c74ddd5-1.png" alt="1.png"><br><strong>集合划分</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_5710e6bbd5-2.png" alt="2.png"></p><h3 id="完全背包问题">完全背包问题</h3><p>每个物品可以选无数次，这里s=j/w<br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_4f4c9198d5-4.png" alt="4.png"><br><strong>集合划分</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_4ca7401ed5-3.png" alt="3.png"><br>我们如果直接这样做的话时间复杂度为$O(n^3)$ ,我们考虑从状态的表示中进行优化</p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_cff80399d5-6.png" alt="6.png"></p><p>我们发现被黄色框框起来的项非常的像，首先一一对应，每一个框内，都是上面一个参数比下面的多一个w</p><p>因此我们可以直接替换得到 f[i,j]=max(f[i-1,j],f[i,j-v]+w)</p><p><strong>当空间优化成1维之后，只有完全背包问题和单调队列优化多重背包问题的体积是从小到大循环的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">for</span> 物品<br>    <span class="hljs-keyword">for</span> 体积<br>        <span class="hljs-keyword">for</span> 决策<br></code></pre></td></tr></table></figure><h3 id="多重背包问题">多重背包问题</h3><p>每个物品可以选0~s[i]次<br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_4f4c9198d5-4.png" alt="4.png"><br><strong>集合划分</strong><br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_4ca7401ed5-3.png" alt="3.png"></p><p><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_f466c256d5-7.png" alt="7.png"></p><p>首先每一个部分都是对应的，上面比下面多一个w，但是下面多了一项f[i-1,j-(s+1)w]+sw，我们知道整个集合的最大值，并不能知道下面黄框框里面的最大值，就比如最大值是最后一项，黄框框里面的最大值就不清楚，因为有这样一点，所以我们并不能像完全背包问题那样处理</p><p>但是好在天无绝人之路，我们往后多写几项，我们可以发现最大值可以由一个长度为s的窗口来求出，记得加上偏移量<br><img src="https://cdn.acwing.com/media/article/image/2022/05/16/99310_aa5fa894d5-8.png" alt="8.png"></p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫队算法</title>
      <link href="/2022/05/06/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
      <url>/2022/05/06/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>我们通过例题来学习莫队算法的思想</p><h1><a href="https://www.acwing.com/problem/content/2494/">基础莫队 HH的项链</a></h1><h1>题意分析</h1><p>给我们一个长度为n的序列，序列里面每个数的范围是[0, 1e6]，有m个询问，询问序列中某一段当中不同数字的个数。</p><p>莫队主要来优化暴力做法，为了理解莫队是如何优化暴力的，我们来看一下如何用暴力处理这个题目。</p><p>对于每个区间，我们暴力去循环就可以了，我们开一个cnt数组，用来记录当前每个数出现多少次，最开始cnt数组全零，长度为1e6+1，我们从前往后扫描下要查询的区间，然后统计下cnt数组里面非零的数，这样做的时间复杂度为$O(mnS)$</p><p>但是有一个比较直接的优化，可以不用乘S，就是说我们可以边去扫描，边去处理有多少个数，我们统计次数的时候只统计第一次出现的次数，时间复杂度为$O(nm)$</p><p>然后我们看一下怎么继续优化，与双指针算法思想类似，我们先将所有的询问排一个序，假设我们询问的上一个区间是蓝色标记的区间，当前查询的区间为红色区间，我们通过增量式的算法通过前一段的信息，去算后一段的信息，假设我们已经求出来蓝色区间内部的信息，将其存到cnt数组里面，我们现在用两个指针指向蓝色区间的端点，首先我们先将i走到红色区间的右端，每次i往后走时，相当于我们需要再cnt数组里面加上一个新的数，如果我们在cnt里面加上一个数x，如果这个x没有出现过，那么cnt[x] + + , res + + ，反之cnt[x] + + ， res不变。我们可以用$O(1)$的时间维护好cnt数组和不同数的个数，第二次我们再将j这个指针一步步移到红色区间的左侧，那么每次j往后走的时候，相当于我们需要再cnt数组立案删掉一个数x，x的出现次数大于1，我们直接让cnt[x] - - ，res不变，x出现次数等于1，我们直接让cnt[x] ++ , res - -; 我们可以利用前一个区间，利用增量的形式来处理。<br><img src="https://cdn.acwing.com/media/article/image/2022/05/07/99310_2fc8c9d2cd-1.png" alt="1.png"></p><p>如果直接这样做的话，前一个区间移动到后一个区间时，最坏的情况下，我们两个指针要移动$O(n)$次，一共有m个询问，所以最坏的复杂度为$O(nm)$</p><p>我们看一下莫队算法如何去优化它，我可以调整一下查询的区间的顺序使得我们可以把时间复杂度变为$O(n\sqrt n)$</p><p>来讨论一下它的优化思路，如果说我们的某一列区间右端点递增，左端点无所谓，它右指针走的复杂度为$O(n)$，但两个指针不一定同时为$O(n)$，左指针可以用分块的方法来优化。</p><p>具体做法是我们让区间第一关键字时左端点分块所在的编号，按照左端点分块的编号来排，如果分块相同的话，按照右端点排序，如果分块不同的话，按照左端点所在的分块编号排序，相当于我们将所有的查询操作分成$\sqrt n$ 块，在每一块内部右端点递增，分析下时间复杂度为多少，右指针走的总数不会超过n，一共有$\sqrt n$块，所以右端点要走$n \sqrt n$步，考虑左端点，第一中情况是在块内移动，最多移动$\sqrt n$ $O(m \sqrt n)$, 第二种情况是不同块之间移动,最坏情况是 $2 \sqrt n$ $O(2n)$</p><p>莫队的玄学优化：奇数块块内按照右端点按照从小到大排，偶数块内按照右端点从大到小排。<br>前一次右端点从小到大滚，下一次就会从大到小滚，这样就会滚回来，但如果是都是从小到大排，前一次是从小到大滚，因为是增量算法，下一次就会先从大到小滚回来，然后在从小滚到到，因此这种处理方法会优化一定的复杂度。</p><p>然后是块的大小的计算，假设我们块的大小为a，那么右端点的复杂度大概为$\frac{n}{a} * n = \frac{n^2}{a}$, 左端点的复杂度大概为$am$ 有$\frac{n^2}{a} = am$ 解得 $a=\sqrt {\frac{n^2}{m}}$</p><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDQ分治</title>
      <link href="/2022/05/06/CDQ%E5%88%86%E6%B2%BB/"/>
      <url>/2022/05/06/CDQ%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<p>CDQ分治能够快速的找出来三维偏序的问题,也就是对于一个n的序列，每个i有多少个j使得$a_j \leq a_i,$   $b_j  \leq b_i,$ $c_j  \leq c_i$</p><p>假设$a_i$ 不等于$a_j$</p><p>我们首先看一下一维版本我们将所有的元素按照第一关键字排序，对于i来说一共有i-1个j满足条件</p><p>然后看一下二维版本，将所有元素按照双关键字排序，也就是我们以a按照第一关键子排序，以b按照第二关键字排序，我们可以从前往后扫描，当我们扫描第i个元素的时候，所有满足要求的j一定在第i个元素前面，i前面的序列必然满足$a_j \leq a_i$，i的后面必然不满足，我们要做的是在前面i-1个元素中有多少个元素满足$b_j \leq b_i$</p><blockquote><p>双关键字排序的作用是对于i来说，满足要求的j一定是在i的前面，如果我们按照A来排，那么这个性质就不一定会成立。</p></blockquote><ul><li><p>我们可以用树状数组来做，我们可以将b离散化到1-n之间的数，但我们要求前面有多少个数小于等于$b_i$时，相当于求$b_i$的前缀和，然后我们求完后，将第i个元素插入到树状数组里面，将树状数组里面$b_i$这个位置加一。</p></li><li><p>我们也可以用分治做法来做，分治的话类似于归并排序求逆序对，我们现在想求的是对于当前区间，每一个i满足要求的j有多少个，我们可以将所有的i，j对分为3类（i在后，j在前）</p></li></ul><ol><li>i，j都在左侧 $\to$ 递归左边</li><li>i，j都在右侧 $\to$ 递归右边</li><li>i在右侧，j在左侧，因为一定满足第一维性质，所以我们只需要考虑第二维性质，我们需要找出$b_j \leq a_i$的个数，我们每次合并的时候，按照b进行维护序列，可以使用双指针算法，我们i和j从左往右枚举，每次i向后移动一格，j向后移动，找到大于$b_i$的位置<br>算法复杂度$O(nlogn)$</li></ol><p>最后讨论三维问题<br>对于每个i来说，我们都要求满足$a_j \leq a_i,$   $b_j  \leq b_i,$ $c_j  \leq c_i$的j的数目有多少。</p><p>我们的做法是按照三关键字排序，这样做的好处是，所有满足要求的j一定是在i的左侧</p><p>我们可以将所有&lt;i, j&gt; 分成三类 （i在j右边）</p><ol><li>i，j都在左侧</li><li>i，j都在右侧</li><li>i在左，j在右</li></ol><p>对于a条件来说这个限制一定成立，我们不用考虑，我们可以在归并分治的过程中，将区间的所有元素按照b进行排序，我们对于右侧任意一个元素i来说，我们要求的是在左侧有多少个j满足$b_j \leq b_i, c_j \leq c_i$ ,第二维限制我们可以用双指针算法来解决，对于每一个i我们找到第一个$b_j &gt; b_i$的位置（线性复杂度）那么从区间起点到j-1的位置就是满足$b_j \leq b_i$的区间，然后我们需要在这个区间里面找到$c_j \leq c_i$ 的个数，这个可以采用树状数组的方法来解决，我们可以把所有的c离散化，变成从1~n的某个数，我们要想求$c_j \leq c_i$ 的个数相当于求1-$c_i$的总和，即求前缀和，每一次j往后移动一格，相当于在树状数组里面加上$c_j$</p><p>时间复杂度为$O(nlog^2n)$,一共有$logn$层，每层复杂度为$nlogn$</p><p>如果出现$a_j = a_i,$   $b_j  = b_i,$ $c_j = c_i$,我们可以发现排完序后这两个数一定挨在一起，我们对于后面这个元素我们可以正确求解，但对于前面这个元素来讲，它只考虑它前面的元素，没有考虑右侧的部分，那么他就会把和他相等的元素漏掉，对于这样完全相同的元素，我们要进行判重，在序列中去除掉，再记录下每个元素出现了多少次。我们对于同一种元素我们还要更新下答案，如果有k个元素和第i个元素完全相同，那么答案还需要加上k</p><h1><a href="https://www.acwing.com/problem/content/2817/">例题1 三维偏序</a></h1><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, c, s, res;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Data&amp;t) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (a != t.a) <span class="hljs-keyword">return</span> a &lt; t.a;<br>        <span class="hljs-keyword">if</span> (b != t.b) <span class="hljs-keyword">return</span> b &lt; t.b;<br>        <span class="hljs-keyword">return</span> c &lt; t.c;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> Data&amp;t) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> a == t.a &amp;&amp; b == t.b &amp;&amp; c == t.c;<br>    &#125;<br>&#125;q[N], w[N];<br><span class="hljs-type">int</span> tr[M], ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; M; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l, mid), <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].b &lt;= q[j].b) <span class="hljs-built_in">add</span>(q[i].c, q[i].s), w[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> q[j].res += <span class="hljs-built_in">query</span>(q[j].c), w[k ++ ] = q[j ++ ];<br>        <br>    <span class="hljs-keyword">while</span> (i &lt;= mid) <span class="hljs-built_in">add</span>(q[i].c, q[i].s), w[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) q[j].res += <span class="hljs-built_in">query</span>(q[j].c), w[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">for</span> (i = l; i &lt;= mid; i ++ ) <span class="hljs-built_in">add</span>(q[i].c, -q[i].s);<br>    <br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; j &lt; k; i ++ , j ++ ) q[i] = w[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        q[i] = &#123;a, b, c, <span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(q, q + n);<br>    <br>    <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<span class="hljs-comment">//q[0]直接入队，k从0开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">if</span> (q[i] == q[k - <span class="hljs-number">1</span>]) q[k - <span class="hljs-number">1</span>].s ++ ;<br>        <span class="hljs-keyword">else</span> q[k ++ ] = q[i];<br>        <br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k ; i ++ )<br>        ans[q[i].res + q[i].s - <span class="hljs-number">1</span>] += q[i].s;<br>        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans[i]);<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/2849/">例题2 老C的任务</a></h1><h1>题意分析</h1><p>在一个城市里面有很多的点，每个点有一个权值，每次询问给我们一个一个矩形，问我们矩形内部的所有点权值和为多少<br><img src="https://cdn.acwing.com/media/article/image/2022/05/06/99310_83499672cd-1.png" alt="1.png"></p><p>我们可以用二维前缀和来求矩阵内部的权值和，对于每个点来说，我们要求一下这个点左下方所有点的权值和，只要我们可以求出这个权值和，那么我们就可以利用二维前缀和求出前缀和，此外我们要区分一下标记点和查询点，标记点我们标记为0，查询点我们标记为1。每个点的坐标为$(x_i,y_i,z_i)$ 其中$z_i \in {1, 0}$</p><p>那么问题就转换程对于每个i求$x_j \leq x_i y_j \leq y_i z_j \leq z_i$的所有点的权值和，所以该问题就可以转换为CQD分治，分析本题的z值比较特殊，我们求小于等于某个数的个数需要使用树状数组，但这个里面，z要么取0，要么取1，那我们每一次相当于求$z_i=0$的点的权值和，我们可以直接用sum来维护$z_i=0$的点的权值和<br>因为不需要使用树状数组所以时间复杂度为$O(nlogn)$</p><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span><br>&#123;<br>    <span class="hljs-type">int</span> x, y, z, p, id, sign;<br>    LL sum;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Data&amp; t)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (x != t.x) <span class="hljs-keyword">return</span> x &lt; t.x;<br>        <span class="hljs-keyword">if</span> (y != t.y) <span class="hljs-keyword">return</span> y &lt; t.y;<br>        <span class="hljs-keyword">return</span> z &lt; t.z;<br>    &#125;<br>&#125;q[N], w[N];<br>LL ans[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l, mid), <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    LL sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].y &lt;= q[j].y) sum += !q[i].z * q[i].p, w[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> q[j].sum += sum, w[k ++ ] = q[j ++ ];<br>        <br>    <span class="hljs-keyword">while</span> (i &lt;= mid) sum += !q[i].z * q[i].p, w[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) q[j].sum += sum, w[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; j &lt; k; i ++ , j ++ ) q[i] = w[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x, y, p;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;p);<br>        q[i] = &#123;x, y, <span class="hljs-number">0</span>, p&#125;;<br>    &#125;<br>    <span class="hljs-type">int</span> k = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x1, x2, y1, y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);<br>        q[k ++ ] = &#123;x2, y2, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">1</span>&#125;;<br>        q[k ++ ] = &#123;x1 - <span class="hljs-number">1</span>, y2, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">-1</span>&#125;;<br>        q[k ++ ] = &#123;x2, y1 - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">-1</span>&#125;;<br>        q[k ++ ] = &#123;x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, i, <span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(q, q + k);<br>    <br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++ )<br>        <span class="hljs-keyword">if</span> (q[i].z)<br>            ans[q[i].id] += q[i].sum * q[i].sign;<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans[i]);<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.acwing.com/problem/content/2821/">例题三 动态逆序对</a></h1><h1>题意分析</h1><p>对于序列 A，它的逆序对数定义为满足 $i&lt;j$，且 $A_i&gt;A_j$ 的数对 (i,j) 的个数。</p><p>给 1 到 n 的一个排列，按照某种顺序依次删除 m 个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。</p><p>首先我们可以发现<br>$p_i$ i的下标</p><p>$A_i$ 元素的值</p><p>$T_i$ 表示元素i被删除的时间，定义删除的时序，如果没有被删我们任意给他分配一个后面的数，为了方便起见，只要有序就可以，我们可以倒着来分配，第一次删除的时候我们的时间戳是n，第二次是n-1，第m次删除的数位n-m+1，剩下的数按照某种顺序分配就可以，那这样的话，每一个数都会有一个唯一的时间戳，至于为什么要倒着分配，是因为你如果倒着来赋值的话，会发现第三维要满足的关系为$T_i \leq T_j$ 这是一个前缀和，如果正着赋值的话，会求一个后缀和，树状数组比较好处理前缀和。</p><p>然后我们考虑下怎么去统计答案，我们要统计的是每一次删除之前有多少个逆序对，因此我们统计的时候应该按照时间来看，我们要按照被删除的时间算答案，对于每一个时间戳$T_j$来说，我们要求和$T_j$可以构成逆序对的数目有多少个，我们把结果存到S[$T_j$]的数组里面，S[i]表示的是和第i个时间被删除的这个元素构成的逆序对的数量（只考虑$T_j$时刻仍然存在的元素）</p><p>我们规定每个数对（i，j），我们看一下那个数更后被删除我们就把这个数对累加到靠后删除的数对，这样不会导致逆序对被多算。</p><p>我们要求的是删除一个元素之前统计整个序列的逆序对数，相当于求两个数都在第i个时刻之后的部分的总数，这些数应该就是$S_1+S_2+…+S_i$也就是$S_i$的前缀和</p><p>现在问题就转换成如何求S[$T_j$]，我们看一下$T_j$的性质</p><ol><li>$T_i &lt; T_j$</li><li>第一种情况 $P_i &lt; P_j, A_i &gt; A_j$ 第二种情况 $P_j &lt; P_i, A_j &gt; A_i$</li></ol><p>因此我们要求两种偏序关系</p><ol><li>$T_i &lt; T_j, P_i &lt; P_j, A_i &gt; A_j$</li><li>$T_i &lt; T_j, P_j &lt; P_i, A_j &gt; A_i$</li></ol><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span><br>&#123;<br>    <span class="hljs-type">int</span> a, t, res;<br>&#125;q[N], w[N];<br><span class="hljs-type">int</span> tr[N], pos[N];<br>LL ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l, mid), <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-type">int</span> i = mid, j = r;<br>    <span class="hljs-keyword">while</span> (i &gt;= l &amp;&amp; j &gt; mid)<br>        <span class="hljs-keyword">if</span> (q[i].a &gt; q[j].a) <span class="hljs-built_in">add</span>(q[i].t, <span class="hljs-number">1</span>), i -- ;<br>        <span class="hljs-keyword">else</span> q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j -- ;<br>    <span class="hljs-keyword">while</span> (j &gt; mid) q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j -- ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt;= mid; k ++ ) <span class="hljs-built_in">add</span>(q[k].t, <span class="hljs-number">-1</span>);<br>    <br>    j = l, i = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (j &lt;= mid &amp;&amp; i &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].a &lt; q[j].a) <span class="hljs-built_in">add</span>(q[i].t, <span class="hljs-number">1</span>), i ++ ;<br>        <span class="hljs-keyword">else</span> q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j ++ ;<br>    <span class="hljs-keyword">while</span> (j &lt;= mid) q[j].res += <span class="hljs-built_in">query</span>(q[j].t - <span class="hljs-number">1</span>), j ++ ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = mid + <span class="hljs-number">1</span>; k &lt; i; k ++ ) <span class="hljs-built_in">add</span>(q[k].t, <span class="hljs-number">-1</span>);<br>    <br>    i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i].a &lt; q[j].a) w[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> w[k ++ ] = q[j ++ ];<br>    <br>    <span class="hljs-keyword">while</span> (i &lt;= mid) w[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= mid) w[k ++ ] = q[j ++ ];<br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; j &lt; k; j ++ , i ++ ) q[i] = w[j]; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q[i].a);<br>        pos[q[i].a] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        q[pos[x]].t = j -- ;<br>        pos[x] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = n - m; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (pos[i] != <span class="hljs-number">-1</span>)<br>            q[pos[i]].t = j -- ;<br>            <br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) ans[q[i].t] = q[i].res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ ) ans[i] += ans[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n; i &lt; m; i ++, j -- ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans[j]);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL总结</title>
      <link href="/2022/05/06/STL%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/06/STL%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分块之基本思想</title>
      <link href="/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/"/>
      <url>/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1>分块思想</h1><p>分块的思想其实就是一个朴素的暴力做法。<br>我们把一个区间分成$\sqrt{n}$段，对于查询的区间，我们可以将其分成最多两个不完整段（长度$\leq \sqrt{n}$）和不超过$\sqrt{n}$个完整段。因此我们可以把$O(N)$复杂度变为$O(logn)$</p><h2 id="例题1"><a href="https://www.acwing.com/activity/content/problem/content/2760/">例题1</a></h2><p>维护两个变量</p><ul><li>add使本段中所有值都要加上add（lazy）</li><li>sum本段的真实值使多少（算上add）</li></ul><ol><li>修改 $O(\sqrt(n))$</li></ol><ul><li>完整段，我们要对于这个段的所有数，$add=add+d,sum=sum+d*length$</li><li>段内，暴力，枚举所有数$w_i=w_i+d, sum=sum+d$</li></ul><ol start="2"><li>查询操作 $O(\sqrt(n))$</li></ol><ul><li>完整段，累加sum</li><li>段内，暴力每组求和</li></ul><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">350</span>;<br><br><span class="hljs-type">int</span> n, m, len;<br><span class="hljs-type">int</span> w[N], pos[N];<br>LL add[M], sum[M];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pos[l] == pos[r])<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++ ) w[i] += d, sum[pos[i]] += d;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> i = l, j = r;<br>        <span class="hljs-keyword">while</span> (pos[i] == pos[l]) w[i] += d, sum[pos[i]] += d, i ++ ; <br>        <span class="hljs-keyword">while</span> (pos[j] == pos[r]) w[j] += d, sum[pos[j]] += d, j -- ;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = pos[i]; k &lt;= pos[j]; k ++ ) sum[k] += d * len, add[k] += d;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (pos[l] == pos[r])<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++ ) res += w[i] + add[pos[i]];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> i = l, j = r;<br>        <span class="hljs-keyword">while</span> (pos[i] == pos[l]) res += w[i] + add[pos[i]], i ++ ;<br>        <span class="hljs-keyword">while</span> (pos[j] == pos[r]) res += w[j] + add[pos[j]], j -- ;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = pos[i]; k &lt;= pos[j]; k ++ ) res += sum[k];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    len = <span class="hljs-built_in">sqrt</span>(n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br>        pos[i] = i / len;<br>        sum[pos[i]] += w[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);<br>        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;C&#x27;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> d;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;d);<br>            <span class="hljs-built_in">change</span>(l, r, d);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">query</span>(l, r));<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块之块状链表</title>
      <link href="/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1>块状链表</h1><p>把原来的序列分成若干块，每一块会用双向链表维护，每一段长度不定</p><ul><li>插入一段 $O(\sqrt(n))$ 首先分裂节点，然后在分裂点插入序列</li><li>删除一段 $O(\sqrt(n))$ 首先删除开头节点的后半部分，然后删除中间完整节点，最后删除结尾节点的前半部分</li><li>合并块状链表 遍历整个块状链表，若下一个点可以合并至当前点，则合并，该操作是保证时间复杂度的关键 $O(\sqrt(n))$</li></ul><h1><a href="https://www.acwing.com/problem/content/949/">例题</a></h1><h1>rope</h1><p>这里介绍下rope容器<br>Rope其主要是结合了链表和数组各自的优点，链表中的节点指向每个数据.<br>时间复杂度为$O(n \sqrt n)$可以在很短的时间内实现快速的插入、删除和查找字符串，是一个很厉害的神器！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ext/rope&gt;</span><span class="hljs-comment">///头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_cxx;<br>rope &lt;<span class="hljs-type">int</span>&gt; x;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    x.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">///在末尾加x</span><br>    x.<span class="hljs-built_in">insert</span>(pos, x); <span class="hljs-comment">///在pos位置加入x</span><br>    x.<span class="hljs-built_in">erase</span>(pos, x); <span class="hljs-comment">///从pos位置删除x个元素</span><br>    x.<span class="hljs-built_in">copy</span>(pos, len, x); <span class="hljs-comment">///从pos开始len个元素用x代替</span><br>    x.<span class="hljs-built_in">replace</span>(pos, x); <span class="hljs-comment">///从pos开始全部换为x</span><br>    x.<span class="hljs-built_in">substr</span>(pos, x); <span class="hljs-comment">///提取pos开始x个元素</span><br>    x.<span class="hljs-built_in">at</span>(x)/[x]; <span class="hljs-comment">///访问第x个元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次队内赛题解</title>
      <link href="/2022/05/01/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%98%9F%E5%86%85%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/01/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%98%9F%E5%86%85%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splay</title>
      <link href="/2022/05/01/Splay/"/>
      <url>/2022/05/01/Splay/</url>
      
        <content type="html"><![CDATA[<h1>Splay</h1><p>平衡树里面有Splay，红黑树，treap，AVL，B树以及B+树</p><ul><li>treap好写，但比较局限</li><li>红黑树系统里面会用但代码太长</li><li>Splay代码适中，较为灵活，可以处理很多有关线段的问题</li></ul><p>首先Splay是一个平衡二叉树，但没有那么平衡<br>先讲解下左旋和右旋，旋转的目的是在保证树的中序遍历不变的情况下，降低树的高度<br><strong>平衡二叉树</strong><br>定义：二叉查找树（Binary Search Tree）它或者是一棵空树；或者是具有下列性质的二叉树：</p><ol><li>树中每个结点被赋予了一个权值；（下面假设不同结点的权值互不相同。）</li><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉查找树；</li></ol><p><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_9d84988cc8-4.png" alt="4.png"></p><p>二叉查找树能够支持多种动态集合操作，只要所维护的数据集合存在偏序关系（简单来说就是定义了小于等于）</p><p>Splay保证树的高度的做法是什么呢？</p><p>它会在平衡树的操作上进行修改，核心在于每操作一个节点，均将该节点旋转到树根，可以证明每次操作的平均复杂度为$O(logn)$</p><ul><li>插入 将插入的节点旋转到树根</li><li>查询 将查询的节点旋转到树根</li></ul><p>接下来我们来看一下怎么把一个点旋转到树根。<br>我们定义函数Splay(x, k)将点x旋转至点k下面，Splay(x,0)代表把x旋转到根</p><p><strong>左旋右旋</strong><br>节点 x 的父节点 y 是根节点。这时，如果 x 是 y 的左孩子，我们进行一次 Zig（右旋）操作；如果 x 是 y 的右孩子，则我们进行一次 Zag（左旋）操作。经过旋转，x 成为二叉查找树 S 的根节点，调整结束。如图所示：<br><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_e554a3a9c8-1.png" alt="1.png"><br><strong>情况1</strong><br>节点x 的父节点y 不是根节点，y 的父节点为z，且x 与y 同时是各自父节点的左孩子或者同时是各自父节点的右孩子。这时，我们进行一次Zig-Zig操作或者Zag-Zag操作。也就是xyz为一条直线，先转y再转x，如图所示<br><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_2c32fdf7c8-5.png" alt="5.png"><br><strong>情况2</strong><br>节点x的父节点y不是根节点，y的父节点为z，x与y中一个是其父节点的左孩子而另一个是其父节点的右孩子。这时，我们进行一次Zig-Zag操作或者Zag-Zig 操作。如果是折现的话就先转x再转x，如图所示<br><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_412fd6f0c8-6.png" alt="6.png"></p><p>考虑插入的情况</p><ul><li>将x根据数值插入Splay首先在Splay遵循二叉搜索树的特点找到x的位置，然后将旋转到根节点</li><li>将一个序列插到y的后面，先找y的后继z<br>第一步将y转到根 Splay(y, 0)<br>第二步将z转到y的下面 Splay(z, y),分析可知z是y的右子树，而y的后继是z所以z的左子树一定为空，<br>第三步将这个序列直接放到z的左子树上就可以了</li><li>我们删除序列[L, R]<br>我们先找到L的前驱L-1，和R的后继R+1<br>第一步先将L-1这个点转到根节点 Splay(L - 1, 0)<br>第二步将R+1这个点转到根节点的下面 Splay(R + 1, L - 1),此时R+1这个点的左子树就是序列[L, R],直接把左子树置为空子树就可以了。</li></ul><p>下面讨论下Splay如何维护信息(以区间翻转为例)</p><ul><li>找第k个数 size</li><li>懒标记<br><strong>两个操作</strong><br>pushup()维护信息 旋转最后<br>root-&gt;size=root-&gt;left-&gt;size+root-&gt;right-&gt;size+1<br>pushdown()下传懒标记 递归前<br>swap(root-&gt;left, root-&gt;right)<br>标记下传，清空</li></ul><h3 id="例题一-Splay"><a href="https://www.acwing.com/problem/content/2439/">例题一:Splay</a></h3><h2 id="代码-4">代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.3与课后课程笔记</title>
      <link href="/2022/04/30/%E9%A1%B9%E7%9B%AE1-3%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E9%A1%B9%E7%9B%AE1-3%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5229a06fa60dfe75dc3b0d0ae19ed73588449cf70450783af16d7bb9cca82b8a">83bc12dacc7a0d781bd8e05336f2838bbfdc5b331fdf895a8f9b5f00f6cc7bd29e51cd8d9a26436f29e8fd5d0bbbd4e3ac7a610dfd7b96f982cb7cf00fb01d60c8c985df41a22e64d39d28269d6c3929c0df6f314ab6fe5c64207ae82fde90edc49b42b3018e1a1a1ada0693b23e1f55a528d46284b4371f122880cd161192e02b00a1331f269e8e9a0d691446f3d7218394521a778e810bf867298ec43bbb00629860f657d60690cf51a58b346c8f8fd9a699ff9a9ae3216f18df021d74c951653c6392d40a119dac8170dd1c52a808439af7f9e876fd32fdf473cece35baa3d58ed82d985fffe07f8c5282dc95eceea3158a665d777e862f85a6cf848d1de2b5044e3625caaab987fc67da1572865a79b2b5148299da7554c4b641d2952c17fc1beff527c0eec120f18180333b9a8f5253afdb1fee1a8f62e76b3e9635d1d5a8fb9a36a4211e233221374ef5ca23e68fbb90b4937750fd9f9b1dd1396d0da9d2ab68e919083947db7a30082b15782de3e8a791b420f3a0dea939d32a02384525d7cf932bfe433db6564b1879daab567e3accb46fc9ba5755489e7d62cdc3a8285b77e172ea4c1f9d96453edd937a29921a0e04c030111bbffcf99d7b120be5442a974deebee5a7bdb88c47ff46a1d16a2ff90bbace15a61e65c6a83bf7bdb36870a68ece7f9ca50b45216a97ae25727e7f9142c67d48d37101f4e9f8741b96db0698e2dd74e4f24986fdefb25416edc40c38706f9532e03df830a26292c07025a1af253faa602b8488f534da3ad1313f8412c844fb8598be900a4cf29675476b32da506f3b7b51fcb8804a37ab698c2d830ad987f33b83423b39d4b66888495adc1c7cf27e37ce0d9900c927c29a2d97d928311d78c239498d95c791d3f929e9462518b49a9fc9cc98fd86c0910364832a02be34519fcb0627c9bea81db858d7a4441a64d85bd59228bf9e73315e5b4bb92f2b934436a97db5f9eecd55751e87bc4d79aa36580ebda0910ad3542e3bf159a5432494f560bf225712be76addb99b21ab73167d236cc210eab9a57a8052f1dcaaa8bb80b500425e02b98f7bcc6b325b47201e291d141f0ac63d8c009831d5557a4a632a4e1d65fa5a81a3a97f087bc71c12b777ddaa2d1f32fe0a487df687871f259865956d3e79d8ea17f0faf616b7c0fa6515763575a5f0f3bf3f2adffa5db81f58fbc06de7d034d8852246f6de0c2a105b6cd128953758d9b0a1c6e067c0b31eeb9866ec764877593d2360f5809662b988d5fee4749dbbcbc4c140d00271a8a253e118aa121e3ae70653a053c7d4f77e83cda45454ef6e5b27cc9af63e04a4bc084ff86a898182acaf80a37b225319208efeaec0a4cc4e09683134d7c382c26fa2df55fe8aeffc05dfaf8776a72226fffbbcff662438ac0895d06942e1f92d0816832a3af7b06c43a1a30906139e80d00416580da9c1f15020e498a9dadcdcde0637b63af40089f99b64bc15f08ebc4885dbd2bc1b3f4fa23fe68b38b322f22ddc245452672c233bfe52f3d871bdb1537fbec97433f5f05cf82f381ea62445dc6390c2de250066af6056351ccc658488d153a6afea01ae34a2f9b1beae898df9f2035ef31763848866c21ada7e560279bde07bbd0b5ecafba8b52749d5290cc9751d6193d69f1c53c44fc2a356158bcaef84971eb686ff129f65940214212644a02a86683077974627c45375c4a43ef6b21b7591473b61476750ab6039f9b41fa2a96cad19d3156e1e5d6dac5737ce0de762bbd27f1be2c98e45bec4fd6935ea5fae7b04dc8f0ae68c574c66f90344725e9e467cc41b188468e904c443c5a817973cd0aeb20eb3417917f609a36cd47da7a32bbf640d2d6bb1fe537fc540ddaf311bd5358be6b9a796f6d60f3d95938f0281a8dfffe23386a8ccdf89cebb36e0ecdcaf35768ccaaefb06e3730442906122eed81c32ec69e89bd786f592d83f288db832c6dfbc35038e372d36bf43e07aa4ba0cbca90b9f51d05540ed037b7a4afb58bbd3549d460d0f63e1c6b4d736d1105fac121f046498e2fc6b332d2b5a62c4161c18cd236bfcb8c537b32cbed89c2f22ef064beab1bffa10dcd2158d1fc3ee8fa61f1f188e2e9bedc4e1b517811962c81a89d3d89d85e4a6d6d858c7ff02f377a82e262d4b690590f1b7ef783ad577b8c1d88e6e358c9978db61d6066d773f5262e74c158b1ea174eb20d6d2e41154f4a45d4b069422f47b19a65854da549e3f262b507ad78ac25e8f4b55b7b8c2f6384ee669c19ffe1f14dd713159b3cc304cbdce48c42bf66b84215a3639dd331a67e362fdef3604dacb8b2a3a78d478f4bebeedced3c2d7be4cde6512e1100b965c3bedf7345319f382a81a183af6f27532cd70fedc2e0f9639c9e0a9517a79cf40b1dc91ee3a99bddc9b187ea58102f6425dd3d31ad72112d5b8d451d70022f0dfb416ff0040dcda6b8b2765cf937db2d47dec7f549ea953f0e379d7bdcdbae9e8f90e5d2a12475542e7823b38d7aa677662354374e2e0c38b9c1824a20df94f3c9ceed7381c4b8280fff012cc34bcf4c9c72f0c1cd83f62402bd928d37ad56c1f8831f8f65ac913535a6d5f3a7944e60b5af3ebfe0c2036302c3733f3669466667b7c491bda483ec34cacec12342216d2068e1315a7a8634e25e93cd2a3037b3efe976ba1f8ecc1d8ca988cc26bbee814b2597bf9586762b0e66f6fc2558e9eb5e8be94a925b476eddb957d6d96c6341c07b3d3ecc9b02a94883bbd1e06a52c5d7345f36d2715b0605430d9cc9bdfa759eeadd2f16bbfa57a74143a21cd83b1dac469112c6bd8fd17df496738da2ff08576f1b630f7d69cf4945251ade5654b4f6794c2c047186a49d298c8521636a36b7eac518e05c6dd3bcff08acfe814e01d47b26e12b10d36d96fbc8ef6753200fb6b506c2634fad70f67ab27fad46f1676f8ad99918686178cbbcfc77ce622df822e8003d852d387b7c1ded959a491065fc1e814d11c93810ac6396a3badfce24fc0a57e762f5ed198bcc5c3f36d38c6cfd52b2d2fe4b5525b1f17be65eb32f33964c2c8ea7fc7ac18cb7065b3936233fe8518c785a70b3547c32b2a6eff8064585f6b926c5caaf8b8ec188013f8e9c1304c8cad93c3745800ac3f1200d5daf65f513f808d00b5baa58485d5bd52e48d7be291ed708587a5b1bbee0c2f16c2831a6ac9c6fba100578bed919fd0b5b52a531c71723a36535ad55df765cbbb2e1ace8bf6d4f33e3cd67bd912b34bfccf96e72392130ecd43bad85f06a3618cf19aa088146748449b5bc208fa2c13669ad325f83234c5d5b74ee199a0d959ff4208b45afb6c70e1010e71264b48365847aaf17641b203901189f655da7719a9190fd65392b2fad884608fdcfe87102786a67233e9ff44d1ccf865f34d1abca8774999eab3aab9cbaf0683f6a697eb1b88b8fa3ec982a2caa5c38841ca775149986e8d7ded32b47e18de8b0c00b02485e3f6e7207330e16f44fb1d5180621849538c29f817ade4b9fb109ebb2c6c32c45ded20ec399af4fa83bfa69433b6f4fb4513e8f9c2142efec3da6c40d9b214ffbb9533732149fa761204fe76a3b78b1b498e262fea239bc6d0e71cd0414aec378846891b0e9b42f1e6cdbf516e329aec132124de6d93e970192247932f2ec678f76b4775c0596c681290215d9eb957f73f769d7051c5f0a12e757d33a8930c0ef9163a7129252f299b284fc1b9ba001515f06f6b05e8831de8f8d806c250795b3cb6655cdd6333935e08874a15eb0a09d8b6c2da09c44b8b91fd244fa6f62f6b235c36627afa9beedc6e4505e60412331bfee9561c3ca8663f2ce5db92439a06aa87e80b33ef24287a2823a8727537dd187a4fbf11cfd47af578e2f3a697dca10c65896da5edff829419676eb57ba05f0dc8d1be2004d6526ce801f31567dcdcc166a9ed8ad622c206121d0ac38d26d2fd22f8c602b19e0010c10df78c196800ddf8b7880447dcab43a309597017960950ed6514930b5249547a86449a3a0d4d5433566660670de940da7b51dd505d903e64ade76ac4c8e7cbc58fa71d2df3cd2de29cd651f08708000bd8a82c1ee3956af9f76f48e86327688f7e5e07bcc90f0b9996141b5ff83221eec2249cb7675caeebd4a2a0291eb04e906988e4e02e157004d3fc213e1cd0699a3521bf048559b942e193adf60dbf313e7303cd1c39584d97a54a2e5320cbbe5357274063fbf6ba315cc43458423c3fc86abbd3d085f057c34a7e2b24c4f5070289b279bd2dddc964a2862c53bcdb9806976d8b56e7762a224e6e0375e8459fd688b4cc72aff4d175e90e8dad4c5f2a9f63f04e885e2fcc8045ee210ce4faf29c3f2fd705f1d6ca4f7e1633cc78e249de3208c68eba6cc326e99311a9a41fa7c37e97c66a09b6664c68ec7fadc1a6a63373692d4f9c5b8ebea6b985333095fa8314c05dcd9d92b14ece4ddf66ca14824a1dc5945ecddde51754c929caa620c211fe9389cac50354f86299f3f1da2d4f2d9574e3508848d7f7b9949a83ca5d40950f5fbd815ee1d00515de57dea8e365df634af64da0c97d79705b48acd71f20da435ff0a799cd3049d43007f44e8b0c308b7a7e1b4d17e88f6b032506a54515772eb8603f1036b2c66b1f15a1d90908e2321eb52f51fd6bddae643dca14bd78c72297164b22362d05f74bbc33b52277a0f8f773a7675d0fc126f7650bed86743b1be0404f4041357804387569c88184fc535c41a7d8f9ce7aa622fc3dadd7be6915e49b8a1a7723886e14d063f325b443843ce022ee86bfc049fa9c2c4e02255f8b0e7145ac6535b22a04ff496e7dc868e0aa9d3731fc0900752e72db38581c28354a2f51af56078984a55e1a37b42cfa3ebd82a99762a13107f818b76cfe4f90ce4a8344363bff1ea42019acf234ab92900344564417e73a2e0ef4c2a5af1fad3bc2820fe0b37f9e49e484d518e44335f7ddcb677d4f534503c5659d9c9f40f1e754ec886bc2c17806ce9cdaf4904e57374451b5e651ab22f4c542dcc2ab39797d244095e9add539cc9830014a2f99e6a372ce35ad64a737c6e7016b58208a3c9fc90c2d846d667131bac82b46d4a633ff7b315a4fde27871de0321015a354a636c4b8c00e132519db69c012f0bb38873188fbfa89f7475821665bb6f782803110ef42eea340d93cb2a0918981a81e2781496f75f46b845c5ab0fc8930270b563f91e05fa89bfecf724e315021dcff0855702d14653038193692c49328a13c8db78fa7fba8947ce680bb3c71c8f852e9da5aca32c14d13ba12ee2fd094a740fc0e1619cfb9959fac2ad728cbeb0693dfab4c0e832e17f99bb893c2a4cd63ab6541626d6d8177b3cb15e13a4202d654d03810feac18626067b3fe0592df71853f3cd88ea768f27bd26ee10afafabcce818457a97573ce500773bcc1d2406182186211786a5515bd33ca146eba746add54081f38a7d3f151ecb5e1058053d20495585470cad90c2127822e2e13028e6a3c251bc6201e8ff052b8f8608d806a0a359005d84346c99fb51122c5fdbc6fab8215e15afa96849d54e11a7163beecbf3e8ffc65ac268aa339ea1dfa4f4620b5330f73d0a479419859137daee4032cb991789af42dcf9dac4bf4aeabd6d44cb6c7a1f934b516b15251481e576065809e3db360a6b0ed9e7a745bf743944cd5fcf174149e8314c274d4f44b02b00afd24653a5cee3536075669c04d35ac9828fcb19be0ba613b5679b044b9dbc7d6b1cd534dffc17bb28e6bf7d7a42f5d30adaf2a095991a70f4edee74d550adeb702c42c58d7eb64d0216f2733de1fb6b4b677c49414da6609e390502aeeae0f260af19eaec2695d9b25f9e376b885fd01730fa57072c2798fa02eb0d4961fb2b0a55d0f3888a9abc9a8ac01780d7936ae1a332dc68ef601e675144f32fa09c31678c2937135795ed19d033890a012168557a1bb1a1b4618f1813b0d2fd65ceabb1f9f3d1f3739ca2bfa2b303e7e42a138cc05a57cb90fceb7d15a513c680f0307230977feb3415ba22001aefba980a8e29ad261f0259a761fc9b29e6c88f9b177f346216062f21496868c0f4394d0babdf2717bb54de3e99576c4013fff9d64d2bb96b4ebe62077169207c26bd72c72a866c041f046f94cf2ed117be0f6bcfb2bf6e6f74fea0ffb1ea9a7501edf4f83b7760728b72c93768b64e7bb970d8f258725ff680d8710505b7d0da19d2b90f3f8c7e5fe036886dfb46851fc32ac6bed9f1cbdb6b9ae336c5c8496e1928058c42176bad36db420a9e201bec169eb8ea3ed9cdd087b6e2576172e21b5366cf721428df9265098ddb95571d73e8ccdac16b29f040f710f4e039710cc44ad2148ddd4829748b115aa2bd53ee2e5b38cbbe9c39231ebb0d05dc5b3013be3713a33789fa77b298985d2ab9f3d8da34d81cad2c45ef6f006d74a8a247479a00fc2d2c6e9b9234b833378c0441604eaa89bc10761c581756ce24506d851af7ca1105bd9e16065e160a19da545fe02658d88a80c63026b303bb2bc027d5c022aa8b38867b4241ceb8342d136e08a85334aebd5b5bd75b0d3ebe33dfa04e1742a8b111826c4e61363944e7ca6d01789b0a2ef9660c697e898429b8bfcc99afde4d5ade0ef235bdca3e2e5f3e218b3fc48d07f974858ae229808d5a5f9ada88d93d43acfaf57f50b5a8a58907d16a7b76cd7b394db6e12738ea20de3a22e2c8d88e50552479d0f57d3169615c1600fdb106b72ee3e43c73bc8d1e2a0ccecd76126fa0b3abbcc88571d38e6945808f6c80e2b3ca750754a59df97006b4194954e1803927305edfeedb4e02894c4cc3cb3f186e61d0d2a42bcd09a8cfa08bb0bddf35f16e834ddb666838b95cac9d6f7ec1f76e1ae1bfbe17eb54d6aab89625cc9b708e1921eeb8f29937c2418b65aacb04d8b2f5ea5f8f410c877ea62cce5082f861f1f6f0045951999569eadd88e6580120dcfa688b57b133fa8672416a8d4da9efb1e960b8211b7407e05ee32784de127b4ca87b140254a76069ae0ea4d60f3b5c369dab1f04da486f95bd26b774029bd7448c0c0b7a07a4978cd0b9eac2403f8e8da76e5828ebcf58913fc56051aeb60032fb6e19b22e0b1aa349ee23efb82f632e2a6d871e9df415f23fbc68ce6e6c03b73b0fcec9a92aa4af2d98c506e07569f7b4b7f2b5259f29d5f9f9407fe499fcf577ab072e621109fbdf1b8d4fb79c5a10eb150f63be86eab9429c66e55899d73c33d9e91f858ee34ad75f93d9b01a03ebf9df18bd5ba93be07f5a1f564ce10d9436798d83faa8e9489d33f00532f34ef40162065d05374ee90b9ffb92687c3fd772f622d856d40031a0df964e8ae8c1f98d58af20e3db3be44c1f046576d5e36f0a4c68ecd81783eee00f605a5e301e580575d903a313acd981be3522de7bdd372a84690a46dc2aca32559e6361250ef9290b937371fe629d7db6901d1c28abd27a7571454c73c00f5685f5e5d811b97b367c3734bf9ac0222b1205c3832cf4c2b47fe38b62e2380afd862fc9f309f45bf9a33e570df26deae7b043353a64e02ca19e1df8cb356618160645813b38e655753ac348d401a462d09badf460bc032c0726018cb140e81d1281b561ac3edbc486952ec58e02e967f4c69a7bee7112defd3addd68d019bd0e25e2c4f8546b5a37146dcc14cf5be57d8787f6a3e5bf8080eb934f389bccf7c173e36ff65d683f2da0c0720d48a8503352da50dfcb45394b7f2c4d1171420b62fd81b50613f24814a1341ef9e1d177782db10b3ed6c4edcd7f368399e8067d99f17963988924778654738701fba8e90fe099ff19363fe666a8b49a6963be1c0b0676d1baa432f83d01bf6f7a22200e46fac3627a32e800e308909a37b522a3d19c9752cb5fed0b9f0b2bd15beb66f4e8f9ffdfd7fa9217c3881b21070c17a94eeafff05bee7373338d11fe5cd338f1f5fa8fbb823ebdc696c7fea91dc92b171b50ed5b205663c4fae3e9ff1f1b43f9202a5c21d675f6ec75e71720f9fc882b4471e1705f9e76ff4b92863559d5384795a6fc487294f98e76198ce89ae304530b111148561ab1d2634bcc1cffd2b90c6baa8a1288dd096aef60f68371061e78446e4bef6bd06c151ee6e0f72a051edd47b9a4dbe871fb40cb73e78e1b5cc55c573be8591fb125f99eee23ea1eec21361f28371995b1b8a626863f4e784e7776ab86882b20f7e7655f374f0a7101cfda9d1b890f2045d43e3f0558aa53887ffceeb19c03613fe96421792555e29f89600c1ba6d27c547f5b1860316f46ad19b1038914cedb9dde1fe9cc1c7085afb32afed6edd6b121d9fd73db3558a2f2765ca8770a8871b1925bbdc72dab082b78d09b4210df8ab87b83030984640f7dd4dfea56427429bbbe00a3bc3dc9a78a2cd8d1d62fc7e028123c400bff7ae589a4a15d1e4a5c969e20abeebeb8c1bd354809acd34c522b4fbd27d058c2e6eff500005bfbd359b143ca240d1347bf3c004f9e64a4fd27e6ba50d30a7b98e54fee97c7d1f311a8db041845d4b1964302ba5f02e8cc37d8107ad79cce3efb21c3d07c7d82360af04be81f9de15fcb796f3e3af9d610ac826c877d1d7743db8dd448a55eb8c554ef286dada50da49ee761987fa415ee0f7460285655d682031a62deb488e377633ec0ba2b07002387da46d647b71eb91826b0150125cc5df57aa173337c1a3e8809f4aec307e905c6ab4a5e3bb98f9d363fa60a49f89c7df1825bea1dbc7e43f8bf0929a75850a6b10f925db6e55e894d464c76b97a5802d9a7a0a2226ac57b56c6540fc274225425e1bc00ebaf3d556f111c7f9933a7ee3a09b64f6aa40fd3ce2b5323f1da3056eca18d24d8d53bb62dfa8332ac6ce55eecd17c9c3d173a6b061915f54da24e193883ce824c61d07948ac65fb16e9e058e5d2a22922560eefca12af7b3fe39f553535b1e7ee46c21106a00b10ffceb28c5562f5cc2b126d73b82b19b4b26904e5aefb0728855d97260ab0f05ab3debcc08233f8f688abf39d0357c1604f466b68d5f7e7529ca964ac413d7dded1fce5d249b35160d35f2ee37d0c63d540d7ce469a7593d02c649272caa567dba112b19a15d62eeac30ed8f832f99ced4e59d744e24c1359111f4a9526dfa35b35a3bf404d7587b5ecd731a10affdbd2b233438302caecd60aa34a41487c9e9115893ec3da9b28509a3ab2eb0b14ab938647e57e91496a36a5f6965902ce84b1122f932031c4ac02053a43d838c203e4932aae45693449f206e8827af2ea43a4cd0789752818fd575db49509c4d27346e1f03a8dceab1aff7da37eae55e91356766b633f2038693504df8f3508df7e98abf96968faf66a6cd66b92f03fde553c07eeee8257c2bfde9488c4de2da63f9fdb650cee94687a6691c6242c8a05551c0d61aabd2750134986f482c5acda85e97c33f3f9977fef9a04b2eedba6adb0377e83d9a270152fb0f63e65c17a006d8831e5733d9173db7f7c37815391919ea1d51c8501371a28c98b23dc490077526b30419de37e8f4f5f9eb798492618f492a53059ad2286bc6d9819125f448b77ccbcd3d40f3306e752e4ff48ec8cc54774f40f3c66b118e82a2373b7fa046979c07dd874e62c410dc7c3ec51e296da6d36f0beb50d10d0bc32233cc22996ebd40d35ffd1a3bf659bd662b25031ae1dad217845e23b76ff3b148d2c1b2f20dd5ce2ec2a22c205d9d122fbbfc7261443b41fd6b68961d07b6652154727c5950b67a2b78c487ce3c367b31f5e409ae5ddf2a6e495bea028d514eb886974bb8a4657552c49f615ca5fa0b11d32fe6fb51a8029f0953c796eb2529a2f3e5de55938360222e97a8c43032101a9e0cf56415340249e88feb1f6f359e12da722e453e08d48f835c5ac68df68e8be7ae51a210a1125aeb2c9e35f0b06af811a388958c9ae2975f8d680c30751ace95cd7fe1f3a80a3a9ac35d1d759a806385ad12db3e9ac63d78526e83d4acec6be9b21bd9bdf85b2dc5b521088dca51993ec78d115de22eb930b9e644e5760b9bd968dc41a7e00996595c680f96f11d4542c594687fb9fc4c94f956d6796ebe231380ac95d094c31d5fe7b69618a9494fb0a7a8b6909b6cab64d8f344986e8fb36d3f72906682fbd99cfbae81bc28d48b718a28842d7c91f98b604865e69163dc864ee133cc8a9b8b64b67f3acc5880a91a390bb7906d9671c45b325b6aab677060a4eb301df077a54a939f96e3845681ff0d4a603ced17958e42d3f45a95174ef96a629f7d7a1fc694a13a2baa61a0706a8fbc948245154307f5e88562b080208dd220391c3ee2a4cd64ff91eeca9d3c17343061c8996b4120187ad937e709032a2e76e0f92d1399674716f85c4bbcd9c0f70f20303ba593042b25799e52096ca237f2a1c81b87c69b79665697040cc27379e141ce27f6f459e580af7ed9cc53f5e31e4231a7661699312d7510f76ecb4719436053a51fd81806fe29f2bf6e7cdca73cdaa1d964ff945bbb95b7a5686ed8c77a149d820875efa10020cb80e3f6babe6979e1eb14dff840685761db1ef4b200f163557449e43d0a3fcb5085998d90b7e235414d40e44fee5923ddcb903cc483c84d769302bfd1da55ddea68106096b9ce169897dcc62e29867279ade70b29572e15631ed5f3ec4dce95d5ea00b81567ec0f81cf6714ed16962a343018705abc036f58bed67acf6771eb70759fa27b80fe8891c80f5bb58d605ef681ae1f83dd636b26cbdd201f1e0a206e83010a6311c2d60150744373ec1f4cd1197f4003cb31537c82dca896386146f14af09b031b5c8a3308f294ca8c41df04b0553e2f75cdad5f5e06ef6db2bc6c18d2d6ee61f781a2db8cf3c9bed71cf7efc61f9d2d48c3d505bc8d56393c5b6521dea4f8ba4bf7e37d7ba8ee5877f28a74460b1b3dbbe82eee6e0f0df8623f9ab1f89b111478527502caabac44a12cee61a09797af98380583168375f1db859637803a486844271ca2779ba365e1659603633aaf496e5fbbd17e339bd77a5b4e42db0a49d7b38ee74a5cc89b28ff741fce20b09f47aae2f95e7ccd2bcba6fb68cf582aeb241499dcbcbc4f7645e7fe9e3cc4311fa5d0420d8fa187019b49fcff56e131e426ad0d75e7795b297fe2f8be9bccf2f4251539e40efa0f6ccb3bd8a0d7b7af4ec5fc193eba19b6973690fd05ade1b4f021fe98ea82ee80591a99dffc8da321893f5d63f2490bdf6a1ee75eaae436a4711d49aed46622333d6a21755f5e454d8999f3c31c7b5eece29e3d57a775efd3744c4593369a8b571ca4f2ab93af637a65392d1d3c6f22991fb9b986b77daab53efcaa36dd01e84feda8793a56f16c12c87b46c8baeb64f4c349b189e0939ffc3270484e807f3947f6f8c99377e05435b7fff0a82d8843af8577bf370b325d33efd2d09a5308c37e45d2dd8424415d85d696692a82054c4e6755c05eb99169d767f5cbaa55a8b24d465dad3f7db041d353c3c9a73e1556fb4be1d6bfce3e5714f9dd98d24b42417142e0d1b2e3fbf0d2a057fb122267455290b2a91c81eb442be7751d1d3f10683372f8886a8bb6a7f34e200a2086f24fb3891cd5dd68f91aabecb82f416070262295dccea7441af809fae3a84927032771035b75bef33682e8cd0cee7e9552200ce7f9b9b828b1b9741b43aba1e384a77e89f441edd4d3305554143755fb5e46d7de7923d405066915025f78eaefa37cf9c701816ac25c2d3e5103f40490a858eb1f14dc93b0572017f759be69a1c16992b4497d8ce0df98cc6ac0ba310acf73efa3e64a2ee1ed8e94159c03fe69b5c7b233938a35b05224ab035b3b082f8612e43fd0e4890427d0c50c3095f327c5f863cd441db150cedf181e93837a5a590dbd860de79f9a5be840a3edaee8e741cc5d6ba1ba1d0a8a0f1d6c19948256568c95ec9edea7ce8e92dd1635a43c1df7f9b44b6924de5134d509a7e680b61cca74eca4b39535130a93ef3c751a3faf1c3522fe0b1e9e1ea454e0b962e712d512a71d522c4a4c8c69327196d9cde9a67c4c79c00b1f0f7c4543fbfb61a40d58432f3a6f79e1fc6622e1a1b06264e8155d57a6ccb073088ce3fb52f6b6b91bfcc0cc5af18ef57c90be9feaacf0069d97d0ce3bc53edcc693b864ea72c0706103465e7bda9f586b2699ee784033240af7b6b25cc4fc9b211f3b0080d4a879b324476ea6f08b2d8846d26d2662711558a74aaf1c334ba5c60750d18a83871df08a811ef89868b6dc093896df7e198a862af2f0869cb68a778ae03714e342f96d6ade155a1251e11037a546a8f37255113320f9a72c981cee17a0718a4f5579b09676c5da25a6e5f8cb0792b54f4ebcd014505765925c973c15a7bfc4781b92baa94ecd8e148be2f6fb8c644949357f98dd5968316c05486a7a41b03fcbd58b4b425cf3776ef838d1609616bda17c7819f928b1c01f46d8587a78c6d8d7497a77b70dbe1f0f3d8ed0cb0791d518e84c904fe518d312ae7dc59c0b32dedc90bc5f8e2443917c60d5d605e06c42bfb5ac7a2fc929e06a6edb366ddd47722523f6c52c2f380e9722c32ffca83ae911c81dfd40f08c8efb3cac550aab24af8926fe2ef7c00e70f73fb609211c0107ff8589785f0bdcf216a9bf293e5c6460eda0166171970d4acfa54c0684300429c2bdc4056cc9f9fecf19bcfc7eb969eab7f6ef082d276602abcde6b0995f4a61fe5b5f6ff0cb833ee87d0f6b15df609fa059e6f7bb45a36a5f0a8b831feff0b700c6e35abfd1d277e873f3e9b55467a8fe260fba543d89ec84381ac020ade29117d90a3ca25f02f2a5688f362956101989b41dca3147ced3c5935b261976601d9c9aa2c1bebf7f6226a0dba7587ccab5b7258b213ec20b868213ecd39802cbf850251a9ec5e8ec570ddab6a2b68de0999e71f6f4c66f65009a000ed5bfa419ddbdce65dc2cfcd0d7b543f31d268fc034c36a4fc8149d16de5b41e962ee7ee00284c2662be617f9f67f87f53918d11452163b94bf4757b8df4e6adebd0733b7184e615b6c6f01952076a8e276126e1446856692a479ebe27e0f54e447c66e3cc41fd8298e74d93761c56c650cbe90d3115e51773459f035ec426340ca8c460fa36cd1a266161537e0079c153e128777f661e2f4315f0472c72ccc8d38b42cef72b909e9213722fd4552a419fcc1b35610b203572dedbeec71232faef6381c1010f81620cd8daa8eadf61e2be6a20ad196d7f4f08051d44686a924dd68c9f90423d880d21cad0b5e8ca6fcb675ebc03bfd7ac5bca6b16faf577551f9e960a79e7a6634799c4a655ee69759e148a6a2e322e13fe474f4dfbed77cbc36f730d1e3ec259d3cbc3ea29b11ffe41d223578d714ecff667f448452606002598c27bea4e269409750db641e19c9c6f992834e5969e73f2108cac2bf9752e9baee5eadec79173102c0f87a2fd78baaa599f0c7687f7811d4716650c05c782dbd35c490f58dfed461c186f4600f3e1e301b8c466b80ec15fca3fc0dc21d0bd8c4018f32adb57873b3358cbbb2057ef49870ff13e7287ed1197c9df34944f300c78a270f67931b846296d89f830d79523a1fcdaad8f930087c5f0a871eb2aa2285a3f27723de78a94b1ddb97b471b2d0b4fd2539cf723c1a677a17171c3bd5028f3287934d38214654f60dd97d2df470aa583bb9666c8164a8e9167f3000b659ae3b4580b889d513e5b98fba7866767a3b8f443ceb36acff6fbed6d6a9af4bde3eebdfde3a93bf83cdfa7bb4ca85f37e331e4746829913c7d6609986439adb4b8ffb3c959991d13a1c2ce291c6378cbe4cf819df932470a2ca4bc5b9aefc94eaa154eec1fb6a36a8617e5efb439844ed99898386af35c2fc3fdc1fa13a762bc2378a945b96067fe6869f9e017413b06d962a3a884770edefa91197e5c799d00903c752fd6e09b82f7221a1d782780ca6d215cd77b091756e0e8eae36c7192a514985331800552eeb58ad12a5fca382448f782b7e43310afa7e4f215207cc17a2d78a2cc44076737169f1e73305f5d6f6923562e2265dfc45e19cc98f59eac832a19b6e3e56f6666cd12b4d3f7b77f2f3acb36de71b6670ea79b21f12030d30d69d6b2f20e7f1731aa1019c5b5b4c95370f9205e1429622289e0c3d565e1c5c668cc1dcd5232794be541b662ca38803224e6a95999da92f70c39e38234caebcb91323ed180458a0707bfb1db0378358bc0366c8da57168ff2513aa9b07ef3c1fb814b89c244d12ed16db730ff1bb526ff572521b7e4023995264dd611b1595cf61ca117929c8929157cb42884b3304f081fd36552e7088d0b369d0c9402caa46700b60d8127fa462ee122593adf0cc47f012d58da780d5aed381cf394df0fe145e17797cc6163a820f5db5f8b58dc53311903f802b23d5ce619d1dcac59b3c9cf7738c5f89a654255c776d5c0b4e964bd1657bebcaf0d1ce9c2d095572d0fbe5f8630cc88817c16424f0d314bc5adbe20ab686e7b78041bdb2d028fcdd89df76ee05c9d087d88a1ed011d1860f28fab4926fd5da6fc4401087b90caeb4f7e0eb8dcfd6dbc770abfba052166eb55988cfc0e60f150120773145b291182bb6998dbb63ac04bbf29d5726cdfd4626d763305fe6b4513624063b9a4a92dcdb098ac030eacf3872e2040927dbbba779a81a236549dfad70ffca2a32c275ee611d3368d2d1e606d2a8c4281e16d6857567b706c0bb6b22699d48983f62abd6110e2b1138246f54264803d120d26530e45d06f450206d90db13b95ff2491b89a7699bb675f73163c70b15a6d4fd718d1379dd03cda9450dae6c821003d84e975779127eb12b684cecdce27040212f57eb5f04d90c5b9af2cc210a4568216f974e4d018fc51f7a25fbbd8119c0cf6d3cf8d29debefae61f6f9f17b61163fa22e6bdc63126da40bb6d1a44aa84e7cb922bb1fc561c130a92faaf6b14dd3136e7b536d9818cf9a9463d53fc61f16697aa10a8f72e0d027ce1578bc3eebe5dcb5c80c82d9046393ec553e41f8b4155adb0152b21ae1a107e292658fa1b03c2f26831a718875fbcfe8e21713092f6e675906a94f410d8a5b57935a40add20d25d1c8c313a866801019f5cfe84a23934a3f20e3a25143232a1c0985ca4301988dc706834fd11c691ccf2bb2a88651aa5b11e98ba0e83126ebd7c1ff70395d35cb0b432c90d28b4ee85f852b084a1c4de024d9a26fa1328ff0e431a34fec9bddebaa7435e28fc55cf284524749972f0811b794846eb077179e48ddcd66d2c5d61a58068d47a7acb7f19d71008922efdd8b018ff860a8ed5c33354a24cc0dad56536a05af35eccb3fd6212719cf858302dcbfbe46b5ae7d63f3653d694e2df02ff79739d28e4ca673b117ef9fe3fa7d548a7c63e5de3bc6f0fb96c194669469578fba1a129e9651f53bd023a76d6dbfe470d5253e764c5978bf46d61ad53879abaead2d7d2a95758d972d0b7985874740267d9374a77125480361f12b8fb13fd3ad7b3c4098b5275360549a21f429f8d97b00be3a3e7b8ea08027b2a4a873a7cdd9b774f270b6c084bdf60727af4203c4905a2ea83269c5df0856b85332d08f40aed6099790fedb239555bdaecca1246ff750df4024024e7d3b9ea7542590186081c737eacf58cca85b10757a0b0ca0422fad55e9a341dcdced1da86a7090a10fbf6bcfa035e125306f11c6c88bd95b43bb9563b381e552bfb77c2f1f3aa0c2a248389e4da2d08c1a073305af21800222acc4f5d8fab6aecb93b525f1e9dc53f5bf4e25de5d8bc025e091230b6806fa612308cf8acc0d5045e43d70414a0350583ba483e69fbf97283711a570d8f271c2955bdb5f2a3eae1ebbd634e2fa8f0c5f0fe46fee8c62aa106e4d9eb420f48dad9adaf891fae4452519d3362aa0b097016266c21606cd03654c2e8105c940b9563c353e2372f6d6e925ba67a4389ae346c75cb63f86611261745b9683881c3a00bb39f8045e359678da29ac01befe04253f05a6a6b8ec8ac8d25137be26ce0264aa1fde23dcf2e9eaebf265188f0a5a599ad28a8d68baec8105a17296da76cc4911d460a126e0574486b4a272fdb7be88e8881b97a0f2fc60f0dab8323ea1950e806fe148d43e184b89afcf40738431c7c92f862c0b1d0927f384b1bebb90ffe9486e2fa104bb2bd73e28d73031724ec772ae2008602cbd2b71c4baa50ad0c71b886b22a15a59d7d15a7f08cee177ecc5262b00fd95b72626b0ef9772414ad18552903cdfe7dc585bd7561e7cd180bdb9bebfabf720b4b69773779c953b6abeeb6dd1337e994f20ec62992c3fbcc4b1116d6934ff1b8d2575bba61560ea8861749323a92c2c58ffd1f5177d83cc86dc62b188f84f0ff44b4d59f151f2aca995511683cca6129c86159e0d7dc596a2dca0c27baffd2e489977bdc56cc503ad3de09300180085fe92813c4adf07744a78f40aa88014ba307ea92e325af549adabe8ff68d0b5ef5110c02b2f0e24c359bc8d447514c885fa97527876e525e66b91757cbe8a622c90c057b781e1a0b6aaec459358530d23c52c0dc43970b194f6d8463fab60d20d4b74f04e3053615c680ad0c07f5efcc1c4dd5ef551baf829574f4c0114b9cb0984547dbb4f6cc227f92c4738ce5bb5078167a66ad1b0a9ac398912e357bb59cb86672099211aedf2777e907bbc56c50a9041c6fd3ccf054615f475928873f6625b82254c26cf1a0af96f1d2a576c1725d00306c1a29e53a67bf1daca90cf6e368ba075d698a7f3860565db51a55cb36ea7742aca5ffe949ad883bfce34c9626b49c57240bb97f371ce52e2f4393c9ed96029c62da022d3b6b48f5f780003d52daaf420a71daf14bc952af6fdc4828df20e310155379dec0e86d501a77278b8502b30c86c26e141ea1fec0c00be7ea9e034ad8d0c9f98831b2ca29eefe7ad45049f00223adb1b59e6722a9325ead9d0c1166302787a4f96ace254e8ae7aec19efa8fc141099cf2fa1ea35ece358cd13e9204a16eb20cb80e7c96eb1b6408965d36ac27a5ccbadaefe426377cd429d8bd67c4f8e1844567ec830e6d97c41769df27f295d4f113273ad45bca6c719f9c4d3b0d66e5d72ebc8c53a88784eb16061ce56997b9c7601471a384fd8bed701bdbcd4f5aac2962c0489fc1b64ab49ff0ed95fdd385f0c4eab2ea359dc22230a5502775123fc0e0c0abe4f56ec9659eb104ee1a33668fd16ed02cbedc05aeaacf7143f2428a63e9e7590d5d0587c97e51001085e36731e108c0bd21451efca5d82ef35d6653b0a8235a85e150ea73bbd375378f41934b327513fd5b24313d2c48faa2be71df6e53e4dc6dfd2a9cc4212838e13b0319c384c556fbf826c5762ce85db2d093d56e5dd2bbc0f5b6b3c9ef9f570090dfd933633bfe2837f4740ee6fd408c074dec7a8e69ce886d798fb266f44db3ec2c5228395dee9453a8ce5c1a42d2b8598dadcd267562109250b693d6b3791515b9ff22a24289c0c57187f171f38cfdd0f9da552df9ea2a2fd71cadb0c6b7c9aca53ae504ec3b7a0ba5c6d019c3226c65cbe6e10c151ec6c5f852b4ce01fd0c8bc7d6dd38e416433ba3447d72a8790037c88566501f7f55762aeb639828c17902500df0a5f4bff8606cf0a89ac7fbc804008353af889dcf8d1e3d3249f1b66b79c3a8a5a6340059f251a2915e724705317873af7dd26a2490528f148d95734da5228388aac829a76f12dbbc42a6259f3efb1c819ae84c892e561287a4f4b77fe43623278046c53c48272ef3d8abe7f73121ec32cfc3dd0146c6b838aa87555c6c5d0925d91aac1b2760c85239683d97236a13a732a1faf450c39aa56ec4c2c26cb30518b13ba1389d093f3b3e42d9070e4c19ec7e788bb947e5f278f932a2e34732a909e276faf620960fc1f331503e0ad7e611ed6019fe348e87889d8e6c71747133a38358698120aacf61b585056ca19bc0a0594f21ff5cf396e9aa12d53efe8c0f61e7503c1e578bae564a4c934f0afc4cba32c076a823fa03385229fed4d0195fc4f5d56e378766cd614c93c4460fab2952f206d0449a0ce2672e5bb2497a67b694d80744a5be77e47b6c56dbba4a57abbfdd22f8fda18ee4ff1e1effe6d94f5951052bec444deb581b92985486d5160eeb67bcee122aae4ff5f0eefd03cc04f58859f4cef689b1774153cff08c411cbc8ebf3e98150449772195a2f82e12e30ad5700d1becb0b96910b511b06e9cc111e6838e252a3cecc74d8996cd68b44bc995fe159be34b9ca0dde5f639c778905805335913d5989d45fbfab2ec695370cd1d280f2f72d3506e827a2f779f7d3135d3e4b0164e2c5897bfe67e9584d29a0d0b1402211ad1e015f867481ed710ab3c3b45cbc90e693768ab9fa668dc3ebf53b7472ba10dd25d00863a39fdf82ae8022e725c9f9bb6caef9388b1200b855c8059899bd92ee9215ec924934a50b7fc01d25c5a1930d1ed6e0fb2a0814c929ab4c6f4eccd856ad8db9c15d379fc614c5d5f7ed6f1c947f7e65a2762e2386da77be84f0dad5cdaae712275bc92ae373f634d97b46f838c607aaa6c69e4d6646ae7d1c508d0fb12555c5417bae24ade0295ced91b5bdfbd27c31fcab6351d515326332b0fbf068acdd43b900c35c35fdb29b73605d64cc1737a2c65e528dc7ebceaa548bb29b774f101361d59f23dfb50573ccd3f9b1ff0411cdc1ef861da44108314c647b0c0ea1deae7cc36c5e2e87fa65a657592e782713b7ec742e96ca76bbb419e687e17cf89fc5068c11477d231fe8a3cd4021872e812b5df518ca76daf2dd3342518a440f03edcf39b4d64eefda2eb9d6c50685d648dad0609cd451570f8c38b03bff8f9c8a301a30bed7e0808ab2347ac5b8fd8fae62634bbe91498ba0921f333e7df614208c31c5157ef7f90002aee610780a8972115633b990bafad0355539f9487c511a8c20e4829f872545d04cd42c1aacb3fc439768f4d4ad773da4e054e015ebc67c618e7530a33be96fcd5d1a87e22e0ddc4f417d3ca6e00e3683303996342a093e466133e9e507e38a95e9f86955e132548982850c00b24582c741ab5922ec90eb86b6dbb5a447ac47448fba18a89b03b2c422030be009e94cbfd14f74d6a94baf4a97fb18c41447f6cae6b7b9df365eaad6a3f35d23f2226df79f4949c523106a24ae9527dd09378fd290fd68c24e36a243824d3cb9b3037e082cfc3c2fbaab32cb39621096f4548cb76faa7b381cd6136553e485872c78a53cbab03a832768edb159329ab261932544847d58732400d1a8dbea2b524c4d2c545f31f9add17a6eaa06d70c77f18a71a0b106e5f0a554ceb2f59c853d1335ead643f38b41ace46bc07a377a0b5ba48b2ef38886653e8c3b0bcf39b9eb42cd93c9ff83033347e45d2ef6b830ec33fbf4d4a4cf55f6ba6e207a57575af4e9b48fb757025fc6120900c629643ef7c2e4f7011b4b73b101fb50918016faacc5cca6a4bdfebd12b8df286ebfba419d313f9ea86aa47bd717780bda5d2ef69e0c5168ab5ff4e7d37fd31c46be90e9d4e84511551a624fa5fbb44dce618c51e8f93839a83958e88ddbd7c5c3750f673592fa1df004e0496bc867600eed7dbd1c56a24e819a8357c3cb611be5a43508cf0a4b75d16d900c65733a4345da3dc8755e57fc4210fc0c89d7116373c61244d017335f0adebb5d8fe429b17bc9142005ebd3dca2b0a1413377c6865607391b42c1e16cf8c4887ba7359b2928b8dbc9ee6b3e3fb8f1ca2490cb99b31ba995d79ecf1646a3d21b2b8c47161ef796260e85f1384e32788018c4514ceaf17f0b8c736fa3ec9440d6623a6bd5757f4651f64a1498c01d3f9d5e3bc55d2281eb78d677a6f0996d74f6abc3a0a35e60b705f81627d40017b551286477b67bbcb8f1b34ac05e74ab27077946f20ec8fd68238ecd7136cabbb75d7c5313592475c5232ad24d69952df36ef737d5985ee247e7a7cdf0c752216904d4f1c5253945fdd6f2cf18ce3e54f583aa60d460c4a70aa10133c9e5238b0fd254cae531738df67cfd0515cd896d020a0ddc3e1a80090a11905ce01dfdffcbda21abf25e3b484ffa9b200e4c43ee407a8b7c813348a78ce3e84222143a3b74b9bca3f77ea04de41d36e79e7bebff26ab1d5b9b9660b5fa39a1fb5ba173f637731d92af859a69771af244f5cb3e1378b1ad7e04221fac975109b18d0c6d37d6a051902c5f6546532bdd2862cca8f98db90e62e8d84fb252a36dd5ffdd64977776bab64d52f20ddc65301e42bfc201659f1c3f1fb888a3da2ec691270501460a40053fc00d5bc1bcc7ccfb5e0938bbb82695cc98f09024a9ff47f80ff04a03efa607341e68509809af68f7b029340d5a15e3510f1aad6178bce4a417aeffdfd034620f8211816e71dd6a306a18ba1ec79024fa0061544cdbbda67549628983cf39bb9253f3fd15a2a30a88d76030734c5fb12d692a99df7938aa16cdebb400daaa50e9513f80cacd5f67532e4915a24c845a1d66bbc785a76d70f078937cde9092070237a93486abc4400d94aa31e62c268cbadc45b9f3c5090587b149eac3eba0a87c985f7e6343f02ddba05803cf97458ca7c792cfedd53b60b29b8ecc66e284cefca55cd9e6d1a9ef708cdeddb48eaf04eea0bbae97cea4c8d47bac3a58511258bc44f80425ecd10110e820bf3e2a012556a53eedf8abfe210ba05babad6fb4247b389e1595691d6020b87f20c9a32598bd0a25d54e01a912b406c26b0211bb1c2dd088a56372ab297cbd342e9eb5defc2460e053d22bca068c5655719e3161adda7f7fbd5254250e25458baddd0ddec5145cef6cc1aaaa2fd6503d1f20789ab38c38c8193a9fda90f994e484330a6e0e8238dd818e547ad7ecd602254ec164b02c72808dcef8890c67d6053eb50e2b0a1a38e48d6e806a188cbb5cef5c2ff21aeea2775f68c96dc61a624a5df1a2458a596eb02e2144ba437cc8ba43cabac2b9a8f7caa03c8d47949fafe14f33446415a53b9af17329b41579c3086a1645e87ad62d2618d2ec5adde7272428520fe340731b2b06822399779dfbb209d081a684e422794903b0f28feb1daaaaf6e61c4db0bcc3fdc82099838f345d6f3b4d03317d2f88c9172c1151f754fc5279e4bea3e0d19dbae24ec67d65146ff23e26c68ea5e7724efad109c900d7753ccfbb0e013b1e7caac761c98ddfa482b29ec9445b03adb3e588e4ad2c6acf84b6c9f0b4353c465b131e6988bc998b13eba45678a89470feb5ab1437af1da829d7b879aaad2e89dcd7bbd2e09164f3754a613afa0e9f3abba6a7585976e40f0d8c71ac7b308a4e03aeabebfdac45a625a12c013a019ad2dd50056277c7ce62d6a9840f299c0dc8c8d135124ce82dda1e8d00ab8368ae9596fd329704332ee6b16e489095f7e9bc84d2751f68a778fc71a65d3fafdf6f43986493157d796614e1bfd7a910a633311e5370bdab96e3e173559b46d832afa37f951b5a36e9215c0eb03ccf566021bcf1960eaba8bcc0ed9566d4ad547b782d50befe9f41d06fdb06b3cdaef4a312296fe26946c9c217ec94f01b5f6194351112314f10771ec556e15c3ab1f9bb7bf22aa8787831543d501c667ecb7839a3fa5d857abebe1a74570e2228bcce05a82e23be7f10c0a6072bf0da763ea78b660f9159ad4c814b15689ba4c74764888dfb4dffa995e4aa0025f0dc974270703f4b6999c053d0b3a4abbf5702e27720d273830fdcaa5a82438105d6bcbc1685bb3d2821525c04f2ef48fb7ffa23bc59a925b758b68f56e276105c4c4cc611a6af532fe9a0656916b38c973c4fe66e4c5ce972057ac853c7bfdb713c5793b50fce23079e8e64fd8bffe3cd7171da9c5d9e9b0ae330112efb243f490c70c05bd0714004c44a29a5fd7118e3eb5749b6051cf8d2f6704bac368cc704d75bbf983814713a69540264a980d5d13b69d7bcdc5d1449664b90681f2dfdc2807fb12aa4995cafc5147dd7172563025aff12fc0ddccfcc019da07558ecdba1a04f6c9990b6f3716544575b901457d6d7c7b932f64c67902b6b7af6c1db5bdd9eaf39dfdb7a7a4830df8bd3db2e7036ebdf276c9a51edcaef6b0100c0e3547e336261a6c28b1ad4c5cfb22de98e41f8f08256f579b7b72cd1d6d8a6b84810f8cb6a6a93434e11c00ea1cbedd3b0af01fb1ab2d8aa854c8826045ce74e3a8c600460856aa99c78b8e7171f1dade46459617c723343ebca47a49e41ea4598cddadbb3ea480735baaa233131c162e379292dffba98d9368061dbb7dd592af8086c28b694c0d3c483cb8b1c79c11bec1b2286526d1775c972f90a8eedf8a5521617a6271ebd79580221cc8401414f51bad00464696e01bf603d3604954e8915c747adde3f2e3833767f210f022bbf932f3dcbf03c0cbc34f61f7e6263e1933c196c4f47c82ada1943466e0ecb529a1a3fc57983f958971da47934b7168277c38953bd3e35790a25bb3b6de0db432d62d88e1f3ba25babd6e29ce5d369cc2ff15258b27adb1919aa60e90508a8944822887e95d952c3904c07a2ccdc9f8143e5ab06f1846059b58f17439a8ef02cf32fd995d2aa0dba20b41ebdd200f2227bbc6589d2f724ad099f94c48c3f300882e77a4063c3475664c0c70bc2aae517dfd3e46fb2b7ad6b6ad3556aae25ca7a3fb0db949dbc8d8cfd66cd58ce63b4cd8df9e64bcad134298a07954c94c6c923d15bc7892b63a1c445e2708b57f42c7c9bbead7ee600f9fcac3c5b7b8c1f06c9997571779c2733e533b07cb5af3fb13e37408dfdfee66fe1ed0149281f8f69e926985e7681bfac914f7e414871b052f286961f74775f65702b4135ab15598462fa7c13cf3216c05098dac56a0b094dde306cf96a96254cce44431049658165e9ac81a285d28dfd0842975bf2f3320965e0ed4f3911fb8c6afc2d1e3c96d3c231d03902343292c4a91dd9fd2525579de8b3ff73c5c5ba3f34fa72f308ca07b26a93677500e028ce2cbee082f183a29e7b8862f2b7d68cbcf7e6993e60e498ccbf925d38e241e23966de3370b2e278d8b14f3848b5432981fe31ccb9bf4ac1e8a007f609550bf6899c7392de4472f69d056dd09f46aaf29db33f36206340e05dd4b62e870f40fe2b0e87a979339eea05ff5ceb2d7c54c9966fefa44b834d7690b586a09d427bd8098f598a8a3d858b71f9dabc9f82271b8e242681370b80d51cb762fa2312e7992018c942f8f498ddd0b4ce32fc74d5d4d00ebb28324021cb523d54ef87c854772a479a58efbbfbc63fd86d20afb9be32d741fd4413aab063ee61186a32f6890145c9a2b12ea350e0f016179d6d0aa124bade73c3aa4aaff9d9748cd78653cc4bcc84acff9fc66cb8fc778868b470d772c40f511cb256b8ca1a0f8d48477049f10aa861d81dfc4cc28cb58f68ecf1d3b48cba762041ad3170eb1ec25d93875be4ba5e1628aaec7677d2a0dd7180e030e7408de0e164e6b37ebf808250f86ed7d7a67f6f8d90bdaf383b0f0c2f8780992017cb7047c32ac8b645ba90898b346e42c6b84de5c7fd1bf6b368848a99676ecf0db63e7796e060790e88877c780bf1479128286af1432e6e6500ba998811b1dc84866fdd7fbce5aa5530feb30d99ee33ba66903a8f2c0f42a40a01454745cb86a0382ba864b73e05948c23d2b817d79b9aff84bfae070002ab64d8dcc1bcba0af251c56eb582248e870ddb88fe3a146a09322670ccfe256016153b3c13c874885781b1e286e2b79c02863b928e141edc81ffee9530edc1c077c9c322060be267342c6030b27dfa37cb3e4722810f2dab91df2dfc026f0b6a25b1639e78796829683449d090467bb42003c1dc99cd5804710271196cbf281e46ddfa1cfd313be858670325c29f40a64fcfafaaa57b49a665c59c938bf24acce055d9cefa931615f955215c58bbe147ef56d725f9ea51feff7d04b4569266e14b2fcf849e8e87c279f3211a034c5e1256f466ad2591d6a026c7df49df82ef2ed56d8fe0921e65aa68b39c3bd81f81aa93789441eb5f5280f8b485bbd7fc681ab5d213b0b8ebf91781deab9ac65a507389a6823540de70a80d82d51a641bfe5279ae7e9574910928e06470553aa6ea8504fbd1f93e5a709d903c8c8d5ebcb946fdd4469347d2cec42083238ed379adb6451f46839c71d09dcaa47de0f357e1324ddc2a018a52809de1a6c1d04a0872f767b641ea8184a76414c7cb2a300686648f7f71cb27b10323f1134371db7fd13b8b3971b79a4d7805b5845309b0ac9f3ea1bb025b5685ed37c1a73098d8ff8582cd3d33a81436ec459900e9f2a5243a0ec74bf3a7cdbfad3a9635208859c956efbcb4026597ff56743403c721aef8cc423ff8bc48f820f06fa587d04536ba8309412845329b49e606e71f7dcc7bb6c136463ba5713222548cd866d3156f8249c928f082951fecb0e49ee53f851d6d2a2a8cd9bfac11f0332d326762f792f88a0a2c027175aec2abdf7a8a0a64c6f182541cd3eafa3b6c8da5252ea54793ee10e4d6270b5699bd32e36335e494fe18b729f031804daf00fbe5c8a2dfb7132b641b909761c430a90f27944ed4d413fba4d921ca8e58c862fe9d5a3aa363910f8269ee30a5d5e6d5927362bca6ec077c0f81cb9aed50d7b2105eb6347ee97e7ec55b25d9f7d52b3f6a62893e7148e3ddec6b8b1a4dc21330d5fa98268ad070c793fa6d898adb6194e894cba9656d588f2ed6e77b81cbfd24508544b493944770cbd7a177b1d9ea0ce2e7ca46df1b39cb8690579fe9c61c031102f4733a95e3db3e7b4decd8bc6d8127f0de8562db10292b3f2ca75942d57b02a4c38f01a4cb583463049d2544aba73bd6c6509fecd849305868dfecde988b1f4e0d5fdf631fcf1bc77f49f4b00c9285c4656c637168a08867b405ee2bf919def561887b83f6987a21c226d5b0ab5f1a25a574398bb9c7e7e969197aa8d4380f7a9511bc29a2918f71075971b1a43afb31c5d65b3048ada7f8915cff438060c19dd856ad2183781c65937cdeda85f618533c8758b2c93f41153463fb2a64ba494bfbd41eee2f51cb04ef3d170117a8de6377704f73d5dc81d72e34cb3768697c10598a9dc6eaf3ecb2fe6e1e8c0201059b2ecafe93ef1ded9c697928b335ae000a1c50e9719996369c54ca721993d118845b3a27850db0a7752d6e571770ce2c724ee976ca2307b5df1de1919c1f3b82f7f3732d0e311f2c3b4bb93b57d485223c75cd15f89d0f63d229514198204a9450ebb4aac6cb6f927330b098078493dc69f0d3676a8e0296cdbb49c226c5a3c0363ed2f66c7b010ed2ceda7551975328a5f47c8a0d8036f0a215e2f971740b145ece7eaa19893826371eac41c6ecaabd61d23c39206e1ee3ea4c5e0703158c7ab463fb6ac3565c730bd346b40f1ca217a60f4d58451cec51719e281c6693871c6b2bec2955d0861dc8b29bece9427f14b89dec52d51c5fad75f9ab8040a901d68f230ca133a479d5826eea35402c2d923f6a8f3b96819718f7be750e616006197ba329602331b35784523762551ae8e9476c37254e7eb7191b22f892b5ed28fabfa12b1c5e83490feba9ed23fb33b89dcb2d1edc513d61880ddba946d42355180adc20789bda615ffb1a1cd4a3cdef11001819aa4a08b7d0aa9c0e28a4e2265f1ef8387837a7613c159b7fe778bacc060580f3b95d06ee9452e047b7ccfe8effcb192314be7b6bd9f44ce4fd04d2f1d814c46b67551f2d9518da91bfa1700a2d5f8eef417670d3d754bd80b131f6238bedf9e5faf64bbcd4b072762659e7cf3e0faefbff4183289cb8eadb0269d1e1a13d31baf1bb2c7ea79087a5eb6ce1680390d742f6f34cbb8d81ec560925bc4ee51356e62c355c8e8c747198920a33e576ee63051de43ad5ab18bea8eaba3d730406bec85ce3c50bc3f799cc58677dfd54bd9661e1e94521eb7f30f77439ac8a4e2961f3afabcd5617af52453ba611691debc51d4773f71f0b3dc48250cbbc5f1cde7541fcb2b9e0989e6f46406ee03bfdc138c8cba5aeea112ec31831f4d28c760a9d4177759a61e5ba41431cbc4bb5af21fa8c3dbb0d44d7fdef30536fcd983b082d039f77870da20dd33dc76ec539c4503f19961cc40189cb415b860d2a8b17fe6f2129962f500de75a3e4b7d9e40711678083b65b990d68509479de13733c7778ed363d1513942dd16927ff2f02a801ea6df6a586d185eaf16a19f795a841fbf767ec96bba274c3a027212cee3614110efae8db26612a8c661c58d770a0109ce21f9aad8b4da237e19a8f99ce45821dd71949e4c3d47e08cc307f9fe9cb439cff50624ff334d30790d00ea6d18f9578f4e308094b5cec4bd6424450793d6927b53d5008e30163e711c7a063abb36cbd923fed3ef8e40eb106d79505523ba1447a6195af3ce3f64d7431fe2d5e059ed0743e7bf30b13d07e2c5dc74c1e9edc2e19044c277aba8b7a529a26279302d8b0f03f9540178c51731ceb8faefe9aafc0f197e21406144d1a186535aa1fd95581486b383018073174fd8711d28d76b49ff0c4f631a71fed905684d56f4726b03a409899b0ff0fb9cc397afabcae7d756ae160e897c83bf4f6ba264d981a14658cb1a29012ff874e329b77cc376b5236f5e4f28d9d866b32755ae564fd9f4784dde5006188d39e5ca71b2d48327db2213b9825e3528237631ccdc2a3ff7f68846f08c29725e71f004838f5658db75960fb571b200f4f6e34e1f39c634e61b3238e0c47923bb33fd54fe32675bda1a2303cfa44ab48c3b4b13dfa0c9e753f10adfbccf46210665ab07062ca8fcd2c5ae6ff7ae8c9083ab79e8c4e70327d09148482de9dd210e653a4df2e64dfab01fa4451413f0d06554d24e943c39813f5202643086d85e201f885cd246d2313cb05c60799413fe3e8fb4564dfd3f214d6d2485607c4f35f470082535b3c14ae039e121e3ec699be8f86fedb5f2892be20659df3b7e4b9f2dbd741122d88a90d823a2700c19ba5460f16bac4e5399e5f8dc3e554d8983ce46177de027fe8c785e3228a5cf5e70fa222bd1f51290962b0848e5e99d50b694b670991a0786e8a29717485070ab63bd9fb84fb045e14e75fc729a6afdf2603425f1fffa199cc258169eeffe189d81779af24b76668901c053ea5173b967c3cede59c51a637b7503ad5052435e84aa428f0172447dbba3c2293e138efdc32d076325952b610ab64f040b9ee232f35f1270a786075d2c683bd9f9a91a8cf18ee276b9ca99cc8df1d04a45b3e3dcbd238cea30ea52d02f8cc35b41ef47a747649d2cbdb52547320c52883c049d3eeeeac8f2d850f11922e10b7e9b35f8fb820dcc88e3e701d852b2bfe0c407e0b280f68945280dde915b729c80439de57698ab7b8787095e012b515f8494327ac5b3a3d73f7c71806d1e60a776cd4599416a0b2a826ba70c222b85b90c3bfe276c002896b08c9b487db68368a0383baabf6e5e0ec80af6c111e9fa8ec0c14ec5322fafc33288acfe3decfe12cbfd0eb1bfe7b54305a9fc980939a4fcb9d78c9a4ea139f0212c23b906d1d4f5a885ab8e3908f64c5b7567937fbb62263f9a48257b1da3e6203068257834f5fe23e78681d844dfba10f14871d05e6da7bf380453371b1a744be36cd6e3fce5060aaec601ab4ead37bcafc1344482cc0eb47535c96943db2a0a9613f0307f61fba92ef4e40c9b420e881829c36c4d77d10f54fd775e50ad7ed32f665128e3e2c94a7b6b7fe533d4101066bfbf8a2221fe6e1c63569dd40d81336372520cd1d070fea2085490d7f0ae3056ad2f29631b1a3617615bc8066fd22d4ca296b3520ef2e06966d4fb6f15cdb011a73d409279c2050b78efd31c116564ab2e520b61dd99d291949d191fc1ecd87e0a86a38817045ee47f5a6b0ca32b9f21357feaedfd83c14e5667c92ef2ed06d7a4ca15aea520c7eca021d21abf4efdaa5a77dc7fbf445ead5f162737c71741f7d442b3129d3fc1c7a27ed34c4ea0ec8323634c93acba0edabce608764d2e34cd30fc733bdd9fbcb76db9f2b22ca85aedf3595f6a90b494438a9393a56b18427c826e4a58fbad2ee29aec2eaffaf9ee002669384ec6d7288fb458bb1f538ab8cf492442a3a634612961caa5f36564f6691c9c3b5c7bf97fc21fcb693ab3f08f3092e207fc7b511d22177941a8c1bc632437887f3dd35a904e5355f654719e744237f0dc4ecd7fd89c6dcb7f9d9ee56297d1d2ff3a00b09313e134eb5c2284b9712f22a2074fa2664476efb6310653daab9091af2a954b566fd38d02e31cfd8083ec16838ebe6f06f784a3aa3cf87465af838473fdf9f6611ef190d2e663ee402a46bc1a0dc05d0e76055c58da10677b4036b7144efae9b171509df20f20f8164c17f98257706dcdb2003ef7388638477d11b0b651c1f0012212577800a531f4086f5fe552509dcdf8832edad52c3c191cb060c528e00d10ea88c3bc663fd8079bfc8142da4b77deb327a31620ebdc59ee31d505a43d5a6763c7edf75103c0e5b488bbe5d19072b9a1b656926bb539304ac4b01618ab563d4b566f82c4b020a4db62ade077b274cdedec21f6b5d38359af619825fdb75d3116cb59bc343181abcd26ed4b4f2e985ba80fa45b632d02352e4ddc479241bd52b51623e94b7d0c687e26580dc4ddbf927320dcbdea85ec798ad78ea5a87aa73ea6cfc6cb3003ab004adda70cd2ce8a7f69af29636a8afb4c42158eaf27d79407d6e913c03ab0df3c61e8ccaef011b58f5e2b869126c5c97f1d3aca5c3fa6fadf249ba444fce3d1b90c4783d3ad2f19177701a4264fcdfbfaf589891af3ff51d0cdeb43e2ac52bff4aadcfe78eddd48d88c96e248d1624f842f302304f756b2516d99975ce38d64ba3e04d998176e6651ee33cc8493d6ca613d71468b7c0739e82933cd0ac660d7b18c0b65676229e16e8339a7ac3b8fd884b88785ae4c879114a64eb2052d516ed0f3b8d7e166cbb3071f8a8c16382c804782658a156e41c2a7d7449092a3d983115e7b3703fb9464f18db50265b16a17d9a8aa49d7dc8337486e2ecc8193ce17ffb68d84a964a265aa6ec248218c1e9230808ad641e40974f3bc36acd63ff91736f9473de2dd70d49b6366e6c9a4f2d7f3a5dc7a38e6e6f2ddf4417960296e2cba2ec930ceeca70e8e2b0e73fc6de12e36476d14fbe090155b8d6bb201fd97017d7409dcc5753ec08fa8df684e1813dba79706112a717b424a9d4d174d4e57359ae49436557e7fbc67a3edd7a4c02a3f9d66f9cf668533e97b873912dcb6bf9fd433776167d194a0ae92a7bee552986698272ac9bbfbca66220164564a311df019e25ac6066fff89299dd3a0267d9c26d8dea1bfb2af660d7efbf55b279450689640b58b98d91a645e941447efdba2bb988af4fd93a880eafb8ce316a2038a8330bb266ad7eda7698167413da2a0c4210df8a27ec1487dc420dd3ca2a5dafee523c848dc0ddddf058d64dec109f21bf20ae963fc6c669f6c683cb3e1e28c96966b490b2c4de9325bf13d2787c0c7a7121d4502c3689d0759171ac19d0baacb612920112d79828f4e811cdbc3948d13d9d40c36d8c998ab3b34e277d1c52f9c50f2ce99006035c596c7b8eda6a7649d6257596d6356c634e334b5b2c58e43d3c6ad06c2e17b7481a59bce80cc870542714ac8e4ca321d4306da7d5246ee31505c42837e93fadf657b769d8e1d73a7347bacff078815cb17d4b44ff838144591c5dab02826d6d98f0716de6f2b8df17c98c159384bcc0320e7a7f55d1589ad92d112f2972f6de9a66b0a6c093c668d009d7331b850745571d418e126d431a23c65cac953bf0bc3ca8463b7d0e643360f2d7133ff20e4de484822a9118e2dfd3f7b77d237c6e7cc4aef5268ca7f4e584e242a9530a2cbab396fac38bb11a963dac87a3bf748b824ae795b488dbfb1d15b53375093fd473e9f90642020786f9afa8cdc7997d40893f2f8ae4a5945de0ff6a202feeb9730bf9f0ad04d1651562a635266369e7664f30a61e7fc8ad35a5afc3481bad9af07b53fe6bf9db98a5c8c20995b5ed353a19930e397e3dcdd725231ee4173daeedb724b85a47292f4805d1981b38e81b139ddff7902dc8493c3b6752c9b37dd880f18cae4d0879e82e31f71dbdae1eda5a708ebb02a33d8ee6979cc05a72dfdd6a82326c8128bd56bf21dd083e8ac95877c67871b5cf5793ae0e8a8c5034682e625d5e78c7dcc17f97cb027e5bbd781ba15658c06cc603593d0a11cbb8d82cb1a6a8afeefdf3811c687fc02a30475a0643a341cf69d8794ca975c216d6533439688f6ab5d71ca1f3a9bcd175ea3ceea12a06f59bfde8f6073bff190c5e9590daec1a1ea107c0fdf821ea06875a597b3a1d95fa3d8c4751dbade6d7c5045148f4ff59ad73d71953ad9d37086f53626676c06c817a1d27b255fc5b5e53823cb3dd10dd76d9beaa44b151cd65679d22ac4111167a3aa51640d42e173c6dbe9a6cce912fba7ec0ee1b8b8bdb00d78453c9c82a0295cb4bd8c1662dd793700dc1b59110018f8d30491135c224d6cf66286cd63a15d704314abe741dcbcbe64a71ffad21d2f9831b731798152aa6e5f825bb557845390c78fd52f36db54749c863cfd5889084c15ac6b661ad334be4b85827921c8d482271e5a649d57e18884fa885b3ee7dc3c732b86d4a54ea3cfd48155ca8cee06e0ccb5651dd93553b7a5be708e4279402eb648fe0f693c24fc8ce74f0c80b210267309ee77f156203e4dfadbf33ba767c4ec9ff711f806764d9290fd3a53d97c7f4583666114531936da52e3b4b9af1458d3f1e525abde8ec822ee5b18d7c0ae11a2e314b228a2c4c0083482b4333fa0b175c9ce426af8c90a9c0dc3e7747465796ddcd58120c4d19ca234e2ab9c55593534344f252496bb5b170cab48d0de48072f729e8263fc6e6b14f9069047a602b3754e72c3f658163dd0d0305ae2dbd629c2bc7958f879ac953ae30c001b8d8cf13553fa28bd4f678abc8c0bbbd11d6d988da8b33cfa20cb091f24070cb8a98121c46300210def7c4ac8e9b45c135c9ba0d04d2c1c173fd58ddca9a690eacc98e1a8e1b5ff485f75cc338eaafcd53e71a4c668a84ca0b0fed2c8baa1979bcda3fd71d02ef4e90e06a3458c99e4a886c0bfbee43b807202b6de0bbe21a4d8bf998ec8cf56e705eb2a507445fe6a9a373f2a9a2256e94e7b61761a2f1b30e44763fd764c2577bedc4188ed02fdaef6542b11ebeb5f0f83921be7e4e2933eb25628c833707282b56cbc5559b35097cad8916b5e9650048455eb7e4f7a7939ccf2a6e69a14ffb4932ab5e7ec6b6938f9408430801f41b10f3b6f50e1e9a5aaf062f7a118f08726664aa371bc2b47ed968c548a34e9f67483c31ebbb8a776f8e3d0cbce57f61a473087200e4aafec8618ac568af859bdeac627a4600e24c2a073de1b38c08e0743f1c9f9133e3774fb2373bbdf3d8929524f8e12f6a55550cf4c2b49e46c31e52a0e598e630c1d946e013c63e9f06adfc53d07fde4e4310059accfe7861d2bce7e25cc66695d758b2ef0ce53646280209e9a294434e6eb5878d0a621dc931b0c88c72fa386590e6aa9be80f29fe810d23e3f3381e4df46009736093bcfd21c2d63727ab720cb602ca5cbc0f31d17e1b9aba88ef30d2e856164e5b5e22f4424c0d9dae45324a201a81372e28c70679c34f0569a2c99e97b83f8244b077df2ca6adb7a9c3ddf12cb477d583a408d20b7c27520c180ba1397897e9e8d10b7173dfdf9debb556460ad866976ba2f28aeed1dc25d12dbdc0884920a067b0bcc4a1da89bd4193a98210c28a7e71da6abb30d8024622713fc6bff39a020004fb5473493aa42275f8911cd55c1bcaf62cf8f90177977276c5fd8b5ebdb865aed8ea6223bb18ee3342cb73ca6c30780d7059e3686e4199f06c74ef629e31dd6b8f1df0e2b843a764d8a0d4848ac47445dd8cca9b566e71c0d4d359d625f495d473eec7344a67a4a814d1803d14359d657d880fcb9fac9523b57c946813c953211953e402689c41f07b0606256250a1c4c0f87dfa736350fa2df7a4de71ccddd0d278aa4b7ad2754db095b583624b74a71d8f358fd19cd6a5aeff670c6a9cbee5e28b0e8d8ab5b632e37f2f0455aa3eb54056a9e00b6c840d61ce3acb6f20ab9f27b55f9aa1d4f4fa9c92679fcbaa1038974649f301168d0608f36436ae4d0d32056b4d38d4c0de2558f774333b1abb70fe4a94826de3b8317a28ea0de06b79e0d001c3deb2fae2cc8776570f667de20054bace0281ee6bcf465a012486f5362f08c640571ab9580767ce59935c44a5a464fe416d2fe8220e8b365f5cb43df541d5d071dcfa1564b9d7e9a8049bd078cf1fecc2b991d6e68b9a4f665f71d1fe36da6de3abd239e1849cc5c1c266ee00245e884b17b1dc94ed019cd3e72ab52f1418eb5aa7ab5131fa67da647261a9813773d379122d34d1c268d682374ffa815e7e766d86790be3ce6e8b15f07b9ea2a4e36afd46b6afc24e86c776a35d8021c8c2e3e11ab7897948e7c2c2a1ab516c892bcdf81546e4f268bab9bac93cf558eb9d3f955ccf3e5ec711d2c0683f7deff35a2552afc8f1dd28e83a9a4da406df76c231d796901f3eea61217857a4d7863093606afb00f127024c0eda2728edd40e78a5ced8f54c79c7744d227985c15618b459ebf17fe11eccbb607a0acab2d9434e706514e4b545b595993c24bc1ca2ccbe03e0ae175471e403b6a3ceb034d04a6bcdfd61c687b8d08c8400fcb1335ca3b9181026bb55170497f8cd2cdb675b8abac038265560b038b806fe6cdd9d088645c64950f7b80ae1b2288544465b678d5d58559caef83cc70a568136c4959010a794c73159deeebb8fe138ad90bf6c66f10e406eb79379982c961692addee5302b7b2b92c388a55e82236b8379c69a7166bd9444d674609798c70b5c03e256e29cc271b4608c0c4ce9b0c3b04c69ae434029b84721c3e0315cf2dd6e9f99821865d32efdc6714a08cc8e61d104491add56660a69503556157b367231efd53a9d80fe4a3640721ed83d2c781ff3fd92d3c32eb48a65dcaef061d84c73b1b875321e85d91c6de2bdcfb3c48e90349309b8760dbb2248b709c4c8f071730f4111e978d518af49660aa28f12dae12c845d0a412c520efb62e40b9c9c2ebe4e5bfaeb20867b354b3a9b6ea78adb799891827a52c7a40c43a3a7695f1c85073b118c09b8bcd56822176a36aced791a096e5585e64222584fe92eb36a9e558cbde5837ba50411d81596e9691747e35f8f3cfd1b9f02e47d0ce78201a3c9c82838979213a0fc09cf97ebc7d279fdb66f45332eb565f64a095c1276ba0a7e65690a35ac07f9a3c8554228c67ec7272252ce2796da731d335e7e35ab534b95f04c7af01ac55b4ddc01f08eea62e4e683c7e384dc78fe172aeea26f7db3b7a7c24cf56a8f18252e89a09d497890eb5932ade70d7988a0e1a626dfbdbd19b3c017c80ad5f710f838cff35e15624fca90c75caa3caf51cbc04766729bf1c8c6c12a3f71a38b402994c3e520f1879f0c2928e5763ed1b5ec83420af024a80442c5a6478cbe1cbb5d16b041f7033ca7a14d23d0777a7a3423d8c273e344f5825b954f74194d34ae68ad1eb0b6fc6691e927e9d789031c801436f989268740169b13259ce14290690c76dd98db389eed54a53d8df43bcf4203a5f897ebba62313cfad8045279381e330d34cd83678fb460c658971700737d7d989069399ac9ca1f53e629e840e25ae642ca8ba0eac9b6754a28129e2aae45456fd31277f421156a9d3e3c9deabf9bfd4fb0ecc0ff135635181336b475c5eb869d1307597e155c55ffaecfa7f8a0727df428b77d42eaf1853896695dc202bdd49334edd27d4522532381466c7f32ccc9df0680baa2d73fe7c9b2d02f39e0ab726d4a71edf7af29d40d87dc7a829f7721539772c5bc892766dfd878818b320ebe7e7780b5b4942957b637a2eb64223d187caf9d402698ef7f387180282d9c28165950b7162053f8a42ee972532de792782d7bde1b95cedeef7e6a909cda4df6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.2与课后课程笔记</title>
      <link href="/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.2%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.2%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1af2860010cdb265d05ce2940e19a3c69d676176588ca6c6f6bd9e3f5f7299bc">83bc12dacc7a0d781bd8e05336f2838bbfdc5b331fdf895a8f9b5f00f6cc7bd2ed9823f95858f6f3e48cd71838546a34b6a3c3399769c63b581ec89264e22d596c445524630f575f5c15784b6e53f258d3429d5e94b6243c8a3e06ec708ed2113a901994fd988e1b1eee80b8c7462a34bd9e7f790b06f42b1070b059c6c8131d2b4eea03147b06d783282fb7a9550303be7db744eaf7c35a886c9e7231ab3b111049f1dd05d4954311fd038689f0916c98b54bdd16caa270f84dea2b11afb793c4903f05f7c10c6f8b4a1258bf0a7aa985aca88963e5e9178dbef96a556fe33c469597fe5744118a9273d41006d68fc27e732ff521edcbae4f45e9c109bf52249f6be2c281f7c2ac6033232c9ee76d76f6488a2f2e337e4f919b4c28de2a8747a8bfa4f24fe8d339d0724d12a5e19516e6952d08da7847df1a4a5e513714a047070b3b98571a3d8b3c2cecf71de571289a279a46e4fe240f4f77dca2e8ae6c7af85c3776cbdbccd725b13adba4f01a75367b7ab715392c8a7d889bc80407468826acb775fb9a2927c63d643148f04a9a806b7e9f98074f7840dd0746c413bbbd7b6c7fa3c73bc29d2f38e2aaae2893d8784aba3835779f75298e6ce639e0e7f742ab44cb8818c95440768ab2a168a02e9f3af6efe07162654f4940ce772ca2852e64d676e9452499f9562ecba61bdaf1701d914d7ae060c160f59ef626f44a9d69c0d2582b3e4a07aa8b2cf8922793273b034019e436ad41b7602422957a0af5ad24cde63ede0f5606786c0600bc7b1d48fa1b85a10d9146f0a4964b338098441860ca7f32bdea95fd0e9c4b9c98f311c54410b7c46d9febe4ab74fbebf7521cc2e6c4d72bfb95d3de5ef65a9984ac0738968ab6b3c1df4cb36b21202cf4eafae08436c3304d6471f28d00201c2580cf238f0acb40ab69db35c85fe4140e1b50964455a950b4bd0978fbfc92c381dbcc8178386c02dc77ad00788cc3353c0ed69db4fac45e9970f603e680bafe9861346aceb1c9924478bd65c0cd143db4ccb4db0a2e60ac42d5ee7dda71c5eb915661399615dbf4ba2b6c49db8309bf2024dc222d83eb2978357371904939a1cf2310e7e9239a875a6dd53b7b5e13cf90ec537e360354e821abc2c90d6c0ea0796d3cff7d1f6d73abd57e65e5047097487e24f59a08831f5c7f9071117c0c3abf1502c69ecc1048b0caaa0baec3176a06ad8c68effe766f45d8380ac4ef5252879ebbc1450d1da7954941c77209e53f8a7151d70af9b547c84bcbc7e1e541294882fb8c73d392ba4e8a73a5b7be223c4a2b386bf6c5e4bbf2858a021f62caa8ff795346eec36eae44d585bf91389109f264a8bdd64de6830317425114d7609e98e074bd15521e8eaffd5565be486be5fda7d51ca7181719d2cb2e76ad6395f5f3d489d950454124c5fb8adef2653d859ad3223ce34b3de4be1dedf1d33297f176a64597f6da0c51fb28d4e7ad9568d9b745a2d7feb8982ee6a3f6886a2ca57f83acaed744714b09598178ab7e49bb268a5416d94819460500c24655f0325df6c2c6814d9b11e4aec592dfc01df0b27e2c03716f8a0e14ab6b01d3747078b0c011aa453361771cf9792f7c19c670dec1790fe0f4a85e76063b64f9e1e088413bfdafc02358c492d58877663da99f100cbc0bce1bed36a4f3b9ee195d4f6c0f94c04e0b516755b7d956f7ee89499a9bf0a85c97d0da5127aac7a6f664cf693a1b2d161b0f9fc999ae348d8d89359de346665cea717921e7c141d278e78a883dc10f71d856c5622c48e20f78a595c50993cc8900e9b91728d1f893cdbcb8629315e975c2cd8808aa67c081dbaf369167cc7e6e263941c56ddfe23db18dca9aaa174f2b1c51a1f9829d114c8bcadd44f4a07d446342571de96ffad983e733c2bafda1d2f4e9d189f333db768fc27dd49211bfb22577047bcac158f723f01779c525a73ba419015dd9cc102821961fbd58cc5a613c7a642ebf67ad909b671a5229cb07710f10a21ee74d5da8ab6cc0a185ed142aa332b6bc6c9f168809ec9de1c8c17b00e8eb93395c578d005d02aebf4aafccb32502e88c52e4483d182dbc6cab821ad847b47311b1504f073e2b97461c1a00a39f863e3674a4e986082676e5727f180082f58873317dbc10f299be426350851099baf17fdaa065562a7da8e1b63b2f5cb16a117f03f68a8e50f36c5973fb13e1796aaf03e333771d9d4ed18ffcf313d82a0dd9cacc812c71c29e5944b8fad3247d697087f9c32cc51e62f3b57acdd579d949a321cc22ffa8aed0863436feb7e21abfe4640c1b4faefb59d09fd4cc89c2c4cb4471bbf79ec5447ea63ef3a92c2d82371d338c7f054f003337bd6621ab2b823f8bce183eef7ce16dbadddd765b9c001905841429c61902149c38b58eceae984272e3ea53718e20608ad9e75cbce0948d04709db6f33ace69b908c1c4c78856351a7b16506d13c8df640f93ff77d15790f0721747237e9bcc90a765530b7ae1cb3411e164c02f8851c31a8732c61abe078434ddf2bd685a46d7ab130e1aeeaf1119627aaee4569d838bb57b81f62bf1221814cd82ea629944237e1408c11f610e2c41667fcb864791a92dd85d004d4222a707ec1f5808506a0795039928e9d3fc1c6588aca8a42dcf129f93705a1ff8142e23f70039ae76655eb4eb7a82ed868898a4006e8df9b018c2434f1856669dad7870236b6ebd0d763d67b178f01e1dbd9ef840c1def1b822d63deb896235ebb099926bac39e9065794f2321c0ad281cdebbf71d3955d3660857e9ae085d700f420e8cd5dc0fac8cb3d50e4c271acdca920fd92f4e53268c4a5c8d88181866257dda3e96a2b97eeb61bfe4647009e1c89e3b1327cf2a94a10bbc56c42541c7b8ee59fc1504bc506c1af1fbf299fda8a377ba90437dd10aae20aaa22218ce13cfb407159fb3869b4939924fb9f37d50801beb29bea3d9161389a9bd0867bd09085610dd5112797adcac325728d0d6c4f9ed75af0e1045158b82bed5b2c5f2ea69d3863e9e47b99435cdbbb5107f789340c3e05d6d1f19410ffd18dc4200d145e9362c38c8650a3b7e0138eecfb44bbf3710f720cc5a6cb31cf078210e95ed3aaeda3407ec22e412ed656de078360491ab82ad28373305d29285f0dc0675ed3c365fdb5e2f2b3297a3a9fdf76a4df249d9e8d4bbde4098ccfd20d82ec19daf1e3fff224569991a12fa79bac393cb4f92da7cdd9bb421ab33304eaefcbbc95073a921619fb7a904ec565bf1fb9d6dac30cac48b439d20807fa92e6d4216fc02483bcf004133473ecd432b429d1af867ba916d13adbeee4e352c90aefa73a67660c84a7de395e80bfcde1afcbe97dff6714dbbaa80d7834da8ee1ad93a307740abc1781b25d22e11c0a32eef59040ddcdf573895ce15e773bdd07fe0ccee39008bbcbb4df5835fc214caca714ea815b09457a8c956cd722256282a7860c56afb72b4603d96526e5df9bc76974d3bdb5113b9e2b0dbd039db01e2b8bcbbaeb95cb5a5804f50629daefa7fcfb875cbbe6fcb241fd5c0adf1c99338bd560bd4b8c05adeaf9ec8198f4e7f9213db945af901ef891a0dcc42c897ad2edf3df0e9076a4ff9217f6217f2285f454bde821e0fdd81e9a81ec481e1596280f4e7fe23e67a3b2fd926edb13d8f966f1cd46d6c258587f058b30c087664d41ea01da312bcd547d0c70f927ea819d8f11f85f2d862bef522fe0ecf1d75d4916c1fe34f698d8d62ca8419182499cd9d6f53c065be87ba7042344283d1e862210656dde2761972461d56472cf99b3bba102dfd8ba1daf92c044bfef3bb06f973c0ef3599eca04d1015ab48eb4f0633680838c8fb46e80a122b886dd724abb5e2610377a42136a73bcdfbb9c9e828e75dd814695cc77fa558a36be032fa837776aa56c19e2db00950fea1029dd69a0c4a5d1aeac60fe19b242da0dd984358be030c60dec08472adba6cb5f4ac639fb9252a1845232723acb9d581f2b94ed62f6621babb1ce705ef1b9b2985f9c7369ed145c5881aebde8490392e48972aa1633e5cfe854902e588218e37d03c0c5e3a947716a47f36d75a49243a41288503dd7ccc4cc361f4420d998b9111359201a88bd3d2ff38405e5d48d50bc6381387d49015019594f21ad49ddf7a7ce1003cd20c372d249017116d4e1334eae678687cc08eccdea0b8cd1e1e00644e97b5eb7b85a88c3d2cfba6c0c0fa16db29277d84a31b342d5fd7c40b7db60b4bf6560528a5330a6a2fc1579c0a3e1b9cd1301f3673fce9fa3c56c494669c14dd66b9e813f6b73741824be7e35799cba68209c62726a18beac53307ed4e26cff898bf22a26a314859562853ea62a55c64ade764aed4ca4350f4fd860790262a47cfe3372efc0af49102c76df4e65c923d35c1f90225a23e8dfbf083c2f4ad2e31710ba66b0c62c8881f66126e61b245ae03111384b254acf26e330fdbf641db5cda78dbde9c9131e539afdfe5a4060ac508364dd2117dc32b59bb9729f7a6b40f7f498bd74fc860f25db10a0a1c27b7b3de1c157258e0cbc227d6f502d8839bbdb38caf559074c46d87109ebf615335d4aa48233f658cd89df965a0f8aa22772fe895b03dda4429896f743c6ca564c7d2955fb28d433d3afc4dcd7057e870d6b46fa1474bfc57b0551a136b5ef935adc38c1d58cf3cfcc196087f0f22d5be550acd68dfd5ed463b3345685e51ea8801b0b6bb812ac152533d72535aea261eeb6ebdd632f44a26a90c473cd055b575d5da12005bcf4565892204445e432cc5e7015b3e8a47e0e813f6759025dbdad1fb587313a7eab4ccf2bd1f65726319b720495e8c239b07d51aea8debd64fea3af468f240f5501b5a180ba81ffdee71f95436b6529a04151e5484c1dd747c0750efb88ba7b4bfc20a90e891bac2deebebb6dfea5bd9c21336a8acbf4726f856c93ed211e0f6b0f498a98880319820ef4a3253a61ba9565a9955f9dac6eb23a21c2e7f26e48b0d9f6b6385d6b85e701be9e07ee0a9d7d9b5229135b3f71e2da9adb65ede9407a06376b05097949b4df542e7a391f592b86838e4e809e68c015fd702dce127b7fd8a3207c61af3fee004dae30bcd12594af5f7c2c8b3ad9bee67d99e3faf268fb4a1a1e566158b2156e06ada58d60dd5385c53f57a6267b9d94c96ae923f4300e263a58789d4dd5ef24c11cb5e6423dc62b4fffc16bcd9c71c1c5d991f94eef499b1f1a09519dcd1910fa945ea0c8193ea088e0f8d379169bca9c75a28e93679f47f2b95928f935e1c0f7234da3b71845470d666eb51b6832779206dfe8851092f3516c9246d25c9854c48e8edf7bd2a50b7d0596b9b0aa4036a88f8f2d5b736be5d792d30b183d57181b7d594437abbf01da272fb3031a1efe6a9ca50fc93cbf784914580572b911e8a5c0d7887f0167c07649fe4cff9ac1fe691eae074a589afea768ff6e4745918df1fe56e2d43c800a1afeb92dcbd237883c49fd6cedab67a06a8155a15dd02b023a49bf6f7c212f90d05ede9bcf1a491d594e5244032a3c8abf0bd141c41aa088330ff4b591b8d8d56abe649ccbf503213b62f775f5965bec8c1b3875059a03a0e2a785debb68bd6bf11d1371f34b4484765b58c472352d9ce71d58752536aef1afb65f053f0d5a15b266086e8017182e55905936baba29fd0f1bce7042e4b435e43ea153491fbebdc96c318735b42618c7904e871666935152c14f62a588697dc98622b504197ec6865091e52b9107d50ed29cb2d1893f3de99e5232020b42b7ea119b6f0de0988e5069b619ee211f5f83e3352562f44b1767ae089095ee70d8f556d55940880d94fc933a9500735ac752716f997ebf30e0b52fbd0524453c845781aaf5716faae0e60481b4862add605cce5d4b5cbfa1cb438db53e38ae87ec43d2666094ec223eb730161543190e43d981cf9bc4506950685ded83d55459ea27bd89c4e6ab8d397b1cc3c69317aead6bd5dd2eee8d81236ec3427df0d0235d970f59ecfe08b261d934e3cc55e3967596012ba3ff363a37b7d85d6bec123f5e3453c42769fee327295db542b1e0380e7dd5a25857754ff2bdcfa1f83f29113b04c19b0cb9c7ed786fcfbc5d3101ad72adb7f724f06c1709efeba20c723572bc3f2fffeb7e47261b4cde3a0f221888efb265681962051a9f999f397d45886b9ff09951573e551204bd2bade577449a0b8c749d4efb31610e90a2f8837f6d0acc99ce4e7aabda16b0484fd9090712f3a015d3955936f03fd4e376883e097ddda2c11bc8aff5c0c857e485b2862b169664d82a010c9ef9f0522e4a57878ebe0f443e358ac5fd3d33576db98b1ac50109f65df9bcf3db2d906fb87d31530664d1b5d7763e9e409919264077c4cfbde00539a93d4226a37b152ec99dda1941fbe65c4b366b9c7f5bd4c905cb6c570d841980f2bc90940b0cea3cefab607e34f9fdbf89ce10782072a9109307f7a39c968f60bb23f8c6cc797e69f6e9059bbf8dd981ce6e4afaeac33f9392dfe1afc36f99297734b24d74ff00883c89aa8b41d72664e7949628cb514c81136c6131c41eee3a8e8e84c758310b41b58372161ccbbb8acf2561d5fe4b9ec52a6c9ed7d706380e5a05a83a7b577462b0ef6ce4f3e8f13385207565b8fc2c58def6419e772bd233553b02a8334720a245f5eb190c1c833954991bfdf312cd0200f753eac990c54a48a1d9baa5cee14afcc1524e24adf139012cc3f008f1f0e4f05fda2c434ddad9919e245bed57006dcbf9baa41e5a51cd77e848445c754932956681268b39fe5e1044e0e5b70f30c6c10f4c43d600d66ca3f9c3d8dddc85c5ff428f28e769ff5d4164fe4936e243d128b6b746478d71b9908a4bcb2c560a6588c935fe79cd6c3c51984c8690982847b95143590e2f7e2705e1671ef9b388370c5b2e90da4fbb2216b73ea5be92459b6b7ed258798594ce6b9da8f6ed32a8ad59447352500492d05925f46a9215d2a5fff75ea54ebc9c78e3ccd6cf02d11e8faa66807eb25bf628cea73e61603f35ccd9ee769517a042d2a03657b2d406ff54c6d8da61d4cac1a0e7821a987f837a1d0119fb8e9661e8bdd6945ca67df5e56eb24e6a625fc2bf5f14592ca1cd68f96cd65cb1f5c88cb861e152f11bf03d9dfbabb40ed038a5d0084be09065a65f2f5e9b232184b525ecba63505e3edc486648435c08c07a3e144b553969bb0e3e47dd534c176aa4a5dbea92fbd2cb092f0aebcd703bf49270d888111e7b4b3d140ef55d1fb9d016851e100dfc180e85f24821a18a07e6af268af2e838633212b19199532a2b9820baae7312d8f995caae208f3f3ff1368059c8885e60ab2dd5a443dc7e95af4267ad145fdabd2f4824ec764de0af8b3c7b852ee2270182b30afe6bdb0cfefdce4b8558ef8738028e483b194b718360706f0bc29f57d8bedcfb34a5d9dfaf7d4729a20c41b6742c0f094992dd635b2049fd605009e361ba78d3429f0d97ea66e34c02bf16b0e298d76e71885d2d090bb1b5a661118c9d511aa5084a7f5c037c0eb35ccb433c59351cdfaa176f1e316483a625a0abb570eb44ddc3950f26d65673f69526b60e2e820e14995aa733a18e709d313af490b33fcd8d001d8e7510c3734c77a3e94e7ca9e8d80dfc943e24a252043d70a7f8a0cf49515397dfb0de9324b16291c56cc9060713b0899cf554e1fa7582bfaefcf168b16aada292933d752811aa5e7bd42f8a4759dbfc77662c359a251f816e6d973a4fd3fea09bdfa95a2cf5fabe2ba9aa370f514478606ab5d19746168c34aa9f947d406745f891a9d7936ee586a16b586adacbcb23dd68ed78de639194b7ea62a4fd8cdf70e0cb7b821c7b52196d4d5b8a4583d10af17dfbfb7252cb538c9c2bb89bda2c08ad3dbcd4af0b1f8fd750b9ad00feb26dd714365e2dd83ed587a04baab7e44a5356c9423175e9929720129263756cac86c7d4bc16afa13a329c808c129d9eb842e8f15422dac8bdfa6042cd78403cb4e589ef1ce1b0c599e6922f45cd78e8cd0ebf493f48dee230ff6aaa897808830017d9797cca910394265d83fc17bd0c596903e0680ef617f3ceafc87c10a1ed9beedc6e818c779fbe33ad5c3885bc007b982b3b21a518bde6b371140c3b9c230a6c07ea6494533a4d1c7655f9ac9c9684d9a2ff525271477e3bd78e68ebd82570c4803c64e0980d7caeb7dc5278f429dc1145f2e93e189d2e729edf30910cf92f77be763921199f46fe8834f65be7fef9a05904ef87b6e20df1cd615cf1cd6170166026239a12b958e642d7e53ebe9266bbbd8c0d1829527670075057d1c800704f4eef567ad0ce010c3738e3f77b20f8aa3c7ef37d07be848ab7bf892688cb53bb98fd2a7a39fa18cfd84194a9482982d78b26b05a849961159be1b8a011476add43cfd8ede4d0322b0ee32e7ae0dea4e5ba69b6095f0b80f6185595a0e0d7a7ed4c148cb6d8540e87e9df97339297a62428d63a922f0deb557b4272d5671834e04d36e6333da568c8ca8a09929b1470e07c55a2e131bc641d659d588fbae8f71a84dfead30886c5fa34b7adbe3547ecbddba8aed4377a8848e34cdc25656f65891f581c9018dcf7fa7099e3183045472f4876c6cf7a7db84bc626972d58253f08f9e589daf2f9b0dbfc26f883fd2a780a4cfb52ebf98dc92607a2d3d2998dce2ebbfbaf66a8fdd8fdcfbb6a532c296101cd5a7968fad4fbc88ec4202f4074d5080ceddecb5777d2ebedd44babd6508e6d89d7a945e47d499551e125510f57b046f105b9cfc1de9d8e1d0e86cb78db386d7a643182dfab93f4b4f17b287bb17f184a08c51c8036404763c028884bb205a564efa691b80d93053a787a496edb4cba9b6765a8f9075dd6331df00235dac1fe5b05e924e6609137c5bb56fa72cf116decf49c154df538f838212f47d61c7e87fa04035dbc9a0f37ec3afdbfa0f86bb91ab134ad4ffd9fec96e5a8109b7b129e116e9be1bc0b6d39f5e35933e85b222fe4793eb8aedfcaeee8c8b394887587773d2c175cef5df1b582a3e3d70fccf0ea70d99a627ed5ab3e41d523974441aee0cb3cf3b68ed6dc88994ef37c151792df7de701a871456cd140f9d6611e9c458e60dab238be4dbc704b27f35b3de43050f772876c32b47e152f437faff6b175afc3eaba70d8b5249a536bfa05c797454c7fe1155534c66b284a6a699823328e1b45c466d50059b2fd18da6375c49fb601bde194192c2aba2980c7456aeaf940ba8085cbeb3c17bda8a8b43408aa1c765fd9a27c7ad4ee742e37842632f64fe1f54024aa320464367e8acf98dc5f0f34a39d755cd1c906cb4a50637f0c31dac42fd1d13ae15e8a369d56f23062ac3d3de66c66705be13e8fbda6057a2ef211b6bf6ba5c6403560564f2e58442a64ae8e3cab078ebc97d1fe5b65336e6058d225c31451df021f8de36e0a77218f6fc9cda62c3c9ae748f180b47d83b2b118766ef964be83f5c096651122808ccfcf233d2acebf79220f6f0c94be5cbfb6a7f6bbb747d66f7a0fd45e3a263090d3858ae32b51c1a711233fcd840b44b29d73deed3939c4aa0e1cb4d88aa3c79a33c1e093be48a02fc3d69f0f893d72edb2b7b55fd667dbc76de2078ea1c73e4115301d4cff1f79c21675fc54456d9670247912fe55feddec1b45dc7bc7e1631ad8615fbc2e727c8b14b8355b38a2cea8a14e0383ea4654538f4ed31d595ecddedf46a35096b009aef1ba0130e4c3a6c3c427a58a7dc16dae4d16c317c18203d263ac9086d20bdd1601bbb9a02e3b212b2d3b8f649b47b2c93bb6d7940b842f00ad9950db6db13de41f512e02ca0a790bc5d8ea556e8c485b55a243c16a7a32a4af05400f8c4853af5102b77e33421a31a18102b3f0a68344edea38b659b4782439b383de5a3243423e32b2a62e5c927635b8f191f6fd0174f42443c95b7e083907320a1d7a3e5f00d676b3a5bb365dbcaeaec74885991bd51dad0fece5d92f2187628ffaf4062ba0445c331182c4cfa1f8828dd5445bff96770cad26c0b585e5d7c805dfa321a7eb9a647dc2007a3b0943a69ad6e336d4d648d8c47fb8de67beceada46376f2a65e34cd9a15a8f0232b80307dcabc9443c700e4bb336d2b6346ec46e0feba13240ac1ad5ccbadb2b6218b07345a852b3f32b1cb876cff7fec183467eb52b02598c2bdc47e99fee0c997598c3cec85f5dcd42e21647119bf968088abbdfef81dc5053c1ded6332d8dc2d812940828dec64c94c76518309f53a5ee73f16e756d5c58f868bcf1d5427d903e98fecafd397d2bee001992039d58daa06dc0f29c84f21b1e667f4fb9ced300df529a7ec5a885bd48ada355821072e43e975603b1a9c8bcb55483af5acebeddd4033b26163d94f45fc35fbe603397669814560d66844679c10f23608ce24d3136d5aa0881ada1c4f14117ef8b1b78228eaad2f2f3a1f76341b5b43db39ac1c974269b1350e6f803c8c8843c7748110e115971f45f23e0a78ec9afd7d3e6dfe7c08d699b849505aa9af5eeb065410f338e98c3fc7b679a03b83ba2a8bfaa715a72379007030f01d982d86c2eb49056eab9b7607d9592c41e5f317938e034ca86c9aae026a481b77605bf2f68623bde07bb87c7f60d4f93ed48327c4f557a072061da0008e8f4dbcd4a69cac913b3c5e5b15d02c1df5bb90e34b7e5c41162ebe2b49d148d6f65ace6b3e9df0b78dcb556e48c06509eeb1986ef7a0c594e94f25e6a65506129af4cf6491a3a631fa9a864f6ed7475378cf9281993882da855f6c6963536f01a9bc20ce6368528829b8dd276374c78f26b0a6639ed6b5a6b4d4316499977b1ed8d13f99ea6c20b5782fa5c56469051d6cdb593156bc1553917b83366b215e664440994c5bcbe17e98786194736314dbb3d9e43911c25031c2f12eff2c92430539dd4c357947de10b4ecff0e32e73a96837802af539805c4b084b72d3ccfdd07092e499afe54c29ca380fa3db5d846af41db7d3d37aa2b67695e8f7093708d55c7fec583fef74ff481d7cebdeec403d330e4d507808b7d70cc34766eab6cdb88ff308fbc88ad4b5121be0f04b60b37c6338394012f36e6a32eaae82f52a918027d6d1054c4c8558a7a2cab41a3ac3ed140cfaf0507b934568ddd38465d53153af955967dd2854f47aaff38dacf79048574a613573607bb41436559ff367343498d9a36c0cb3ba02465db47c37999e5639b0e8dd8c320425eefac0769f692b9227cae05f31b2c5ab775d29ad1a7735fd581ed88d2e91522f7a95be3f79379b301b10fad1ecb304dc63f2bc5e3307ecc40bc4518e38bb653abeb59ee362f3ad146eea8c207141ec1b51cbc165fa1a4144b4143cb14e9075a194441de69e03d2506b92ef26c918f5459e92885a7066c9d8e95a7d5571c21a6264e58db1ed04695805cb5191779d0a05ee3d1e90c4900864fe96fe0a51400c92e7349f75a4f3a93d600a8bb0648b84239843f5a0ae17319de29bc71aa2cb99b6dff2a79db231d532886ddc7093df1d0b8c7fecad9242ed7ee63856b009a4a94ed6768ad30b66a770f02e3619ab984c199e78b831040731823a831e9fc55a66777dae1ae022a3cb72cb86a454a137ef0d2e31cea2b21c053a8951b1f61d42b8716d8f8a1b5ee24dd8e71e46cf7c683a5e67a07b4066c28a52f65baf7001843671808c8b744cda80476e799c709b11ae676f8b1da180bcd90276b52aa4168de224e6b9a018c8b03ce7aca1d0c8650cb1ad2ab73661745fd80a37a3c3dafffc21db5ef706e65ffb2bd8da829a46e2b4d9663baa0cd5fed0f01a24f1061fcc58732f7ea27b9f04f8f496169515ebcf14c506c9953841eed6c740eeef414517f2a195206699c2290925923ba6e51eb39d293a80819efa5551282bfae5f4fea1b4d29abb9288eb06cfdfa3259185313de0ca148bdaf81515dedcb6f9b5660f0c55469c910e5ebcb92808444077ee2cff7d322dccb46a3f050a8a844e6e94db0cdf9de94eda61aee7601f2c10bd41def8c9ab046ddf652f71e28e6f05d939f9f556e5a7b23b21faaa39a26b68b1d325d2184ff84c074c0e902a4cd16e86136cca09689c962e6c868e0e51064df32d64e02db34ed82e6adc3965331dcf28a5a561db528fa2d124e9f2a59f55254b2cab2b7112c7f981ef57caa963f1ecd750079457bd2a802767541af1ab9a669196285e07fc129d688dea1379dfe931e637a2d614d00a5819a391228079ed396af43238d945d3e72eb3dbc1c8e858bbbdc2faa8ee314538e7d4cbd4031b28379ef8c85646a6def987bd525fe091fffc5527279116e8232d865aed5a8055c6c51540d0385bf42daab57e85b45e11e99aaaee5e66fbd2c29d6fadbfb349cf797dd847dc03a0f73e73c7dedda7b485f36b62346b7662882da60444160fa5d29ecb01cbdc9b2687ea2ee131d81e39a03c3f802fa25a579c03b744875cda1d0678022a65a1adc17a47bb46466b5ea94b7ce2f73d3582ee7629c5931619d02626fa7d93970034593f499522502a12d904597406ba933af2fd6a79e9e5e0f8edeb0c8f2425bdfb039d1cf103b98f7155c17667c58891860e616bc475004f014ad71d3ff18ee1495fdb38faaf9b1443bd4d998b29867632ea9dafeb08ff6b5a5adf2ed5c4d2314ba54ae37f8f14e28993bf82a801b467630c60ab3813a9d1fa7e87a254a12b5dabb5d4ad698d7ebae4bcd3f93c4c3b1ebed644094df0a7b70c68e2b3f4f4497be8e77b70e781e7ea2207118407b5cd0dd2c2f004792658fa9a9377dd239bf1be1aae890115941fe75cc61894a6dca3c832921573de79937322ae135c97e1f1f47d64a8a1c3c10e513ae19891f6f5f53f40b6b8e4e32f4ab7e957613c6cbd73d4f025f8c53fafd564efd2d9024d877e0760c3beb4dd8dbc98d7f05a0b6e9b2510060ca1879544819e9de6d012c6ba4cce642fc5a34f5026faa794ad996be58be429a400bdefdd991698f3c429d41cee21c56ca1e248443c84f0937cc429efa95064fde1da65b36f616247e3711ec006989d699edb2ec6e71b806569ac91c27cfd199549b083deb901e27cb70f3364ea4754f78c58d067b47df6dab0c2f78ec21a4e14d2684b5ecbc322b930fc7b78603c6ec77251f6810bfe81dc0f5a38a93f12f785d3cd4b4ae75318c8f56777213b364b487224974f6b51a8413f59fab793f7949527638b7b800f4b63537dbf237509d221ab5691e0e59e4550b02bb2a544d3d099c61493242c444e2cc0c68a46626dfe37f4b67f6e953d860050e6ea1455131aee2f8782c9574e88e170c76523b457b8389ae4a911e52976926b0ef036ff588f88e31ce6d5e0ba680f30d0320d8018460a5578567829001b3d6eb6d8cbf1eb117d0f136983706e34b3cc33216425feea1d86045237e8b1f6a494e321743e08994950a845c1872b709ff9b801f1f0f887ee1668535ead7d6b9db106a072e704abeb02913f9090571d7d26691cd487e26cb80f7a6fb1f8565989cc2bae081ee5938eb805c653851c7020c5b13de9daf031b1d9363ed350db25d445e81f58979ac3f17aa900592ecf316997ea4e83fdc82e211f3bdcdae39b5515344c3899284b4c3a379a481ffd73b9c76b47aa21e015274179cf2391bb70f28b502b21e2e204c19120e89c1e56c9a8e93cf80aeffb781d7e6000596bebfd6dc316f35647ff9a384b2abcb5da9a41ed9b5dbf1f9043a6bc31f9fe4ed040b7d075181533e165f39b3092896afa856b93ebbab2fc67018c38d9d72558648581ba37dde39fc5266117f3005c1d54db29b371387a76cb02bac5df91f73025faf6dd00f4510443b4db961b5c88275cdd503bb594321a37fb81675ef72947d50cf84cfdfd7d77e97c884022179c9615fee840964b4694127debcefdf4f9ca14845c2e0c20bc7749642329178540a2457c66835dc7b3e0586fb8aed1bf2163f2ffec217482881c92a04c26bec26589fd273bfb6c8fac8c3fed9c37cb52425923544e2f6c0cc2cd1fcb021c171a0bf43ccab2a1febedc6ba0776e11b1400fd9ca349533e86354e42d2fb101f22b5c69fa0659a0740f0c316b44b63f5a580386e148e95a89a39d75d20698df09252dae98359201c7c5cdaf86da9cee154a54374c0b01980706ef2aed8b935206acfaca4e4db63ab3a49fb63b66da46755a63eb9ef2595fd890ac5ad05908915e772748c87408e121592927846d2226a1d85e83cc7e4be56cbac6c9095aae00b7d9399f91afd28a957e9212b15eeca7c42524ac59d5ffda7dd058aeaeef6f967f61c05d26abcb0f3822f28a7842158d60ffb3050271327186954447a0b75a63fa3e4606ddb0b2fb68a651f6002ed185f1ef8f41d89cee206f38eb13b75d3ffb12bb1c30726eca3a4d5fcb442c884182589415ff5d597246c5cbc09e7e7e47f10ec059bd94256478ae07d700e96502d85d59070588c4e1274400b2db5124a0b72a56fcb61e9df8fa9cb4f09c88e08f91c7982e6a0356758bef51f566edbc2ccfd2e926e1a0b7a4fbb0c18fa5158ba9475e80ce1035d54d671acdd54453f20383c6f762e8ceece45d9727ed556cb30a3d5791dbf13a9bc76287238f0a4e77fa1b5cf46fa9036ab721b4dea88d9c6990ec71f7f42324aaa6087acc9c13ab3f9a6f34b89188fb04bdc6e9689aecbb7d860dcbbea1b9f7aff094ef621b316a1d516db4d6ac13fe2664b804910f8063cd6d436b24bff1daa3a6af90fb4cd97ed82b8c19a86d5e5a2d1e1ea01e152cab7e18534f18fa3cb7e6fee23e5057367a210357e3aa2dc475c1c68b989893b4aee453c1e77608c24af3def735414afd56247e2579f6de365b214a21f90ff761278816e10a0168b0fefacfba51e1ccf0c64727b9b25c7bb74360675ea02ca4c6e1c1832199a9bb0c27cc45e9a34450057a8c1e3a01f9f0e696b782df602ea99e4240d50ba43e9b926ea3b1b35a918e876ebd04dbd11d7ab76b0c7fedc4752637d6c725f3112815eaa15a1be668cab4d7323a7fed2cdf81663f49524c8529cd81ec64a0d8df436398810b134c281ec14340eb5f772c5a32b0e826e39419355c0dfcfd6cc9fdf28f795e8cda8c564cb642bfcde197524d242e168815c7f815f12449b677558c0bf5d19556492280502997d95cffbe79b55cbe7dba110b9f742e2d0891b4ddb0ee80d7679c801ad9225151598c9319b2723635e8b91a5b4b1eb2a65d2e9cdbb673a87b85a062acf67dd5ed3b815e57edbcb06207c58a29a9f2ab0a5cab45b0e9825de44b53989abd25c4dd345cf56087fe267c729ae962bc6640e95716609438580097769393397698f93c63195289995db312ad3cd36569205e5c0e18cb8b70c1862903ad329a4dd8462539499a9787299f88eaa18eb0b88baecc48822743d4f4e4a433822e3cb1d8f052cedcbccef4c33aa3e7260098c17e8b31d293e7d449df8ab185b09e9cd2de42c6d6c575a296d642fd89c4875700025b7ba23b0f935b2a685aa5d93c19759287b2e84f8277d13840fd0a004e6f18159b991438086d207b5e42851e5acefa6732ead15ec88967d42f8920250fc2ca6f41e45b93d69ceb9c46e136eea8f3d92b9c1d0315d346f0e31ac52623c7955d4258dee87be4fb6424f42f956fba0041c6872aae40679c088ac0a5f1fb96b996eef4c3a1332c5e2c2dbbc85f5c7e654abfe6987f4cea5e5f1ce908fa754fec81cf374db5afd4e0fb630ecee10c76d8e70d1de4a093c3c045f0b48897ad6f9d30449b4add5323f792c481aee394a25af85728c4fb55c2aa624b6ab0b68d9ad097fcb8d8b876407b9d7fd24d033a9d685b2cc38a73cc00f42547f892d6033bd4c59fbc0beae8be8cbce830e0ce9ed34242c53afba371b6cf585bbfab27588842d8e51fd7423434c068773f5168cf6e4d2eec774b1dcf95b220c9e3924027e6800335bf1257e6b0e65efe2808d1b9ad185adf9071ccc69ad0698e7c805d83e07fee16909ad927eecba1c5bffb0334fdc11be4b5062cc1f78f5386ea0a4c387a8c0114d770925ee0a47a3e1273b2866fbab44fd6c780c9bba75c1a24a127531de80c717ad394d65de3b805d651c0dfe4d866eeaa6110f5df7ebc49fbc730358637526bdcd2ceeaa0b65c007f9ef6754ca0a2b590dc6a9d3f19cd7b459d7686fca0dfcdf916967666aadcc04da585045ce2cf089539a0f7b03fc75b1fffc779a66df1520c90941802ec79a0c484de9937025da5a1e36c3dbf30f7e692c2f2d57def43a1a005036fea93c443196c9c5b14e5e754a40c1573a497c0042804bc1cacb5ba9e9e575f46773303fa632e8b607af33b8f080ac9005dc0955bc1de066b6269ddf942a5b761ab1d2fdd201ad354fdb821490634fb04d0fc82a90d68c035041b8c557c179e69ad17fdf2b438d94e18e0e6a4f5b78f123d5268019a5257d1110fd7cfd71fbcc485b21320a7f70b913f3e90f2724e626425acfe0ff92dbfa608567ef9467e1e55e69c04e3d90a59abab2d9307ff836af027e0ce5c8ba44676fd6befe9551e4a5aa8eb0cc4e01469884df2549723eaef9c70469da373d0477c23b7a2b5718348fb4d7137bed8397d4c4afd62fd1710da74216fd035163a38a77216dae842186e65c07b3589b2804477c6fffbe855c1435f45e2ac6cbe0711567a4acb0f4f672ac36c31c15dead95746dc83eb9b21acb9b610a334eb843f5785bc57c19b915513ec8c3e068cdf7a31c69eae4c3510f1ef6fc387ce75c9b07cca29773bb6c88dab75608916f5e49bb86acc0761783e0202526345d3a17c7d1cb2c2b103f519f6c20ea470901c868796e848c93d9825b3e1a5d8e9373c7de449cfaeb5bf188783508350bbe17cc448a38afddb67ed688a74c0e0d60ff31f06c55e44a7d6b0197829dc8b221b50c2f0cb3b192e8746189a0581de16c7896109b2010500f7b292a903a4f54a200ef50e39370be25f30053a5f22eaef8cb3b114ede1b000101c8620fc3ef3113c21688e96a1a427aab7b418e8cd1c0886a21ec0c402ff6061e35bd5175ff6909e195eff0484925eb04751873c29b836336b4be2df70278bcd93b555b695513f91b6e9e33adc065772d932eed8f94b19eab25c48477432192bbfaebdd83a4c6e3a2f5f4093ebef2156844a0bc623e1a66a738d8a3f5057d5ea06be7733f6d681f038fee0c0bb9dd795e237309a9984d70ce5c5857e31da3bbf5aec0e6f3edcb4a7d21cb4aaefa7943a4053fc8c1185106d658a0e970a1732b720ee023bc49b497f8ad09be7bea763346758e1bfab0a9501fe203b77d29239dbcc5082ab0e06be6d703cb910b50081ad713d68cfdba80e9773a113ce30e0c0ec4f19e658e7447d85f7997d59aeb2a88d4578e7e223ef6edf3d57e6539518779e93b7f6eacfae7b207cefb053d3ef1d0e8d26ed13b3890f4e9f37561a2db530004f4e3a8c436f1828890efc1be7b0b76e156e71af7e953ae0ca3a36f32031ff05ca3bb84f14dc86a608cd5e436070d5f934fec2374ca6696c2c587cd8785c42efde5133a97dc6555a65156bdf1ef70fa5844d0aa0830e58f183166bb0d1034b2f290e21f2ae598af1fa079bec2d9e11291567d4d63f2da73bdfcf5c77b4a62621068340dc985da6f18be066aaf1476b331f2a5d84879f7190784a32c85e1ab805115b9ef6ec983e469c020cd700d71b619c0cf0eda376faed1b0f7d521a93b1d2fd9c953447e48f4bf3e3ded09993dd81d97b2b3edc9a5345f3e5bb4951597693a041111ede78551039ac653f19e2b8f494e89bca4def02ca853086c78148a08bb5ec8b98ae82b6dc41028a65b5742cb57175dbe1b1fe80d2d685e27361b69bab58b6d9d1b7d5771cc5751f59eef17c79a18c54dd6d509021e1dff3d9d778344f9a862e6850114cefde17d165487a2f1293a79baed3f6e25a1233f7131186d60ee064fad1a35013a89cb70d0f64628c0b4fc1f6e7f5debe26b52a121456bf97fdf5977271bd28fe3855595554af2996a2d6d3d36a15aed98fbd63e922106e14f26c1390c9c479a327ec1eda1159fd1ca427f71165c51bc0223f5aafdb0a5908641411d0181e1d09a47ee44499a75ec5edb73f3908b7dbe1162cecae3b09f516e22497e201f6375d6e5e5f4d2c6a319240a9c8dcbf1d1030e23940e2c2448e4635ba8ef651f8aa532fee90a9d1303b6c0cdc080d979ed0b1ece3616152ec510aff64bcfb72f5f91f0b749b970defc8846e1d7a361257763a3a74c4c96716bc4e4a2c134cec028fed00f640328ff7e38f95a9a4bd45a37fff6d09bcdad1e1490827dee38455feab3225e205aa14b6cde4363ba7a41ac3de0a18950cae703d8aa0b4e00587dd86551d42a548d53f0c9c86a2d538f3c6a1381f5f6472e3e3d9edb6a8779a018ccd9bfe87f0f9d28bb7d5c69668c613227aeee1a7deea65b053340ea4bc9dcf99fe91ff0e085c8ced036f977e189dfdf4ed07d0a9c5f9d38c76a52dcb7a0ea242bf9621543ba42c19323e610a2bb0f8fc42d726f5e7ddd7590eec28c2ff943d73af369a0a38e696089ced14913ae6343b6154ef60f16329d7447159e6afcb646274644636d7cb36d00ddeaa61af711327ff7767ebd74063f5ff7aa13eb19468367f43b27d5a32b183d2f85c49c9cdaf3cc609897fc06211d9575e6388acc7669e798d61c6f5ec099b1d00213bf0d95cb433956ba5e0e436d791bd6318bc3f006d99f2391334ab0a093fce9e93e92fa5b7e1c4c15ee2a77e9ebd953b796e56d6df294b71316d4406be41390c2e37a950251e38030d34c5b01a7281010428d2beecb400e613b74d29f5d971d07e3610bd9565f86664a0fa6845adbdf851d332255558aec8fd29e44b75647c440fbeb742ad4ea4dc9962c6fa46b198ecff6843ba0614616cf7b56814c5645f47e11692d8641c0b5df7b16bd8c88910793699f77f4bdb7d40e9b0c3e84ec3e887fcc563b608c82be16036a23dd3eea2e5c35a9f84357f0e2f08d67c1316426e2b6b08aef31ae0f3954d0755d3569d76de17952d971217af5a3856dd7f2f7383a11b68997bf00cde5d9b3156b185117139db5093bc7d273648ec2dcb79b22c840fa2c9a81ae6209079d1f3201dcdda2b159323a73890eb079b711b8be47c8d07514641d3527597969a9146cd200ebe3190dfed6104e516848eb8e9fac3117a1bb47f2b84279a2d3bff26346faf63236508d319f696ffb5d88f279ac30c0b4bbd891cfc10219ee528bfdefd55d5c8be7c51c97a642b51ae2c44d247a776be7dd2faac32ba0c97e1994c475fc18a8545c49760bc80501753ef388ed9f331a299fc510f5f97279291023caa19c4cfe940bd5ff1a04db1f1a2493dd61c6d3024729d47feb5cb67e0632235e88c9d4b5521e983655f1ae2237cbcce0f1b53f280a840e7a905eda9f92e3bfdeb083d94085b468623fb5108fa4ac9f47b485d30521dcd37adce19089c903286c298d0ed09de172c5517c73f8c82152e110f3318b168e67a56a060895997160fa8964483326c29abdd71cdfdec9c212c5b33989322cab8b522eacc8d0505750d4a615b575cf67ddd7edf937e27a3145c38aefe0fb5ca2021bef73002534ededfeb4a6218e975f39dfa352e27f2e7f15f34010f897612cf437322956f4d123c2bb8e439586798c238f55da47cb20fa170ae524d628354c191f63f183cad2deefccbd1527ec36aa54df8075ab34ad51d8070b98168c259c964d2c1b24654841fb9b01f2992f5604bd387ee2ce2e2ccdfffa5e98e114fe1163d3829da4d917e08461ba6683d3016edc3005f27c03020c68db13d18636855b2700de4b46eba908b859df11cc3b63217c04dc1ae7b188eefb2de6086f635b7723f2b25386966034f2a8cc56b5f3bea039cf05af551ac5e3513fd677a45d7e54cfb0816e8a53eea4bf462e9daf35b758ee19d3a8414a639658d71895a3342d812dc1e8ed5e6748517b59004b615eba82e0254542cad754de6613327eb83e20580445350c52f3c8deac262892dbad9524cacb338d58cc8046dadde2df55f032f95f84972623af1fe444b4fc8f16b51c35a38a6e4f2a67a92d1ad1ba60f16b7a79fdab64cb6c917c69e4eecabc57bfb25c2d3cb34f2ca28fc71f690841aae5e6c3259dc31671bb9e0c1145f1d37533a09d89c6d14b66bb0272cb8fb851d845d4d6b989389db6eab580ecbba693d5b4038ae1e16077642a3448603cc3b87592c6bf67d21de7d6b036230bd014386b3c7a9fca7534c3809c4d8190f6089c883d7a1a078645a3525ef54eb582890b4f396011d8b43d4e91f49ac66dc1c15ada1c16a3bb5647288c39d22cc16412f69d788a55ba7f6a990cc342ecd85009fb3294202a227e5e8a2ba4d4a7a9e7687a772e9ca04999a020fe5a6e0a50d75006a4a0632c8c0403f6922232ec52e36ffbf8a224110f46291f677bb104c1b4f05a4abe39442f9671a26802cafd0f7abad260cbb8682b6bfe81bc2c78c17f5e39d996f0faa75d7579b0aa1655bf7bb3f36664abce2ba54d368ec4204858471f76ba3ea977982a85e6e1372045033d6050b668e4e7c3b34d6b400e67db4c6f3121a5809e1b4c976f348ab9d2d7f5aaf95ce6d57439c2ebebf8e96a65b7155fa3ad6f10438f653d5df9ee7271582a1f1067351742c1a1f38b42d73d9de58c50f871a73e873dd39ba7272eb8a575b08dbacff979ef101a6378e11098f12ba67caf3b1206b26f0c2290acf76db7e771646f222be2eb192a69add83bda9f6051d9066fb73872af648941a71be7c8956f7d2e78c8a8c591602d2f3352999a725421e30905859323cedfb420f9db0395c4aeefc290285102466526b5f1ad3d96c6e541692e6fb73c205688f1efe33f57f03b0cdb230b146224af7d5ac817227b7b11fe0012d320c9542ea2d31e0f7a75f02223168b38f418209db24b7b6e644d475365ab13659665fadd423cfd146cd53e736f43a3610b7d208f688bd12a1734d9c372c55a1bbd11fa05b81e68709032752710ab76e565144e29925b141673253dbe56c91ebbf7c0b9a2e14aaa616e0151c59d66450f579742c442be1b7c5fe437365c343b91315f56f925e781cf27a5f182dfca90e20b6405875e85ac4a9ac166fb76de914ccfc44c3197156b551549021a8debdb3e609ca21e6cd3590e6c0bdf635411943fceb0c24b73515f5b7539186d0168e51135b7d6d830387257b6dc5e664531649d8c06b98a065aee4574f37695346a3ff3a8e5c6c67c8d6cf80a1b1a9f9cb18ebde1b93e7c614695069f9e978233f7977678428e45059b4787a8d21f917ab778bae4da6beb175c4171bab8eaa9b27c7215a704859156850e9154f1d8b1e573337949abf3cf539f25aae0d4fe313d600b0f06364d61c615380ed7f102f1d25e41fdcd03c39cb907147c7ce809766de4960e9794af7d5dec736781606b427dc28b8139864c0fa849be3234e74c506baa9b0ffe9a83ac70b70822e0b9259fc07118b2b1357da711fec7184349f28dbe5af4b710fc11850c6bba51ae0877f2613f2db58e1f4fe41462bec219ff38399fa7719859c225680da8f8d8b7eb0f8271d0850272977a019f1479355347d91eef444600307177f6dc0f3a3b62524e3f728a648f598f7cbf74f7e1214b4a6d1026232733e3f4a5b033c62a74ef8ee84704002c75136ae78625f32f2e6ed51e8695a4f17c56abc9ccccf16c430698a3e08b53010cf067d0b88b3ebe870f6dee7a29718c2ea7996375208acf9fee23bd6499c29a4f4da7f013f7bf99090c2d0539542870de7bc4a81a5dadd952af9ed166f8b56bfab952d34fb18b3e314d77e66d6688f467da817b192d23a2efc3410b78623547838a9acfef85a6dc7295c5050e7fb86579c5c4bf50344ebd6e82daedaa2ea5ac9404e6c4ade0e13a3a7b046cf7ba2e08d8a7e6900374d2df9d847077e564aea7ff7a105ae819f4a26490564513813adce6041a87e76b05182deae634559217adbaf6dd3f9f76ec0091637ccbb5c8b9de432c7f85174b69d8c85c2af9dfc5c8985280c1691d45cacebc99c31302c0d96acaea419fd64784bdfc126d48d67945ea90c9e59c2f7d88f65836fb9b0db99f8a1d8e2c92cfce3b3591ca9cd0f01f473c0ef5b0705ecc0f8ae5e6f01bfc11a82bc25f93c7a83ec22cb8525eedc9c78139d15fd3c4e06359dfee9971dc00a785672fb7acaaae0f138fbf2ad741f61e7befbd2b1ca87f53a003a29eec1d4851d65ac97a35d67d30b0b1b25bdab0dda24d0553037eff24a34cfa91207ed568776c4b1bfffa111c23c55c88a5b65aa13ed950d60f8dba59a9426e3f733fa1ed6c6ae60b4eab37c67042f97002f8e1558482465cf695a2414979282e2781596a6a27e61e74b9211746839a85bff499f8393cc49f496d9bc13cca221118e597544d774c108248f4f8132d7ffb9b2e7d4498f61bc3b5ab387170d8b6b2dcf545bf394b11f2bf7fe1f62f8de6f0a303b5f1a9e3aeda769b0eced201a4e8015df2757b473298c8a02ecda69519b1b6a0165a6f40257834a86651a458f76835ac156c484068b9eeaab4100425320c029fe63118ef2d37940ac2672751dbceaaa6a3e80f0abe99e100920e331cb6661dceb90ae5e1125b047e9d65dcb4bea402238afeb1d2d5479c97fb854373b783be3002bb868dfbc28e02304c5ff001020315ed9022b0109aabb124fb2f82849f677c5932bffc189f9d018831fa37edc7987debb1b097da11fbd581476e4b659b59a6401c638b717250b02d7e2dff72678a4be0996985e1bf1091dd49aec3ae95b332502f48fc4be9f42a2cfbad39c30c909fc309ac7db7a9cdbe6830f8f7e338b60762992e294fa0ae5ae4729723a29cf8c08d8e2169e7660e093b0bee1ff91f6db0026fd52788d70c3675916650271ee0a75c39ef5df233dd64168525f3f7e4e1b39e9f48d83905be9536544f7a18646dbe5fea29354ddbb37c6c8a2b454844b95a7940db3a17b99f88cdb70d42dc55edd0f99356cd88b2a7d9a75a534dd658d4ca10d59171dcbb875c8f94b08f3a74c7a2e9cab662bc99e53393733ff666c3fb856103e99f39597c77b7fa44551117a815965a1f14b29d40cd5fd8f65433d239b8d9ec1728f8cb2a0861cac4fba83f31ce54442429a5f25692d33b30bf51d152d5b293a6c7e1c82c5ba5ab7072cc07e145e093de222e69e03e5c6047c26cb31701fed9f85ba1180bb16539fbac5fbd37e3210ade57ec87d45229cd355ba2b44b4d6df956fff31896aa7799eafc2f3909ec3a8395b1f762468f3f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.1与课后课程笔记</title>
      <link href="/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.1%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.1%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="27f04d865c3ffdf0e42b34c2703f42edd644941bd9fb75bdde5af8eac1b79142">83bc12dacc7a0d781bd8e05336f2838bbfdc5b331fdf895a8f9b5f00f6cc7bd210670bb769e0f9395b7c7acdaaedef70fbb8c6c100860d383125dff47ef83860cf2c523fd7c455871616168b298c8ac65f77212872bf9dbcdae3604581b4a03c996832bb95079fe780a59c9409c7c73df7f922e9f0a47e7b65dd538290e903162b1828993d2f365f0e019c990e569ec8eee61e6671db166f11fb1ffbb9440f50c8bbde1d9faf215b882eeac7b6d55682ab7930309b388a329f7082095e01b59263ee178785c149f1780972e024fceb4b9ee34e0f51180083ee25e7cb94269f434644db62e63e4bcdbbff50784f457fb8b42abcbeb9e98452cdff323455ed6dfda29d1b4f6aff31b824ce037c77370cbf0ec46c53f5ede0f409d5015dc9238daf701e25b911812da52e36e46a6b09d7f020a0de477b6b0c782ae5e57702d293a7e7eb8ec92d38a592ac3d219b54388ad35d48cfe2b7103e3268de3a3e7bf09fc675b86fe6575b7f827a4854913d65d2fe77f5412923ad26c2d2984a3888a1de7e23a19478f11bf45ce422e47f97cca78cc5439847d69c4dd068b1f6c2b6106c07252175a053cce119151503d1cae72615e4aa5f6fcbce614adb2df936b9e8b87a4787a7bb567062655c01a6963d6e760691cf060cc6a4a85bf86b52afe0f2b403e3239b9e3e2b4c685e1408d72006f6995ef1a436e06560de22f722202f446855d311ac0a58df7591476183f34cb3bd44d1d5e6ba0c3e8bd460c2d02c31b4a3979225ed850d24a281a32a38fb0625f219b10a873cfb5556785faedc39f543c43af6580b9ee045331e61b765971f7ae01be5becae9ae7973a28993d7190aacd31c50af354006d0541f92f372aa7e3ed41d8ce990b598702585b5e8f6ebfba9ea94d53c0eb552eb99b3dc038c024f3671e3024f657d15189a5972825640c71030e7c2184327261af63693a1358ed1746499adacff82e391605780b435d03ba90ea9e58cc0bd63bb3e0ccf1f2399e79c58b29e211466c3daf1ba70027363c2945db2d32bd9cd39f3ca35485200d993db66234bf9e07ad0807bfc1226f01d753f4f196e9c89e75d514e569237302716afbdec581ded4cc516244ded98a875b850f132920901d2afa78e989760c9133d15e659d4b7bb254de5997772b318961c50f2db325398c9b2238c3b2f8f35857c59641819e852d306be206d6f259ba575d37783b8bdedd840737680bc0aa0b87699cf11a95bb9956cb9b9a23971854b59970be9c45b649a924bc3e2ff49b1c42ab78684d96addb552a14bcfa8dd79de3d8509ed6ec93caf5840cdefbabfad0c287cfe9ebae88ed6694fb28561dcfc93655c3247294a51b822f8adbaec3420f211c64d534016fcf38df12fe41fdece8f71faec86cfa25105c39191bac650023069e755cbffa3cb5e75e64881ae8cd6158bd80977ec9cee0eb0c1e357d4bb46dbd6716c1d9d528dd3f0bd2bbdc4849367009ce396fe7a590d34f0f067f682580e546846ca2ac63174ad269fa7f3a854c677118fd4944b9bff3ecff01726ad8e47adef393c9b748351fecb623239a6c942eef31bc612c2b005e8dd0d6503a68666c914f06388594c9ee92ec2e26bf90a5c14dcea4ed94ea3f8c1460ac4931e1453a124ed78d72871aae323c07d5f0b70e122fbd37ac9d88fa743e17f25f9342326dfd183f0d37c997d00c0ec5f67eaf5b9b31fe34a5b0a3a6c5a72ac3f2b47586827958176071136fbc41dd4a3d85fa2ff2b773f079a8c4391f84b268e4a7b446f2a63685966de51c9ffef4da6f7079389506b8f79070612b347ddc913c32198c7b17c8d30ef26c6f92b8c6415d1b202aadda7ee296f8fb572cea29d80a09696cc9c2b8af9f0d3299ff03df1ec31107e49a974d673032fb6631e7068cb8b34f43a2d4431ba884c85cd14ece4d80cd252f72a5f489d4563ae587aca048e61d8c1d9a4d0db06f79c2caa82bd962a9c901c67e7bcbd70a29e3eadf21d1fb074a8ce502e60098f65b4da580a53e27b5b050a9cdcd2320fdb78a8b4cb072d6c4afb2ecbb559845a7cb40842d5cac96515fa6095aba2c26f3089c90f1c3490f492af42362bc18cc2b160637629f57f6e7ea53841ea04663e678859c656860f27df24acd10c1b3819411de70f250a9d7a035435e2fb8f0e57acdc0d7b7551cc92ad0092e0bc71be314007b4fed8188e4d11650b4879fe4e719601bb037269517c6bf9ee877453ce80d2dcb3b0f4c52eb87acc57cb42df674e6a5cf60f912c105df4f65a68cb900a61536c0f6b92b96e977e882b9c8c6d8dae0e60bb5fe4bfb4858bdd21823ef1965833d9e9458d1c47bee6871fa900fea6dff29f2e359cdf365ea556dcb723c4c9dcafb1c7959138a840e95712ecc5abe4189f09fe82045f435794ca1f1429f20c5983acba1c45e26e6b0d0b8f562146a882aa2c357ccc81003d35a8eefe5904e469a23f38d5e11b0378eb4ebe5f99b7cd7b5b1d7124413799136b869f8f6d37c5405dda8fb24bc5073ef7725f32c10154bd12dba0b03f36e4725cda983b4fc3e91a78ca09932f4ff993a99dd1fbaebc8b0d147ac77f54bdd9f35a0be02ef4eb7e91a24c05e3485fa877497f260dd897096c9dd14ca5f942150e1435f50329ea26a81a97d3c96b83d2d9cc8f76483d7ffe12cb94089a26c11249a538ac6a2bc81aa8c609ead32f337b0f9504f7d6317647e5521bfb4cda048ab881618c04e6030f70d42615465edaaf8dd5612ed5fd9698facf1a278759c027c58e05a05baa7469541453adb1b4e456381276e20f012dbfd41df4867f4cba1e3becc725c595775083781872ed8576f57010ee7553047a6abcc247bea3ff40511de3a4aa157ced4c128b13fd94ff1cd9f009dd6266794aeeba94dea5fd082329503250fc86f261fae5f3ee16dd0295936c938187f851fb561425e1dd738c54b3cd52eefb03e624b4790129f50c27464bcbf04a25954975fc162ae36c41d4bc828d08704fb5744c7446f84818bea56a3f7cd4a05232f30e35f7a7e3782a0fb0c8e89817c2504407c894a167f6cb6bbec13f4339ddda3647811a4698c14e2df0d37b4e5bca8821f6267f60efc5b17553ef1715f45af0d1528374056f22d7e24c53c02604f33e8b0e5586991a2d9b7e3a6f161c0a63014444b91b3694829152acd86b425d0fb3bb6a9da271e0d7535d13958ad1b170f6caac1d4b6a8749576459f56faa64456ef75496b55cd9ba74aefdbfc43bb8914cc36370059b3e82796423f5d6d4ff3729b36d19523f541238873ea478b0f6661fef7cfe8fb4f43e85879d1d20a26d82c79e157c0f1da326a515bb017a845db063eeee66446e8a7a82c94081e1b5e92b24ba2236d5a8da44a82207fa7d11ab6dbb6291fceb3635ba3d08b5a853255e1bee08f9dcb850b74396981ab7389d93b1fd15776d7c1505d4d73bb3cd4997fb495c699cbafea67d836c52436e33ab0c54650529e50e943aadf6a2d8dcddccfab98c4139698871760d656a1b06c0770968acd50426cf403b64af1e4dae0ce0ced184d37acfd89e6543eaa771afeefd5a8612a4fac006ee843758da9cc22b9f6a7019ef513e20b1225c620a16f8360a3beeab2dabda5a5f529781022864993ba86ca6dcee54a5c7f9843afc5af89ef10596a92766f85fa5839b40d5d2404c4276bbdf4cde4c8896d27c33001769c71888dd6eebb69403ab628ec76096519cd0d41da67ecbaf11da40db462d1a7d0b1415fe70c9d4d176445d00fc8b93d71ff64499d971f0984a5d5f1f7db44f270830d8e771179ec67ba8ad398040045cf94710edf47bc07df82c33e451ff825744561325d3dd028ce62b392c1290d10d2e10b4708c58a1333bdf4c76e4ce7dfbe8998afeaa1bf4dfcef87e99814014a345b364341c149473c9bfc1a61ea7819d1a9e530b8ae26e0e6b9d154bbfd8a2ac62edf556ee96bba863930857d2b643ece1f822a43ff126db3f466e31a20bc53208cafe9d53b99c6e28708a2c1a9b98314a988e1be62a15a26be4719e62d5f15fdece834f3a6f759cf56d9fff4fb22c660b88614d75721cde97fcf2a0be47acef1f064691ab46e3fb81bbef1232f07e08e8d2d53ae56f1292a09f136365d10c48161db02cf7d5eb4018ab5d04b1bdefb3d97c3f5a271da0afd05bfbada55afcc66a8c1e747f55462de7f86ddfbedfbbf8b4024d80ab579a0c5c246ca21d3a1277f0c662d63610628175adede851587f6f437a1043d00c0711b3d2e5226edac67e27c8a5eda8104437a72233abd94d5da40dad42697a0b7bd38cf19b7cdbce19830f5e5ca0da96adc87773018326078a43adca2275154810ade634b6bbeb25b54bae8bb904fcd96587eded7c9ddb182a60f54f146a79a25c2d14d9a230899d943c6c854cf999291d2b598121a8bd0324582d7df5438d922862a0b6a89798749f4c2808d60e919343de0d47b3ea85c2cba68a68d58aad635b334e4f802ace51054d54e1a640eb5b9a8a19a46e20700c222801448e27da019e3cbeacafe7dc345388d2c9f23aecd5bdce9282410a75087c6c1f10eaf837f410c25033b0eb1df42aa28d8f3120086e09be1e9e659da6c167908ab9f06a4f95c00c20d0e84d61f3895c018522cd5b966b27e43ed6ba96edafbf07b22882d59adade9444fcb27e6a8493bc55119ec7fe86cf1da8c0a6bce8bd4031e1d19d31d9c64177df7006e760566d388c8ed037e2920e36dde5c32db3627874df1c42a71be3fc47296443294231d4a29baa5e17c46eaab637d69edef9c8e6928a9c327e8d89baf32efa5ddb87a8d1fafa273d5a3c4ce3b60212dead026d37bb738af0b6678451c5afbd1d5f6cbc074b380f95f3d08e5af0195459a5b22405fd9a96881b4eebb58b884d2e4cfc04ac4df539da68c0cbbaaedb4f165aac610c60abb76e7465bb95e10eee8b2c1ee7faf5a4e14e5796e8452e1eec067a28d1866369c0de09b57d444301c1f1135fe36aae6cf9d9872aa5179aa13235335e0e9c5bb210cb1432f0f2222f841a2861540d2d960cbbaec0de761a92675ef0d59261483019cf418a2c418de7b4d30b7ca0d57c28cf12532155d7329c69d669809bd138c2c365f7ea6529b62c4b24a4be2e2c293cdb49ed8dba28b14db5f7c6d6ce5da0a7aad3a229bb7d969cb25b245277629ee4c1961744e0ad1d9ac40a48281c847058b3c9da55de873b636356fc84b17c2890379dd99e67dd2e36ed6034fe9ace2ab1add01dc94cd12f1185ab9c30e14fcbb492c0f1af3e5bb75d597b5c26e937eeddc1b826c6ef9101574a62391f6889bbff7a811f9162a9e25610c9d5f246be81368d00ed5860da554c1943aa210989238509eea6e85ccf3cf75a0771974233f880c55d178c9eb24345693eb0888e1e1a042e60902130acb58d01a861776bb8da86f9960dfa6fe4946cffe25702dd797921690d960b0bb906b7f95881b0a519c79892b810dd210dc6f4b404fd77b04356a694980fe1ef93e32d3742213f284554addf35bf66f61df806ae8e015af0b3611b22458b06563101f7a003745d103e3928ed56427636d7927c4e4af7dc5b1faafc155b24deba3b05482564b48c44555f9991890b74c8a054572196a4274a5562654cb94451503a84bc4e63cfebb933b882fe96c1ed59d62db92903a4979839eb613bb4d98c6e9c8b3c3d1a2d419ebb62179ef6f76e53a5af309b4442fd11f1c2cca83a61ba80bd99217a4c47c584ba6316aac16e14284f905c4db762060a9982e1ada0fd2c542c1dbf083e5f02ed86a8630512916d60f72817e0a6848a802e4ff6c7497d6a121692c6c093b966e73e26c7dded694ce2c16f9fc4a629ef3cf54e79bd09a41e76aef5c051f588e78d81d403b7a6d436660e56898c8108e4a54f5801feadaef4bc959dfc24bf8a7b6f84cddbd2c6a7fe8b71aa6649c80b2e375e413fc20fbf41b094c74ae79bc603181a68e34ad72bc9aa3a6e6dbc10dc941682648377ab42c1b19f5548ab1e3ddcb19548dc3c448fdcfe4ebc78009207259b6f298ea54d20f1ce98d6915bf515513205b7ce4ac9a11738d03667764b5d4cfdb5a1ffe6ca632686f54a406816961f06f52bfe86916b0aa1170c25132d46f32bcdd2eee99e614951483def27133d161f773a9039bc65f6d279d2062d251ee7a0cdcb909f0ac424b82fbbf2ebfff0b640b8628f79407b9531ecd3a386d0d6353aa8aca1c94c3db92924f39d872014f343a2aa6772e4fcddabfdff7053aa4ecd98c666cfcf0f0055b738b0f6d8885e36c91184dec5cb641a52bfa6731e7f078e0ffcbaa8c5e7d279068006a6e4653aa7a2d68b802787786ff87b46d392a5fedb1826e1d11f0dc3153dd62b944737757006c781f49de2c07234325056a84720ba5e2fd9cfe336c03f4d4dff89e509347aca71405ca051a49279edba51f535259f4e144f4865f364679980f8ee674475e7abc7d2e8eea90ede85492f26a2f4a53a21aed6e96ab76f18e55e4476d22f8f09255ac4fe1eefc53cb6e1b0343c50eb3fd1b2cb924dbada6889acb4db21e36ae149359f1f8529a5c579f7b705cbef3aaca9f86383defad3654b3cd3fc3c95a9f22cab1d18469a16442bbce45259b018216b57cdd0c340a7319c8727fd90d2782ced632411a4f6aeb5fc1fce7be2df6b1b910f7a5ac2e476329702b4d643d4387e79206e763f52b003a2c6980aca81440ed7ced484c3949b4564e7776c1ef317e465aaafb69bc5c56eb21d3d195497a4923145399aebad272743a7a8fc44f54c705905cb117ba876c0c71ebacf785705ff1c6941684ad916f14709a40ed14c9abe732750766ebb1980636f2e2c6814f0f6a33c6ba4ea4b50b5e05cce7e6818ba51738b1164aa836c522ca14cd4432f0e5a4be20c9b9bcef9f639847d341f240f2cbbf86de76b0c0213c4a617a64e4bda9e9bcaf0965c0cc07de6f823eb9479b4aff4971af440057472bdc1315db80d53f133a84528642e9ae9c977df99973eabafba2195488777386bbdb7d4bd6152d62e7b09b6fdeeceef586d1eccb64bc0dd3290e3c0a30268ef9cdde96937c2507192a95921767a89a7686f209ab11297e627d8c84a63cb785ec68ab12c249b7917afd64614628659412836d9461806c98b90a6f9e00eaf20a8cf51f63b6efeeccc813cf70a5e1eba76829fc51f21856bf470c7246e9f093cf9bea9064a77b5a20edbd172414bc1e7cf36f172d218aa705128a327b89280df401e5c8c93a32654920c61dbec21311f7baf85367392fef3035b4e41afc25d5a299cd5aca401b754b1985c92d8ec7fd6b4df4d4db432f3b5c0f40e94a1a2ef67f2a40cc7378abf3852d7d2bf822ad36272477965a9e8957dda7e16fbbbc5e341df08460dc6266df5d81f64f8e01834534f1718fe279e06278cc1674444dec5b6bd715a3560d92bbf06eb6a4f0055a6ca9768aa556ed20397e0e7bc644be49f6c3d322389c001f1ccffc38fce8e3ce4988a852f3a9ea6578ac1aba25bc6e3763a2a9c2f1141399cdafa24fee9c11350c7004b69745808a7f823adc5ed1f003dc611baad08aa4c7eb1199dda92d004715ddb04f1870e84012b56b7dca15a73d6178a3b667feb64bad3481621ce836fb19a2b244790dab213bffbdc2ffd6c062d34239e3844a26d66b59402652e5ba1474569c17bc362dd0752749a73bf7ba53be8e4c87670a90c032486bc5b03e0d41b2303c50f70fe29bee2188b2e9a717da013dc33aa13131a5ad907c28d6a2007c2e447f3299983938cb8051b1d9a7c000416a30d0a1578ac122e6e363f00d53cda75e95149539d31b1c93bb8b1f9717f2a4065fede7e831aa9b12ac280b2245c98d291851f84cba6d192eaa40a737063b750841b0c1d619c2ab8cf1fd4dbc69a0af738119e8e218e3b2190dd92aed2faf1c1b56469f0e7622ae969d8e3ba45b8533095b96deec52b0642e71f700bfb03b9e508cae68d525de3a389e28a64b570a22e8e418e3586accc7b40bead5d7d5576d0e452d4c20d351c7ffbb2f388d5e2ab645d383bef7080c4b917affa828485fda5fabfb75bb5a65156f901205d9bd1ec46cc4d2e3aed62c1b879a38a013fb4bafa4189c5e5fb58633fe2e1f1d14047fbc64f7f885c6f7333c1252aba2dd8a8c857c3a44066fbb540cc035bd1b1cd26a37ab00ad8328de087c9ae0df6bc1551f87d5e4cd39ccfd7f311e952804eacbb79ca8ac3e876767c7b8d46f87f1d48f3afa1eeb6aa01a70a76916a26f1367e5aec1dcf96648e209c9de4211e4baa80d99f9a689703c43bd7191be40cb421260df4527a156a7521e02f6a354a1fd0c518f6f35c14f5b26e779f25feaeff6b6171e9ecb988bb69273e1163cf75162f1c55aade048b95854e6bb046f14360970fe385dae5f61d3d9319a44941a6e23702ffbd4c52377eef3a630b612673adbf9988be5e1ef1c6994e3ef98af2fb28f63b5856805e588ddd2de109c22ef454e078a6a86fd19a4abcd06245670e5f2243220965f8e70c5075390b3a4aff36dae0ed1ed12f006aa20d9c893aed7b38419dec8f45c6ba0a5ce2ccf983543498a564f3928ebc38610b4edb83b3d567163b7738e06a0c54f34f530139ef9b082a159c6311879fbf68be819b8e96a0dd78d7332c0618166512704a43f4fcf59c990d807e99ecceb8e41bc8165681349fc500b0ea9f0727ddff9d2ed610de138d85c72b40603ee847e6f6524dff4c78f587835cffb6494faca3dd89984fbc9ad125feaec2e0d1c0eb8d36a3d88ecfb19804b3a45b3261356e4b62a784466c8d29b444f21ff72ab4523a21d867e87bfbc1a948a195663fa55d8f0cd2f53d7d2594c36dd39a268048f2db1c6f2d506a10b538dc33dbc1329f435a09896d5cdc905da8805ea699a15480d662d38125475d6303a658c3f9e24446ae1027b9635c3033ce4b087af787b2d76ddb20405cb19ee11813a8eef8d91ebe84bfa30c68c62d9a9a77d22beff368246662c8a4e7550a19cad6e6cb55dcfe35ddb4e9741ee1a6cd2806e3c222a0544dc9d0363e0f3a1a9b09543509550f3f81ec93160239f50a0e682c43f62c116f62991212ee5563cec55e4d14d54adc377fb46af7073bb342f364836e3f61b047fb527f821204725b72df779520b5a25f7580e322e71f26fc80702ea76c260a0ef1faccb42591fe02865511eed4d108a6266e47fdaae09c9927579dd2d8217c80aab3ab5706e80d0d8188b13ab08db164fbb8bfc4d916bec7e9ac2869c419e0cd43634af984678234ed248f6dd56cf08400e9d95d175eba6afc4d94b800e04262e2312842b0c4c05ad5dba74083f37092ee8941142bf00ad3372a6bbc50628783b7a57674136ca18d446ca2df0047e98a5381569156d9b437fc8c52dca863a3571ca6e969bd63c4a6cb16aafe5b6b221db762d6fab53f0edb5707953324c7cbd00458243d875e96fb10802064c68d06eb58ffb85fe47029f67f24997f8ef27020eb0b2b0c3cec5f00c420440affa0f20cf74636e81482f966b848fe91c37829aa9e5524b770c5c8fda7996e5550f729895b5f982d30af1678aac2d8ce92543a32ff704c4daa4bc9a5846c70649c3826e3cc37a5469df04ae3caf5332c2a5281c0b9e9bbff4d1e603d6d3c2908bcc2e85b9f870cfc43cf5e4d104cec82ee2cecdb1ac9800d4e77f1d222a100a13806b1b5d623885c0dd3af1e5e0585d002441dbc7746f7d65ca147e1e23478b9d4f5601d7e7c676e561885d9f3f142c5a6d68b598bcf3b7571de4ece8c780939826fcc6f4fbb8e240f2ae590a6512204393cf2b3f4287f9f3282067b9560ce931583ecd1f1f5cdf2a5fc2f98447104ba61fbafc0615f8d35d09adc789bdcadd5814ff3342a63de69a5bd91565295ab718dc5bc9e76df84a87c226130bea8d8e3527a29d2f9f45f6ad05cc566f170a00ba03844510ebde05b9ee59a6f2bb201be0faae5f877610724f0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周总结</title>
      <link href="/2022/04/29/%E7%AC%AC%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/29/%E7%AC%AC%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>装了2天，总算把博客建立的大差不差，现在只有一些基本的功能，这周感觉有点摆烂，晚上一定要坚持跑步，然后尽量多利用时光序做好规划，周三晚上算是摆烂，好好利用博客总结发现和分析问题吧，暂时先这样吧。有什么内容晚上再说吧,今天晚上写一下模板,分析下每周的问题。<br>还有就是ACM本周基本没有学习，五一要好好学一下，坚持，努力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#inude <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><p>$RMSE = 1 - \dfrac{\sum_{i=1}^n (y_i - \hat{y}_i)^2} {\sum_{i=1}^n (y_i - \bar{y})^2}$</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
