<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分块之基本思想</title>
      <link href="/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/"/>
      <url>/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1>分块思想</h1><p>分块的思想其实就是一个朴素的暴力做法。<br>我们把一个区间分成$\sqrt{n}$段，对于查询的区间，我们可以将其分成最多两个不完整段（长度$\leq \sqrt{n}$）和不超过$\sqrt{n}$个完整段。因此我们可以把$O(N)$复杂度变为$O(logn)$</p><h2 id="例题1"><a href="https://www.acwing.com/activity/content/problem/content/2760/">例题1</a></h2><p>维护两个变量</p><ul><li>add使本段中所有值都要加上add（lazy）</li><li>sum本段的真实值使多少（算上add）</li></ul><ol><li>修改 $O(\sqrt(n))$</li></ol><ul><li>完整段，我们要对于这个段的所有数，$add=add+d,sum=sum+d*length$</li><li>段内，暴力，枚举所有数$w_i=w_i+d, sum=sum+d$</li></ul><ol start="2"><li>查询操作 $O(\sqrt(n))$</li></ol><ul><li>完整段，累加sum</li><li>段内，暴力每组求和</li></ul><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">350</span>;<br><br><span class="hljs-type">int</span> n, m, len;<br><span class="hljs-type">int</span> w[N], pos[N];<br>LL add[M], sum[M];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pos[l] == pos[r])<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++ ) w[i] += d, sum[pos[i]] += d;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> i = l, j = r;<br>        <span class="hljs-keyword">while</span> (pos[i] == pos[l]) w[i] += d, sum[pos[i]] += d, i ++ ; <br>        <span class="hljs-keyword">while</span> (pos[j] == pos[r]) w[j] += d, sum[pos[j]] += d, j -- ;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = pos[i]; k &lt;= pos[j]; k ++ ) sum[k] += d * len, add[k] += d;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (pos[l] == pos[r])<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++ ) res += w[i] + add[pos[i]];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> i = l, j = r;<br>        <span class="hljs-keyword">while</span> (pos[i] == pos[l]) res += w[i] + add[pos[i]], i ++ ;<br>        <span class="hljs-keyword">while</span> (pos[j] == pos[r]) res += w[j] + add[pos[j]], j -- ;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = pos[i]; k &lt;= pos[j]; k ++ ) res += sum[k];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    len = <span class="hljs-built_in">sqrt</span>(n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br>        pos[i] = i / len;<br>        sum[pos[i]] += w[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);<br>        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;C&#x27;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> d;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;d);<br>            <span class="hljs-built_in">change</span>(l, r, d);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">query</span>(l, r));<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块之块状链表</title>
      <link href="/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/05/05/%E5%88%86%E5%9D%97%E4%B9%8B%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次队内赛题解</title>
      <link href="/2022/05/01/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%98%9F%E5%86%85%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/05/01/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%98%9F%E5%86%85%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splay</title>
      <link href="/2022/05/01/Splay/"/>
      <url>/2022/05/01/Splay/</url>
      
        <content type="html"><![CDATA[<h1>Splay</h1><p>平衡树里面有Splay，红黑树，treap，AVL，B树以及B+树</p><ul><li>treap好写，但比较局限</li><li>红黑树系统里面会用但代码太长</li><li>Splay代码适中，较为灵活，可以处理很多有关线段的问题</li></ul><p>首先Splay是一个平衡二叉树，但没有那么平衡<br>先讲解下左旋和右旋，旋转的目的是在保证树的中序遍历不变的情况下，降低树的高度<br><strong>平衡二叉树</strong><br>定义：二叉查找树（Binary Search Tree）它或者是一棵空树；或者是具有下列性质的二叉树：</p><ol><li>树中每个结点被赋予了一个权值；（下面假设不同结点的权值互不相同。）</li><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉查找树；</li></ol><p><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_9d84988cc8-4.png" alt="4.png"></p><p>二叉查找树能够支持多种动态集合操作，只要所维护的数据集合存在偏序关系（简单来说就是定义了小于等于）</p><p>Splay保证树的高度的做法是什么呢？</p><p>它会在平衡树的操作上进行修改，核心在于每操作一个节点，均将该节点旋转到树根，可以证明每次操作的平均复杂度为$O(logn)$</p><ul><li>插入 将插入的节点旋转到树根</li><li>查询 将查询的节点旋转到树根</li></ul><p>接下来我们来看一下怎么把一个点旋转到树根。<br>我们定义函数Splay(x, k)将点x旋转至点k下面，Splay(x,0)代表把x旋转到根</p><p><strong>左旋右旋</strong><br>节点 x 的父节点 y 是根节点。这时，如果 x 是 y 的左孩子，我们进行一次 Zig（右旋）操作；如果 x 是 y 的右孩子，则我们进行一次 Zag（左旋）操作。经过旋转，x 成为二叉查找树 S 的根节点，调整结束。如图所示：<br><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_e554a3a9c8-1.png" alt="1.png"><br><strong>情况1</strong><br>节点x 的父节点y 不是根节点，y 的父节点为z，且x 与y 同时是各自父节点的左孩子或者同时是各自父节点的右孩子。这时，我们进行一次Zig-Zig操作或者Zag-Zag操作。也就是xyz为一条直线，先转y再转x，如图所示<br><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_2c32fdf7c8-5.png" alt="5.png"><br><strong>情况2</strong><br>节点x的父节点y不是根节点，y的父节点为z，x与y中一个是其父节点的左孩子而另一个是其父节点的右孩子。这时，我们进行一次Zig-Zag操作或者Zag-Zig 操作。如果是折现的话就先转x再转x，如图所示<br><img src="https://cdn.acwing.com/media/article/image/2022/05/01/99310_412fd6f0c8-6.png" alt="6.png"></p><p>考虑插入的情况</p><ul><li>将x根据数值插入Splay首先在Splay遵循二叉搜索树的特点找到x的位置，然后将旋转到根节点</li><li>将一个序列插到y的后面，先找y的后继z<br>第一步将y转到根 Splay(y, 0)<br>第二步将z转到y的下面 Splay(z, y),分析可知z是y的右子树，而y的后继是z所以z的左子树一定为空，<br>第三步将这个序列直接放到z的左子树上就可以了</li><li>我们删除序列[L, R]<br>我们先找到L的前驱L-1，和R的后继R+1<br>第一步先将L-1这个点转到根节点 Splay(L - 1, 0)<br>第二步将R+1这个点转到根节点的下面 Splay(R + 1, L - 1),此时R+1这个点的左子树就是序列[L, R],直接把左子树置为空子树就可以了。</li></ul><p>下面讨论下Splay如何维护信息(以区间翻转为例)</p><ul><li>找第k个数 size</li><li>懒标记<br><strong>两个操作</strong><br>pushup()维护信息 旋转最后<br>root-&gt;size=root-&gt;left-&gt;size+root-&gt;right-&gt;size+1<br>pushdown()下传懒标记 递归前<br>swap(root-&gt;left, root-&gt;right)<br>标记下传，清空</li></ul><h3 id="例题一-Splay"><a href="https://www.acwing.com/problem/content/2439/">例题一:Splay</a></h3><h2 id="代码">代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.3与课后作业</title>
      <link href="/2022/04/30/%E9%A1%B9%E7%9B%AE1-3%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E9%A1%B9%E7%9B%AE1-3%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1>项目</h1><h2 id="问题描述">问题描述</h2><p>给定一个图，设计一个程序，找出一条从某一顶点A到另一顶点B边数最少的一条路径</p><p>输入：第一行输入两个数n、m，n表示图中有n个点，m表示接下来的m行每行输入两个数x、y，表示x,y间有一条无向边。最后输入a、b，表示询问一条从某一顶点a到另一顶点b边数最少的一条路径</p><p>输出：若a到b无路径，则输出“There is no path”，否则输出a到b路径上各顶点（各顶点之间用空格分隔）</p><h2 id="解题思路-2">解题思路</h2><ol><li><p>建立邻接矩阵：这个无向图用一个n*n大小的二维矩阵graph[][]来存储</p></li><li><p>寻路：采用广搜（bfs）的方法，从a开始依次访问与a邻接的点v1、v2、……、vk，若没有到达b，则继续访问与v1的邻接的点v11、v12、……、v1k，……。如此下去，直到访问到b。用这样的方法，最先到达b的路径一定是边数最少的路径</p></li><li><p>记录：采用队列来记录被访问过的点。每次访问与队列头部邻接的点，然后删去队列头部的点。如果队列为空队列，则说明a到b无路径</p></li></ol><h2 id="设计思想">设计思想</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_94dfdf64c8-1.png" alt="1.png"></p><h2 id="测试结果">测试结果</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_9ae2231cc8-3.png" alt="3.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_9f9d4debc8-4.png" alt="4.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_a200c7a8c8-5.png" alt="5.png"></p><h2 id="代码-5">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <br>&#123; <br>    <span class="hljs-type">int</span> q[max];<br>    <span class="hljs-type">int</span> f,r;<br>&#125;q;<br>q Q;<br><br><span class="hljs-type">int</span> graph[max][max],z[max],path[max];;<br><span class="hljs-type">int</span> n,m,x,y,a,b; <br><span class="hljs-type">bool</span> judge;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enq</span><span class="hljs-params">(q *Q,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123; <br>    Q-&gt;q[Q-&gt;r]=x;<br>    <span class="hljs-keyword">if</span>(Q-&gt;r == max<span class="hljs-number">-1</span>) Q-&gt;r=<span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">else</span> Q-&gt;r++;<br>    <span class="hljs-keyword">if</span>(Q-&gt;r == Q-&gt;f) cout&lt;&lt;<span class="hljs-string">&quot;Error!&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">(q *Q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q-&gt;r == Q-&gt;f) cout&lt;&lt;<span class="hljs-string">&quot;Error!&quot;</span>&lt;&lt;endl; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Q-&gt;q[Q-&gt;f];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deq</span><span class="hljs-params">(q *Q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q-&gt;r == Q-&gt;f) cout&lt;&lt;<span class="hljs-string">&quot;Error!&quot;</span>&lt;&lt;endl; <br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(Q-&gt;f == max<span class="hljs-number">-1</span>) Q-&gt;f=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> Q-&gt;f++;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(q Q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.f == Q.r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Build</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   cin&gt;&gt;n&gt;&gt;m;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>   &#123;<br>       <span class="hljs-type">int</span> x,y;<br>       cin&gt;&gt;x&gt;&gt;y;<br>       graph[x][y]=<span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Q.f=<span class="hljs-number">0</span>;<br>    Q.r=<span class="hljs-number">0</span>;<br>    path[<span class="hljs-number">0</span>]=a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindPath</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a == b) graph[a][a]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">enq</span>(&amp;Q,a);<br>        graph[a][a]=<span class="hljs-number">-1</span>;<br>        judge=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">compare</span>(Q) &amp;&amp; !judge)<br>        &#123;<br>            a=<span class="hljs-built_in">front</span>(&amp;Q);<br>            <span class="hljs-built_in">deq</span>(&amp;Q);<br>            <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j&lt;=n &amp;&amp; !judge)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(graph[a][j]==<span class="hljs-number">1</span> &amp; graph[j][j]!=<span class="hljs-number">-1</span>)<br>                &#123;<br>                    <span class="hljs-built_in">enq</span>(&amp;Q,j);<br>                    graph[j][j]=<span class="hljs-number">1</span>;<br>                    z[j]=a; <br>                    <span class="hljs-keyword">if</span>(j == b &amp;&amp; graph[a][j] == <span class="hljs-number">1</span>) judge=<span class="hljs-literal">true</span>; <br>                &#125;<br>                <span class="hljs-keyword">if</span>(!judge) j++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPath</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> i=b;<br>    <span class="hljs-keyword">while</span>(i!=a)<br>    &#123;<br>        path[k]=i;<br>        k++;<br>        i=z[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++) cout&lt;&lt;path[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Build</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;请输入起点和终点&quot;</span>;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-built_in">Init</span>();<br>    <span class="hljs-built_in">FindPath</span>(a,b);<br>    <span class="hljs-keyword">if</span>(judge) <span class="hljs-built_in">PrintPath</span>(a,b);<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;There is no path&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>作业</h1><ol><li><p>对于一个具有n个顶点的无向图，若采用邻接矩阵表示，则该矩阵的大小是(D)</p><p>A. n         B. $(n-1)^2$   C.n-1  D. $n^2$</p></li><li><p>带权有向图G用邻接表矩阵A存储，则顶点i的入度等于A（D）</p><p>A．第i行非∞的元素之和       B. 第i列非∞的元素之和</p><p>C．第i行非∞且非0的元素个数  D. 第i列非∞且非0的元素个数</p></li><li><p>算法设计题<br>假设一个有向图G采用邻接矩阵存储，分别设计实现以下要求的算法：</p><p>求出图G中每个顶点的入度</p><p>求出图G中每个顶点的出度</p><p>求出图G中出度最大的一个顶点，并输出该顶点编号。</p><p>计算图G中出度为0的顶点数</p><p>判断图G中是否存在边&lt;I,j&gt;</p><p>输入：</p><p>第一行输入两个数num，n。num表示图G有num个点，n表示下面要输入n行信息。输入保证$i,j \leq num$。</p><p>接下来的n行，每行输入两个数字i,j，表示图G有一条由点i指向点j的有向边。</p><p>接着输入一个数m，m表示要询问m次图G中是否存在边&lt;i,j&gt;。</p><p>再接下来的m行，每行输入两个数字i,j，表示询问图G中是否存在边&lt;i,j&gt;。</p><p>输入保证$i,j \leq num$。</p><p>输出：</p><p>输出图G中每个顶点的入度；</p><p>输出图G中每个顶点的出度；</p><p>输出图G中出度最大的顶点的编号；</p><p>输出图G中出度为0的顶点数；</p><p>后面对于每次询问，若存在该边，则输出YES；否则输出NO。</p></li></ol><h2 id="代码-6">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> n, m, q;<br><span class="hljs-type">int</span> g[N][N], in[N], out[N], id, cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        in[b] ++ , out[a] ++ ;<br>        <span class="hljs-keyword">if</span> (max &lt; out[a])<br>        &#123;<br>            max = out[a];<br>            id = a;<br>        &#125;<br>        g[a][b] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d个节点的入度为%d 出度为%d\n&quot;</span>, i, in[i], out[i]);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出度最大的点的编号为%d\n&quot;</span>, id);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (!out[i])<br>            cnt ++ ;<br>            <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出度为0的点有%d个\n&quot;</span>, cnt);<br>            <br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">while</span> (q -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span> (g[a][b]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果-2">结果</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_e6b90461c8-1.png" alt="1.png"></p><ol start="4"><li>设计算法，打印连通图G中每个顶点一次且仅一次，并要求打印次序满足以下条件：距离顶点v0近的顶点先于距离远的顶点（以边数为单位）。<br>输入：</li></ol><p>第一行输入两个数n，m，n表示无向图的点的数量，m表示输入m条边的信息。</p><p>接下来的m行，每行输入i和j，表示点i和点j之间有一条无向边。</p><p>输出：</p><p>输出为一行，按距离顶点近的顶点先于距离远的顶点的次序打印连通图G中每个顶点一次且仅一次，点与点之间用空格分隔。</p><h2 id="解题思路-3">解题思路</h2><p>假设图G是无向图，建立好无向图后bfs（相当于二叉树的层序遍历，就是一一个点为中心，遍历他周围的节点）就能按距离顶点近的顶点先于距离远的顶点的次序打印连通图G中每个顶点一次且仅一次。</p><h2 id="算法实现">算法实现</h2><p>用q[ ]数组来存储bfs过程中的经过的点的顺序，用visit[ ]数组来记录是否访问过点，visit[ i ]=1表示访问过，否则没有。用head，tail配合q[ ]数组来模拟一个队列。从head处开始循环，将未经过的点进队。最后遍历输出q[ ]数组。<br>代码如下：</p><h2 id="代码-7">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N], q[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        g[a][b] = <span class="hljs-number">1</span>, g[b][a] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-type">int</span> t = q[hh ++ ];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">if</span> (!st[i] &amp;&amp; g[t][i])<br>            &#123;<br>                q[ ++ tt] = i;<br>                st[i] = <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  i &lt; n; i ++ )<br>        cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果展示-2">结果展示</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_d1d8d504c8-2.png" alt="2.png"><br><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_d4b79116c8-3.png" alt="3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.2与课后作业</title>
      <link href="/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.2%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.2%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1>项目1.2</h1><h2 id="题目描述-2">题目描述</h2><p>已知一个按先序序列输入的字符序列，如abc,de,g,f,(其中逗号表示空节点)。请建立二叉树并按中序和后序方式遍历二叉树，最后求出叶子节点个数和二叉树深度。<br>输入<br> 输入一个长度小于50个字符的字符串。<br>输出<br>输出共有4行：<br>第1行输出中序遍历序列；</p><p>第2行输出后序遍历序列；</p><p>第3行输出叶子节点个数；</p><p>第4行输出二叉树深度。</p><p>示例输入</p><p>abc,de,g,f,</p><p>示例输出</p><p>cbegdfa</p><p>cgefdba</p><p>3</p><p>5</p><h2 id="题意分析">题意分析</h2><p>本实验共需要完成五项任务：</p><ol><li>根据输入先序建立二叉树；</li><li>按中序方式遍历二叉树并输出序列；</li><li>按后序方式遍历二叉树并输出序列；</li><li>求出二叉树的叶子结点个数；</li><li>求出二叉树的深度。</li></ol><h2 id="实验思路">实验思路</h2><ol><li><p>定义二叉树结点数据结构</p><p>建立一个Node结构体，其中包含一个char类型的data用于存储字母，一个Node类型的<em>Lchild指针指向左子树和一个Node类型的</em>Rchild指针指向右子树。再建立一个指向Node这种结构的*p指针。</p></li><li><p>如何先序建立二叉树？</p><p>建立一个build(p &amp;T)函数用于先序建立二叉树，T为返回node的指针。函数中定义一个char类型的c用于读入输入，若c为“，”，则为空结点，T=NULL；若T为换行符“\n”，则输入结束并返回；否则c就是字母结点，则创建一个新的指针T，并让T-&gt;data=c，接着递归创建其左子树和右子树。</p></li><li><p>如何按中序、后序方式遍历二叉树并输出序列？</p><p>要按中序方式遍历二叉树，先访问左子树，再访问根节点，最后访问右子树；要按后序方式遍历二叉树，先访问左子树，再访问右子树，最后访问根节点；在访问根节点时打印该结点的data即可完成输出。</p></li><li><p>如何求出二叉树的叶子结点个数？</p><p>叶子结点就是左右子树都是空子树的结点，据此完成判断。如果二叉树为空，则叶子结点数为0；如果二叉树只有一个结点，则叶子结点数为1；否则，二叉树的叶子结点数为左右子树叶子结点数之和，据此完成递归。</p></li><li><p>如何求出二叉树的深度？</p><p>如果二叉树为空，则深度为0；如果二叉树只有一个结点，则深度为1；否则，二叉树的深度为左右子树深度的最大值+1。</p></li></ol><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">jied</span><br>&#123;<br>    <span class="hljs-type">char</span> date;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">jied</span> *lchild,*rchild;<br>&#125; jied,*p;<br><span class="hljs-type">int</span> d = <span class="hljs-number">0</span>,ma = <span class="hljs-number">0</span>,num = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jianshu</span> <span class="hljs-params">(p &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;ch);<br>    <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;,&#x27;</span>)<br>        T = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        T = <span class="hljs-keyword">new</span> jied;<span class="hljs-comment">// 让指针实体化 new返回的是jied的指针</span><br>        T -&gt; date = ch;<br>        <span class="hljs-built_in">jianshu</span>(T -&gt; lchild);<br>        <span class="hljs-built_in">jianshu</span>(T -&gt; rchild);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zhongxu</span><span class="hljs-params">(p T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">zhongxu</span>(T -&gt; lchild);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T -&gt; date);<br>        <span class="hljs-built_in">zhongxu</span>(T -&gt; rchild);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">houxu</span><span class="hljs-params">(p T,<span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">houxu</span>(T -&gt; lchild,d+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">houxu</span>(T -&gt; rchild,d+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T -&gt; date);<br>        <span class="hljs-keyword">if</span>(ma&lt;d)<br>            ma = d;<span class="hljs-comment">//防止同一层多次相加</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">y</span><span class="hljs-params">(p T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(T -&gt; lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T -&gt; rchild == <span class="hljs-literal">NULL</span>)<br>            num++;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">y</span>(T -&gt; lchild);<br>            <span class="hljs-built_in">y</span>(T -&gt; rchild);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    p T;<br>    <span class="hljs-built_in">jianshu</span>(T);<br>    <span class="hljs-built_in">zhongxu</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">houxu</span>(T,ma);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">y</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ma + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果">结果</h2><h3 id="生成的二叉树">生成的二叉树</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_ec2de90ac8-2.png" alt="2.png"></p><h3 id="程序结果">程序结果</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_79c34ec1c8-1.jpg" alt="1.jpg"></p><h1>作业</h1><ol><li><p>一棵树的后序遍历和这棵树对应的二叉树的(B)相同。</p><p>A．先序遍历        B．中序遍历        C．后序遍历        D．层次遍历</p><p>解答：首先看这个树<br><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_986b4bcdc8-1.jpg" alt="1.jpg"></p><p>它的后序遍历为25641，将它转换为一个二叉树<br><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_9bd29a88c8-4.jpg" alt="4.jpg"></p><p>它的中序遍历为256341</p></li><li><p>一棵二叉树的先序序列和中序序列分别我：A B C D E F G H J K L M N和C B E D G F A J H K M L N，则二叉树的后序序列为（A）。</p><p>A. C E G F D B J M N L K H A     B. C E D G F B J H K M N L A</p><p>C. C G F E D B J M N L K H A     D. C E G D F B M N J L K H A</p></li><li><p>【程序说明】本程序完成将二叉树中左、右孩子交换的操作。</p><p>本程序采用非递归的方法，设立一个堆栈stack存放还没有转换过的结点，它的栈顶指针为tp。交换左、右子树的算法为：</p><p>（1）把根结点放入堆栈。</p><p>（2）当堆栈不空时，取出栈顶元素，交换它的左、右子树，并把它的左、右子树分别入栈。</p><p>（3）重复（2）直到堆栈为空时为止。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span>  <span class="hljs-keyword">struct</span>  <span class="hljs-title class_">node</span>  *tree;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<span class="hljs-type">int</span> data; tree lchild,rchild;&#125;<br><span class="hljs-built_in">exchange</span>(tree t)<br>&#123;  tree  r,p; tree  stack [<span class="hljs-number">500</span>]; <span class="hljs-type">int</span>  tp=<span class="hljs-number">0</span>;<br> stack[tp]=t;<br><span class="hljs-keyword">while</span> (tp&gt;=<span class="hljs-number">0</span>)<br>&#123;<br>    p=stack[tp -- ];<br>    <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)<br>    &#123;  r=p-&gt;lchild; p-&gt;lchild=p-&gt;rchild; p-&gt;rchild=r;<br>    stack[++tp]=p-&gt;lchild; stack[++tp]=p-&gt;rchild;<br>    &#125;<br>&#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>假设以双亲表示法作树的存储结构，写出双亲表示的类型说明，并编写求给定的树(结点数为n)的深度的算法。</p><p>以双亲表示法作树的存储结构，对每一个结点，找其双亲，直至根结点，即可得到它的层次。树的深度即所有结点的最大层次。</p><h3 id="代码-4">代码</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//类型说明</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span>&#123;<br>    DataType data;<br>    <span class="hljs-type">int</span> parent;<br>&#125;PTNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTree</span>&#123;<br>    PTNode nodes[Maxsize];<br>    <span class="hljs-type">int</span> k,n;<span class="hljs-comment">//k,n分别为根的位置和节点数</span><br>&#125;;<br>    <span class="hljs-comment">//函数编写</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Getlength</span><span class="hljs-params">(PTree t)</span></span>&#123;<br>        <span class="hljs-type">int</span> k,temp;<br>        <span class="hljs-type">int</span> maxdepth=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t.n;i++)&#123;<br>            temp=<span class="hljs-number">0</span>;<br>            k=i<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(k&gt;=<span class="hljs-number">0</span>)&#123;<br>                temp++;<br>                k=t.nodes[k].parent;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(temp&gt;maxdepth) maxdepth=temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxdepth;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.1与课后作业</title>
      <link href="/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.1%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE1.1%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1>项目1 约瑟夫生死游戏</h1><h2 id="题目描述">题目描述</h2><p>每30个乘客同乘一艘船，因为严重超载，加上风高浪大，危险万分，因此船长告诉乘客，只有将全船一半乘客投入海中，其余人才能幸免于难。无奈，大家只得同意这种办法，并议定30个人围成一圈，由第1个人数起，依次报数，数到第9人，便把他投入大海中，然后再从他的下一个人数起，数到第9人，再将他扔到大海中，如此循环地进行，直到剩下15个乘客为止。问哪些位置是将被扔下大海的位置。</p><h2 id="解题思路">解题思路</h2><p>采用数组模拟链表解决</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">500</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        a[i] = i + <span class="hljs-number">1</span>;<br><br>    a[n] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, x = <span class="hljs-number">1</span>, last = n;<br>    <span class="hljs-keyword">while</span> (n &gt; k)<br>    &#123;<br>        cnt++;<br>        <span class="hljs-keyword">if</span> (cnt == m)<br>        &#123;<br>            a[last] = a[x];<br>            n--;<br>            cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            cnt = <span class="hljs-number">0</span>;<br>        &#125;<br>        last = x;<br>        x = a[x];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果展示">结果展示</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_6e814e22c8-1.jpg" alt="1.jpg"></p><h1>作业</h1><ol><li>在等概率情况下，顺序表中插入一个结点需平均移动$\frac{n}{2}$个节点，删除一个节点需平均移动$\frac{n-1}{2}$个节点。</li><li>设顺序表L设顺序表L是一个递增有序表，试写一算法，将元素x插入L中，并使L仍是一个有序表。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSqlist</span><span class="hljs-params">(Sqlist *L,Elemtype number)</span></span>&#123;<br><span class="hljs-built_in">assert</span>(L-&gt;length &lt; L-&gt;listsize);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=L-&gt;length;i&gt;<span class="hljs-number">0</span>&amp;&amp;L-&gt;elem[i<span class="hljs-number">-1</span>]&gt;number;i--)&#123;<br>L-&gt;elem[i]=L-&gt;elem[i<span class="hljs-number">-1</span>];<br>&#125;<br>L-&gt;elem[i]=number;<br>L-&gt;length++;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>在一个具有n个链接点的线性链表中查找某一个链接点，若查找成功，需要平均比较©个链接点。</p><p>A. n        B. n/2     C.  (n+1)/2      D.  (n-1)/2</p></li><li><p>下列排序算法中，稳定的排序算法是(AD)。</p><p>A．冒泡排序 B. 选择排序  C．希尔排序 D．简单插入排序</p></li><li><p>数据序列{8，9，10，4，5，6，20，1，2}只能是下列排序算法中的©的两趟排序后的结果。</p><p>A．选择排序 B.冒泡排序 C.插入排序  D.希尔排序</p></li><li><p>已知某链接存储的数据序列的第一个数据的地址为FIR，结点的结构为{key，data，next},请编写一算法，在该数据序列中确定关键字值为def的数据是否存在，若存在，返回数据所在结点的地址，否则，返回null。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> def)</span></span>&#123;<br>LNode *p;<br>p-&gt;next=FIR;<br><span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">if</span>(p-&gt;next-&gt;key==def)<span class="hljs-keyword">break</span>;<br>p=p-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周总结</title>
      <link href="/2022/04/29/%E7%AC%AC%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/29/%E7%AC%AC%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>装了2天，总算把博客建立的大差不差，现在只有一些基本的功能，这周感觉有点摆烂，晚上一定要坚持跑步，然后尽量多利用时光序做好规划，周三晚上算是摆烂，好好利用博客总结发现和分析问题吧，暂时先这样吧。有什么内容晚上再说吧,今天晚上写一下模板,分析下每周的问题。<br>还有就是ACM本周基本没有学习，五一要好好学一下，坚持，努力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#inude <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><p>$RMSE = 1 - \dfrac{\sum_{i=1}^n (y_i - \hat{y}_i)^2} {\sum_{i=1}^n (y_i - \bar{y})^2}$</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每周总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
