<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件技术基础项目1.3与课后作业</title>
      <link href="/2022/04/30/%E9%A1%B9%E7%9B%AE1-3%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E9%A1%B9%E7%9B%AE1-3%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.2与课后作业</title>
      <link href="/2022/04/30/%E9%A1%B9%E7%9B%AE1-2%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/04/30/%E9%A1%B9%E7%9B%AE1-2%E4%B8%8E%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="项目1-2"><a href="#项目1-2" class="headerlink" title="项目1.2"></a>项目1.2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知一个按先序序列输入的字符序列，如abc,,de,g,,f,,,(其中逗号表示空节点)。请建立二叉树并按中序和后序方式遍历二叉树，最后求出叶子节点个数和二叉树深度。<br>输入<br> 输入一个长度小于50个字符的字符串。<br>输出<br>输出共有4行：<br>第1行输出中序遍历序列；</p><p>第2行输出后序遍历序列；</p><p>第3行输出叶子节点个数；</p><p>第4行输出二叉树深度。</p><p>示例输入</p><p>abc,,de,g,,f,,,</p><p>示例输出</p><p>cbegdfa </p><p>cgefdba </p><p>3 </p><p>5</p><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>本实验共需要完成五项任务：</p><ol><li>根据输入先序建立二叉树；</li><li>按中序方式遍历二叉树并输出序列；</li><li>按后序方式遍历二叉树并输出序列；</li><li>求出二叉树的叶子结点个数；</li><li>求出二叉树的深度。</li></ol><h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><ol><li><p>定义二叉树结点数据结构</p><p> 建立一个Node结构体，其中包含一个char类型的data用于存储字母，一个Node类型的<em>Lchild指针指向左子树和一个Node类型的</em>Rchild指针指向右子树。再建立一个指向Node这种结构的*p指针。</p></li><li><p>如何先序建立二叉树？</p><p> 建立一个build(p &amp;T)函数用于先序建立二叉树，T为返回node的指针。函数中定义一个char类型的c用于读入输入，若c为“，”，则为空结点，T=NULL；若T为换行符“\n”，则输入结束并返回；否则c就是字母结点，则创建一个新的指针T，并让T-&gt;data=c，接着递归创建其左子树和右子树。</p></li><li><p>如何按中序、后序方式遍历二叉树并输出序列？</p><p> 要按中序方式遍历二叉树，先访问左子树，再访问根节点，最后访问右子树；要按后序方式遍历二叉树，先访问左子树，再访问右子树，最后访问根节点；在访问根节点时打印该结点的data即可完成输出。</p></li><li><p>如何求出二叉树的叶子结点个数？</p><p> 叶子结点就是左右子树都是空子树的结点，据此完成判断。如果二叉树为空，则叶子结点数为0；如果二叉树只有一个结点，则叶子结点数为1；否则，二叉树的叶子结点数为左右子树叶子结点数之和，据此完成递归。</p></li><li><p>如何求出二叉树的深度？</p><p> 如果二叉树为空，则深度为0；如果二叉树只有一个结点，则深度为1；否则，二叉树的深度为左右子树深度的最大值+1。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">jied</span><br>&#123;<br>    <span class="hljs-type">char</span> date;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">jied</span> *lchild,*rchild;<br>&#125; jied,*p;<br><span class="hljs-type">int</span> d = <span class="hljs-number">0</span>,ma = <span class="hljs-number">0</span>,num = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jianshu</span> <span class="hljs-params">(p &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;ch);<br>    <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;,&#x27;</span>)<br>        T = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        T = <span class="hljs-keyword">new</span> jied;<span class="hljs-comment">// 让指针实体化 new返回的是jied的指针</span><br>        T -&gt; date = ch;<br>        <span class="hljs-built_in">jianshu</span>(T -&gt; lchild);<br>        <span class="hljs-built_in">jianshu</span>(T -&gt; rchild);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zhongxu</span><span class="hljs-params">(p T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">zhongxu</span>(T -&gt; lchild);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T -&gt; date);<br>        <span class="hljs-built_in">zhongxu</span>(T -&gt; rchild);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">houxu</span><span class="hljs-params">(p T,<span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">houxu</span>(T -&gt; lchild,d+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">houxu</span>(T -&gt; rchild,d+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T -&gt; date);<br>        <span class="hljs-keyword">if</span>(ma&lt;d)<br>            ma = d;<span class="hljs-comment">//防止同一层多次相加</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">y</span><span class="hljs-params">(p T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(T -&gt; lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T -&gt; rchild == <span class="hljs-literal">NULL</span>)<br>            num++;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">y</span>(T -&gt; lchild);<br>            <span class="hljs-built_in">y</span>(T -&gt; rchild);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    p T;<br>    <span class="hljs-built_in">jianshu</span>(T);<br>    <span class="hljs-built_in">zhongxu</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">houxu</span>(T,ma);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">y</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ma + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="生成的二叉树"><a href="#生成的二叉树" class="headerlink" title="生成的二叉树"></a>生成的二叉树</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_ec2de90ac8-2.png" alt="2.png"> </p><h3 id="程序结果"><a href="#程序结果" class="headerlink" title="程序结果"></a>程序结果</h3><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_79c34ec1c8-1.jpg" alt="1.jpg"> </p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ol><li><p>一棵树的后序遍历和这棵树对应的二叉树的(B)相同。</p><p> A．先序遍历        B．中序遍历        C．后序遍历        D．层次遍历</p><p> 解答：首先看这个树<br> <img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_986b4bcdc8-1.jpg" alt="1.jpg"> </p><p> 它的后序遍历为25641，将它转换为一个二叉树<br> <img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_9bd29a88c8-4.jpg" alt="4.jpg"> </p><p> 它的中序遍历为256341</p></li><li><p>一棵二叉树的先序序列和中序序列分别我：A B C D E F G H J K L M N和C B E D G F A J H K M L N，则二叉树的后序序列为（A）。</p><p> A. C E G F D B J M N L K H A     B. C E D G F B J H K M N L A</p><p> C. C G F E D B J M N L K H A     D. C E G D F B M N J L K H A</p></li><li><p>【程序说明】本程序完成将二叉树中左、右孩子交换的操作。</p><p> 本程序采用非递归的方法，设立一个堆栈stack存放还没有转换过的结点，它的栈顶指针为tp。交换左、右子树的算法为：</p><p> （1）把根结点放入堆栈。</p><p> （2）当堆栈不空时，取出栈顶元素，交换它的左、右子树，并把它的左、右子树分别入栈。</p><p> （3）重复（2）直到堆栈为空时为止。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span>  <span class="hljs-keyword">struct</span>  <span class="hljs-title class_">node</span>  *tree;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<span class="hljs-type">int</span> data; tree lchild,rchild;&#125;<br><span class="hljs-built_in">exchange</span>(tree t)<br>&#123;  tree  r,p; tree  stack [<span class="hljs-number">500</span>]; <span class="hljs-type">int</span>  tp=<span class="hljs-number">0</span>;<br> stack[tp]=t;<br><span class="hljs-keyword">while</span> (tp&gt;=<span class="hljs-number">0</span>)<br>&#123;<br>    p=stack[tp -- ];<br>    <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)<br>    &#123;  r=p-&gt;lchild; p-&gt;lchild=p-&gt;rchild; p-&gt;rchild=r;<br>    stack[++tp]=p-&gt;lchild; stack[++tp]=p-&gt;rchild;<br>    &#125;<br>&#125;&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础项目1.1与课后作业</title>
      <link href="/2022/04/30/blog2/"/>
      <url>/2022/04/30/blog2/</url>
      
        <content type="html"><![CDATA[<h1 id="项目1-约瑟夫生死游戏"><a href="#项目1-约瑟夫生死游戏" class="headerlink" title="项目1 约瑟夫生死游戏"></a>项目1 约瑟夫生死游戏</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>每30个乘客同乘一艘船，因为严重超载，加上风高浪大，危险万分，因此船长告诉乘客，只有将全船一半乘客投入海中，其余人才能幸免于难。无奈，大家只得同意这种办法，并议定30个人围成一圈，由第1个人数起，依次报数，数到第9人，便把他投入大海中，然后再从他的下一个人数起，数到第9人，再将他扔到大海中，如此循环地进行，直到剩下15个乘客为止。问哪些位置是将被扔下大海的位置。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>采用数组模拟链表解决</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">500</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        a[i] = i + <span class="hljs-number">1</span>;<br><br>    a[n] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, x = <span class="hljs-number">1</span>, last = n;<br>    <span class="hljs-keyword">while</span> (n &gt; k)<br>    &#123;<br>        cnt++;<br>        <span class="hljs-keyword">if</span> (cnt == m)<br>        &#123;<br>            a[last] = a[x];<br>            n--;<br>            cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            cnt = <span class="hljs-number">0</span>;<br>        &#125;<br>        last = x;<br>        x = a[x];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p><img src="https://cdn.acwing.com/media/article/image/2022/04/30/99310_6e814e22c8-1.jpg" alt="1.jpg"> </p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ol><li>在等概率情况下，顺序表中插入一个结点需平均移动$\frac{n}{2}$个节点，删除一个节点需平均移动$\frac{n-1}{2}$个节点。</li><li><p>设顺序表L设顺序表L是一个递增有序表，试写一算法，将元素x插入L中，并使L仍是一个有序表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSqlist</span><span class="hljs-params">(Sqlist *L,Elemtype number)</span></span>&#123;<br><span class="hljs-built_in">assert</span>(L-&gt;length &lt; L-&gt;listsize);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=L-&gt;length;i&gt;<span class="hljs-number">0</span>&amp;&amp;L-&gt;elem[i<span class="hljs-number">-1</span>]&gt;number;i--)&#123;<br>L-&gt;elem[i]=L-&gt;elem[i<span class="hljs-number">-1</span>];<br>&#125;<br>L-&gt;elem[i]=number;<br>L-&gt;length++;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在一个具有n个链接点的线性链表中查找某一个链接点，若查找成功，需要平均比较(C)个链接点。</p><p>A. n        B. n/2     C.  (n+1)/2      D.  (n-1)/2</p></li><li><p>下列排序算法中，稳定的排序算法是(AD)。</p><p> A．冒泡排序 B. 选择排序  C．希尔排序 D．简单插入排序</p></li><li><p>数据序列{8，9，10，4，5，6，20，1，2}只能是下列排序算法中的(C)的两趟排序后的结果。</p><p> A．选择排序 B.冒泡排序 C.插入排序  D.希尔排序</p></li><li>已知某链接存储的数据序列的第一个数据的地址为FIR，结点的结构为{key，data，next},请编写一算法，在该数据序列中确定关键字值为def的数据是否存在，若存在，返回数据所在结点的地址，否则，返回null。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> def)</span></span>&#123;<br>LNode *p;<br>p-&gt;next=FIR;<br><span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">if</span>(p-&gt;next-&gt;key==def)<span class="hljs-keyword">break</span>;<br>p=p-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>math</title>
      <link href="/2022/04/29/math/"/>
      <url>/2022/04/29/math/</url>
      
        <content type="html"><![CDATA[<p>这里是测试math公式的地方<br>这里是测试math公式的地方<br>这里是测试math公式的地方<br>$n!$</p><p>$\frac{a}{b+c}$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一周总结</title>
      <link href="/2022/04/29/blog1/"/>
      <url>/2022/04/29/blog1/</url>
      
        <content type="html"><![CDATA[<p>装了2天，总算把博客建立的大差不差，现在只有一些基本的功能，这周感觉有点摆烂，晚上一定要坚持跑步，然后尽量多利用时光序做好规划，周三晚上算是摆烂，好好利用博客总结发现和分析问题吧，暂时先这样吧。有什么内容晚上再说吧,今天晚上写一下模板,分析下每周的问题。<br>还有就是ACM本周基本没有学习，五一要好好学一下，坚持，努力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#inude <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><p>$RMSE = 1 - \dfrac{\sum<em>{i=1}^n (y_i - \hat{y}_i)^2} {\sum</em>{i=1}^n (y_i - \bar{y})^2}$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 每周总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
